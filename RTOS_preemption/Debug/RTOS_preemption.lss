
RTOS_preemption.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000055e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  000055e6  0000567a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003b8  00800076  00800076  00005690  2**0
                  ALLOC
  3 .stab         00006e1c  00000000  00000000  00005690  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003757  00000000  00000000  0000c4ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000fc03  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000fd43  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000feb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00011afc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000129e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00013794  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  000138f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00013b81  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001434f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 5f 12 	jmp	0x24be	; 0x24be <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ee       	ldi	r30, 0xE6	; 230
      68:	f5 e5       	ldi	r31, 0x55	; 85
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 37       	cpi	r26, 0x76	; 118
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a6 e7       	ldi	r26, 0x76	; 118
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 32       	cpi	r26, 0x2E	; 46
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 62 12 	call	0x24c4	; 0x24c4 <main>
      8a:	0c 94 f1 2a 	jmp	0x55e2	; 0x55e2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 b1 2a 	jmp	0x5562	; 0x5562 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a9 e6       	ldi	r26, 0x69	; 105
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 cd 2a 	jmp	0x559a	; 0x559a <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 bd 2a 	jmp	0x557a	; 0x557a <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 d9 2a 	jmp	0x55b2	; 0x55b2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 bd 2a 	jmp	0x557a	; 0x557a <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 d9 2a 	jmp	0x55b2	; 0x55b2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 b1 2a 	jmp	0x5562	; 0x5562 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	89 e6       	ldi	r24, 0x69	; 105
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 cd 2a 	jmp	0x559a	; 0x559a <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 bd 2a 	jmp	0x557a	; 0x557a <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 d9 2a 	jmp	0x55b2	; 0x55b2 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 bd 2a 	jmp	0x557a	; 0x557a <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 d9 2a 	jmp	0x55b2	; 0x55b2 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 bd 2a 	jmp	0x557a	; 0x557a <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 d9 2a 	jmp	0x55b2	; 0x55b2 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 c1 2a 	jmp	0x5582	; 0x5582 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 dd 2a 	jmp	0x55ba	; 0x55ba <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <DIO_vsetPINDir>:




void DIO_vsetPINDir(char portname,char pinnumber,char direction)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <DIO_vsetPINDir+0x6>
     b4c:	00 d0       	rcall	.+0      	; 0xb4e <DIO_vsetPINDir+0x8>
     b4e:	0f 92       	push	r0
     b50:	cd b7       	in	r28, 0x3d	; 61
     b52:	de b7       	in	r29, 0x3e	; 62
     b54:	89 83       	std	Y+1, r24	; 0x01
     b56:	6a 83       	std	Y+2, r22	; 0x02
     b58:	4b 83       	std	Y+3, r20	; 0x03
	switch(portname)
     b5a:	89 81       	ldd	r24, Y+1	; 0x01
     b5c:	28 2f       	mov	r18, r24
     b5e:	30 e0       	ldi	r19, 0x00	; 0
     b60:	3d 83       	std	Y+5, r19	; 0x05
     b62:	2c 83       	std	Y+4, r18	; 0x04
     b64:	8c 81       	ldd	r24, Y+4	; 0x04
     b66:	9d 81       	ldd	r25, Y+5	; 0x05
     b68:	82 34       	cpi	r24, 0x42	; 66
     b6a:	91 05       	cpc	r25, r1
     b6c:	09 f4       	brne	.+2      	; 0xb70 <DIO_vsetPINDir+0x2a>
     b6e:	44 c0       	rjmp	.+136    	; 0xbf8 <DIO_vsetPINDir+0xb2>
     b70:	2c 81       	ldd	r18, Y+4	; 0x04
     b72:	3d 81       	ldd	r19, Y+5	; 0x05
     b74:	23 34       	cpi	r18, 0x43	; 67
     b76:	31 05       	cpc	r19, r1
     b78:	34 f4       	brge	.+12     	; 0xb86 <DIO_vsetPINDir+0x40>
     b7a:	8c 81       	ldd	r24, Y+4	; 0x04
     b7c:	9d 81       	ldd	r25, Y+5	; 0x05
     b7e:	81 34       	cpi	r24, 0x41	; 65
     b80:	91 05       	cpc	r25, r1
     b82:	71 f0       	breq	.+28     	; 0xba0 <DIO_vsetPINDir+0x5a>
     b84:	bc c0       	rjmp	.+376    	; 0xcfe <DIO_vsetPINDir+0x1b8>
     b86:	2c 81       	ldd	r18, Y+4	; 0x04
     b88:	3d 81       	ldd	r19, Y+5	; 0x05
     b8a:	23 34       	cpi	r18, 0x43	; 67
     b8c:	31 05       	cpc	r19, r1
     b8e:	09 f4       	brne	.+2      	; 0xb92 <DIO_vsetPINDir+0x4c>
     b90:	5f c0       	rjmp	.+190    	; 0xc50 <DIO_vsetPINDir+0x10a>
     b92:	8c 81       	ldd	r24, Y+4	; 0x04
     b94:	9d 81       	ldd	r25, Y+5	; 0x05
     b96:	84 34       	cpi	r24, 0x44	; 68
     b98:	91 05       	cpc	r25, r1
     b9a:	09 f4       	brne	.+2      	; 0xb9e <DIO_vsetPINDir+0x58>
     b9c:	85 c0       	rjmp	.+266    	; 0xca8 <DIO_vsetPINDir+0x162>
     b9e:	af c0       	rjmp	.+350    	; 0xcfe <DIO_vsetPINDir+0x1b8>
	{
		
	
	case 'A':
	if(direction==1)
     ba0:	8b 81       	ldd	r24, Y+3	; 0x03
     ba2:	81 30       	cpi	r24, 0x01	; 1
     ba4:	a1 f4       	brne	.+40     	; 0xbce <DIO_vsetPINDir+0x88>
	{
		DDRA|=(1<<pinnumber);
     ba6:	aa e3       	ldi	r26, 0x3A	; 58
     ba8:	b0 e0       	ldi	r27, 0x00	; 0
     baa:	ea e3       	ldi	r30, 0x3A	; 58
     bac:	f0 e0       	ldi	r31, 0x00	; 0
     bae:	80 81       	ld	r24, Z
     bb0:	48 2f       	mov	r20, r24
     bb2:	8a 81       	ldd	r24, Y+2	; 0x02
     bb4:	28 2f       	mov	r18, r24
     bb6:	30 e0       	ldi	r19, 0x00	; 0
     bb8:	81 e0       	ldi	r24, 0x01	; 1
     bba:	90 e0       	ldi	r25, 0x00	; 0
     bbc:	02 2e       	mov	r0, r18
     bbe:	02 c0       	rjmp	.+4      	; 0xbc4 <DIO_vsetPINDir+0x7e>
     bc0:	88 0f       	add	r24, r24
     bc2:	99 1f       	adc	r25, r25
     bc4:	0a 94       	dec	r0
     bc6:	e2 f7       	brpl	.-8      	; 0xbc0 <DIO_vsetPINDir+0x7a>
     bc8:	84 2b       	or	r24, r20
     bca:	8c 93       	st	X, r24
     bcc:	98 c0       	rjmp	.+304    	; 0xcfe <DIO_vsetPINDir+0x1b8>
	}
	else
	{
		DDRA&=(~(1<<pinnumber));
     bce:	aa e3       	ldi	r26, 0x3A	; 58
     bd0:	b0 e0       	ldi	r27, 0x00	; 0
     bd2:	ea e3       	ldi	r30, 0x3A	; 58
     bd4:	f0 e0       	ldi	r31, 0x00	; 0
     bd6:	80 81       	ld	r24, Z
     bd8:	48 2f       	mov	r20, r24
     bda:	8a 81       	ldd	r24, Y+2	; 0x02
     bdc:	28 2f       	mov	r18, r24
     bde:	30 e0       	ldi	r19, 0x00	; 0
     be0:	81 e0       	ldi	r24, 0x01	; 1
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	02 2e       	mov	r0, r18
     be6:	02 c0       	rjmp	.+4      	; 0xbec <DIO_vsetPINDir+0xa6>
     be8:	88 0f       	add	r24, r24
     bea:	99 1f       	adc	r25, r25
     bec:	0a 94       	dec	r0
     bee:	e2 f7       	brpl	.-8      	; 0xbe8 <DIO_vsetPINDir+0xa2>
     bf0:	80 95       	com	r24
     bf2:	84 23       	and	r24, r20
     bf4:	8c 93       	st	X, r24
     bf6:	83 c0       	rjmp	.+262    	; 0xcfe <DIO_vsetPINDir+0x1b8>
	}
	break;
	case 'B':
	if(direction==1)
     bf8:	8b 81       	ldd	r24, Y+3	; 0x03
     bfa:	81 30       	cpi	r24, 0x01	; 1
     bfc:	a1 f4       	brne	.+40     	; 0xc26 <DIO_vsetPINDir+0xe0>
	{
		DDRB|=(1<<pinnumber);
     bfe:	a7 e3       	ldi	r26, 0x37	; 55
     c00:	b0 e0       	ldi	r27, 0x00	; 0
     c02:	e7 e3       	ldi	r30, 0x37	; 55
     c04:	f0 e0       	ldi	r31, 0x00	; 0
     c06:	80 81       	ld	r24, Z
     c08:	48 2f       	mov	r20, r24
     c0a:	8a 81       	ldd	r24, Y+2	; 0x02
     c0c:	28 2f       	mov	r18, r24
     c0e:	30 e0       	ldi	r19, 0x00	; 0
     c10:	81 e0       	ldi	r24, 0x01	; 1
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	02 2e       	mov	r0, r18
     c16:	02 c0       	rjmp	.+4      	; 0xc1c <DIO_vsetPINDir+0xd6>
     c18:	88 0f       	add	r24, r24
     c1a:	99 1f       	adc	r25, r25
     c1c:	0a 94       	dec	r0
     c1e:	e2 f7       	brpl	.-8      	; 0xc18 <DIO_vsetPINDir+0xd2>
     c20:	84 2b       	or	r24, r20
     c22:	8c 93       	st	X, r24
     c24:	6c c0       	rjmp	.+216    	; 0xcfe <DIO_vsetPINDir+0x1b8>
	}
	else
	{
		DDRB&=(~(1<<pinnumber));
     c26:	a7 e3       	ldi	r26, 0x37	; 55
     c28:	b0 e0       	ldi	r27, 0x00	; 0
     c2a:	e7 e3       	ldi	r30, 0x37	; 55
     c2c:	f0 e0       	ldi	r31, 0x00	; 0
     c2e:	80 81       	ld	r24, Z
     c30:	48 2f       	mov	r20, r24
     c32:	8a 81       	ldd	r24, Y+2	; 0x02
     c34:	28 2f       	mov	r18, r24
     c36:	30 e0       	ldi	r19, 0x00	; 0
     c38:	81 e0       	ldi	r24, 0x01	; 1
     c3a:	90 e0       	ldi	r25, 0x00	; 0
     c3c:	02 2e       	mov	r0, r18
     c3e:	02 c0       	rjmp	.+4      	; 0xc44 <DIO_vsetPINDir+0xfe>
     c40:	88 0f       	add	r24, r24
     c42:	99 1f       	adc	r25, r25
     c44:	0a 94       	dec	r0
     c46:	e2 f7       	brpl	.-8      	; 0xc40 <DIO_vsetPINDir+0xfa>
     c48:	80 95       	com	r24
     c4a:	84 23       	and	r24, r20
     c4c:	8c 93       	st	X, r24
     c4e:	57 c0       	rjmp	.+174    	; 0xcfe <DIO_vsetPINDir+0x1b8>
	}
	break;
	case 'C':
	if(direction==1)
     c50:	8b 81       	ldd	r24, Y+3	; 0x03
     c52:	81 30       	cpi	r24, 0x01	; 1
     c54:	a1 f4       	brne	.+40     	; 0xc7e <DIO_vsetPINDir+0x138>
	{
		DDRC|=(1<<pinnumber);
     c56:	a4 e3       	ldi	r26, 0x34	; 52
     c58:	b0 e0       	ldi	r27, 0x00	; 0
     c5a:	e4 e3       	ldi	r30, 0x34	; 52
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	80 81       	ld	r24, Z
     c60:	48 2f       	mov	r20, r24
     c62:	8a 81       	ldd	r24, Y+2	; 0x02
     c64:	28 2f       	mov	r18, r24
     c66:	30 e0       	ldi	r19, 0x00	; 0
     c68:	81 e0       	ldi	r24, 0x01	; 1
     c6a:	90 e0       	ldi	r25, 0x00	; 0
     c6c:	02 2e       	mov	r0, r18
     c6e:	02 c0       	rjmp	.+4      	; 0xc74 <DIO_vsetPINDir+0x12e>
     c70:	88 0f       	add	r24, r24
     c72:	99 1f       	adc	r25, r25
     c74:	0a 94       	dec	r0
     c76:	e2 f7       	brpl	.-8      	; 0xc70 <DIO_vsetPINDir+0x12a>
     c78:	84 2b       	or	r24, r20
     c7a:	8c 93       	st	X, r24
     c7c:	40 c0       	rjmp	.+128    	; 0xcfe <DIO_vsetPINDir+0x1b8>
	}
	else
	{
		DDRC&=(~(1<<pinnumber));
     c7e:	a4 e3       	ldi	r26, 0x34	; 52
     c80:	b0 e0       	ldi	r27, 0x00	; 0
     c82:	e4 e3       	ldi	r30, 0x34	; 52
     c84:	f0 e0       	ldi	r31, 0x00	; 0
     c86:	80 81       	ld	r24, Z
     c88:	48 2f       	mov	r20, r24
     c8a:	8a 81       	ldd	r24, Y+2	; 0x02
     c8c:	28 2f       	mov	r18, r24
     c8e:	30 e0       	ldi	r19, 0x00	; 0
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	02 2e       	mov	r0, r18
     c96:	02 c0       	rjmp	.+4      	; 0xc9c <DIO_vsetPINDir+0x156>
     c98:	88 0f       	add	r24, r24
     c9a:	99 1f       	adc	r25, r25
     c9c:	0a 94       	dec	r0
     c9e:	e2 f7       	brpl	.-8      	; 0xc98 <DIO_vsetPINDir+0x152>
     ca0:	80 95       	com	r24
     ca2:	84 23       	and	r24, r20
     ca4:	8c 93       	st	X, r24
     ca6:	2b c0       	rjmp	.+86     	; 0xcfe <DIO_vsetPINDir+0x1b8>
	}
	break;
	case 'D':
	if(direction==1)
     ca8:	8b 81       	ldd	r24, Y+3	; 0x03
     caa:	81 30       	cpi	r24, 0x01	; 1
     cac:	a1 f4       	brne	.+40     	; 0xcd6 <DIO_vsetPINDir+0x190>
	{
		DDRD|=(1<<pinnumber);
     cae:	a1 e3       	ldi	r26, 0x31	; 49
     cb0:	b0 e0       	ldi	r27, 0x00	; 0
     cb2:	e1 e3       	ldi	r30, 0x31	; 49
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	80 81       	ld	r24, Z
     cb8:	48 2f       	mov	r20, r24
     cba:	8a 81       	ldd	r24, Y+2	; 0x02
     cbc:	28 2f       	mov	r18, r24
     cbe:	30 e0       	ldi	r19, 0x00	; 0
     cc0:	81 e0       	ldi	r24, 0x01	; 1
     cc2:	90 e0       	ldi	r25, 0x00	; 0
     cc4:	02 2e       	mov	r0, r18
     cc6:	02 c0       	rjmp	.+4      	; 0xccc <DIO_vsetPINDir+0x186>
     cc8:	88 0f       	add	r24, r24
     cca:	99 1f       	adc	r25, r25
     ccc:	0a 94       	dec	r0
     cce:	e2 f7       	brpl	.-8      	; 0xcc8 <DIO_vsetPINDir+0x182>
     cd0:	84 2b       	or	r24, r20
     cd2:	8c 93       	st	X, r24
     cd4:	14 c0       	rjmp	.+40     	; 0xcfe <DIO_vsetPINDir+0x1b8>
	}
	else
	{
		DDRD&=(~(1<<pinnumber));
     cd6:	a1 e3       	ldi	r26, 0x31	; 49
     cd8:	b0 e0       	ldi	r27, 0x00	; 0
     cda:	e1 e3       	ldi	r30, 0x31	; 49
     cdc:	f0 e0       	ldi	r31, 0x00	; 0
     cde:	80 81       	ld	r24, Z
     ce0:	48 2f       	mov	r20, r24
     ce2:	8a 81       	ldd	r24, Y+2	; 0x02
     ce4:	28 2f       	mov	r18, r24
     ce6:	30 e0       	ldi	r19, 0x00	; 0
     ce8:	81 e0       	ldi	r24, 0x01	; 1
     cea:	90 e0       	ldi	r25, 0x00	; 0
     cec:	02 2e       	mov	r0, r18
     cee:	02 c0       	rjmp	.+4      	; 0xcf4 <DIO_vsetPINDir+0x1ae>
     cf0:	88 0f       	add	r24, r24
     cf2:	99 1f       	adc	r25, r25
     cf4:	0a 94       	dec	r0
     cf6:	e2 f7       	brpl	.-8      	; 0xcf0 <DIO_vsetPINDir+0x1aa>
     cf8:	80 95       	com	r24
     cfa:	84 23       	and	r24, r20
     cfc:	8c 93       	st	X, r24
	}
	break;
	default: break;
	}	
}
     cfe:	0f 90       	pop	r0
     d00:	0f 90       	pop	r0
     d02:	0f 90       	pop	r0
     d04:	0f 90       	pop	r0
     d06:	0f 90       	pop	r0
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <DIO_write>:


void DIO_write(char portname,char pinnumber,char outputvalue)
{
     d0e:	df 93       	push	r29
     d10:	cf 93       	push	r28
     d12:	00 d0       	rcall	.+0      	; 0xd14 <DIO_write+0x6>
     d14:	00 d0       	rcall	.+0      	; 0xd16 <DIO_write+0x8>
     d16:	0f 92       	push	r0
     d18:	cd b7       	in	r28, 0x3d	; 61
     d1a:	de b7       	in	r29, 0x3e	; 62
     d1c:	89 83       	std	Y+1, r24	; 0x01
     d1e:	6a 83       	std	Y+2, r22	; 0x02
     d20:	4b 83       	std	Y+3, r20	; 0x03
	switch(portname)
     d22:	89 81       	ldd	r24, Y+1	; 0x01
     d24:	28 2f       	mov	r18, r24
     d26:	30 e0       	ldi	r19, 0x00	; 0
     d28:	3d 83       	std	Y+5, r19	; 0x05
     d2a:	2c 83       	std	Y+4, r18	; 0x04
     d2c:	8c 81       	ldd	r24, Y+4	; 0x04
     d2e:	9d 81       	ldd	r25, Y+5	; 0x05
     d30:	82 34       	cpi	r24, 0x42	; 66
     d32:	91 05       	cpc	r25, r1
     d34:	09 f4       	brne	.+2      	; 0xd38 <DIO_write+0x2a>
     d36:	44 c0       	rjmp	.+136    	; 0xdc0 <DIO_write+0xb2>
     d38:	2c 81       	ldd	r18, Y+4	; 0x04
     d3a:	3d 81       	ldd	r19, Y+5	; 0x05
     d3c:	23 34       	cpi	r18, 0x43	; 67
     d3e:	31 05       	cpc	r19, r1
     d40:	34 f4       	brge	.+12     	; 0xd4e <DIO_write+0x40>
     d42:	8c 81       	ldd	r24, Y+4	; 0x04
     d44:	9d 81       	ldd	r25, Y+5	; 0x05
     d46:	81 34       	cpi	r24, 0x41	; 65
     d48:	91 05       	cpc	r25, r1
     d4a:	71 f0       	breq	.+28     	; 0xd68 <DIO_write+0x5a>
     d4c:	bc c0       	rjmp	.+376    	; 0xec6 <DIO_write+0x1b8>
     d4e:	2c 81       	ldd	r18, Y+4	; 0x04
     d50:	3d 81       	ldd	r19, Y+5	; 0x05
     d52:	23 34       	cpi	r18, 0x43	; 67
     d54:	31 05       	cpc	r19, r1
     d56:	09 f4       	brne	.+2      	; 0xd5a <DIO_write+0x4c>
     d58:	5f c0       	rjmp	.+190    	; 0xe18 <DIO_write+0x10a>
     d5a:	8c 81       	ldd	r24, Y+4	; 0x04
     d5c:	9d 81       	ldd	r25, Y+5	; 0x05
     d5e:	84 34       	cpi	r24, 0x44	; 68
     d60:	91 05       	cpc	r25, r1
     d62:	09 f4       	brne	.+2      	; 0xd66 <DIO_write+0x58>
     d64:	85 c0       	rjmp	.+266    	; 0xe70 <DIO_write+0x162>
     d66:	af c0       	rjmp	.+350    	; 0xec6 <DIO_write+0x1b8>
	{
		case 'A' :
		
			if(outputvalue==1)
     d68:	8b 81       	ldd	r24, Y+3	; 0x03
     d6a:	81 30       	cpi	r24, 0x01	; 1
     d6c:	a1 f4       	brne	.+40     	; 0xd96 <DIO_write+0x88>
			{
				PORTA|=(1<<pinnumber);
     d6e:	ab e3       	ldi	r26, 0x3B	; 59
     d70:	b0 e0       	ldi	r27, 0x00	; 0
     d72:	eb e3       	ldi	r30, 0x3B	; 59
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	80 81       	ld	r24, Z
     d78:	48 2f       	mov	r20, r24
     d7a:	8a 81       	ldd	r24, Y+2	; 0x02
     d7c:	28 2f       	mov	r18, r24
     d7e:	30 e0       	ldi	r19, 0x00	; 0
     d80:	81 e0       	ldi	r24, 0x01	; 1
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	02 2e       	mov	r0, r18
     d86:	02 c0       	rjmp	.+4      	; 0xd8c <DIO_write+0x7e>
     d88:	88 0f       	add	r24, r24
     d8a:	99 1f       	adc	r25, r25
     d8c:	0a 94       	dec	r0
     d8e:	e2 f7       	brpl	.-8      	; 0xd88 <DIO_write+0x7a>
     d90:	84 2b       	or	r24, r20
     d92:	8c 93       	st	X, r24
     d94:	98 c0       	rjmp	.+304    	; 0xec6 <DIO_write+0x1b8>
			}
			else
			{
				PORTA&=(~(1<<pinnumber));
     d96:	ab e3       	ldi	r26, 0x3B	; 59
     d98:	b0 e0       	ldi	r27, 0x00	; 0
     d9a:	eb e3       	ldi	r30, 0x3B	; 59
     d9c:	f0 e0       	ldi	r31, 0x00	; 0
     d9e:	80 81       	ld	r24, Z
     da0:	48 2f       	mov	r20, r24
     da2:	8a 81       	ldd	r24, Y+2	; 0x02
     da4:	28 2f       	mov	r18, r24
     da6:	30 e0       	ldi	r19, 0x00	; 0
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	90 e0       	ldi	r25, 0x00	; 0
     dac:	02 2e       	mov	r0, r18
     dae:	02 c0       	rjmp	.+4      	; 0xdb4 <DIO_write+0xa6>
     db0:	88 0f       	add	r24, r24
     db2:	99 1f       	adc	r25, r25
     db4:	0a 94       	dec	r0
     db6:	e2 f7       	brpl	.-8      	; 0xdb0 <DIO_write+0xa2>
     db8:	80 95       	com	r24
     dba:	84 23       	and	r24, r20
     dbc:	8c 93       	st	X, r24
     dbe:	83 c0       	rjmp	.+262    	; 0xec6 <DIO_write+0x1b8>
			}
			break ;
			case 'B':
			
			if(outputvalue==1)
     dc0:	8b 81       	ldd	r24, Y+3	; 0x03
     dc2:	81 30       	cpi	r24, 0x01	; 1
     dc4:	a1 f4       	brne	.+40     	; 0xdee <DIO_write+0xe0>
			{
				PORTB|=(1<<pinnumber);
     dc6:	a8 e3       	ldi	r26, 0x38	; 56
     dc8:	b0 e0       	ldi	r27, 0x00	; 0
     dca:	e8 e3       	ldi	r30, 0x38	; 56
     dcc:	f0 e0       	ldi	r31, 0x00	; 0
     dce:	80 81       	ld	r24, Z
     dd0:	48 2f       	mov	r20, r24
     dd2:	8a 81       	ldd	r24, Y+2	; 0x02
     dd4:	28 2f       	mov	r18, r24
     dd6:	30 e0       	ldi	r19, 0x00	; 0
     dd8:	81 e0       	ldi	r24, 0x01	; 1
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	02 2e       	mov	r0, r18
     dde:	02 c0       	rjmp	.+4      	; 0xde4 <DIO_write+0xd6>
     de0:	88 0f       	add	r24, r24
     de2:	99 1f       	adc	r25, r25
     de4:	0a 94       	dec	r0
     de6:	e2 f7       	brpl	.-8      	; 0xde0 <DIO_write+0xd2>
     de8:	84 2b       	or	r24, r20
     dea:	8c 93       	st	X, r24
     dec:	6c c0       	rjmp	.+216    	; 0xec6 <DIO_write+0x1b8>
			}
			else
			{
				PORTB&=(~(1<<pinnumber));
     dee:	a8 e3       	ldi	r26, 0x38	; 56
     df0:	b0 e0       	ldi	r27, 0x00	; 0
     df2:	e8 e3       	ldi	r30, 0x38	; 56
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	80 81       	ld	r24, Z
     df8:	48 2f       	mov	r20, r24
     dfa:	8a 81       	ldd	r24, Y+2	; 0x02
     dfc:	28 2f       	mov	r18, r24
     dfe:	30 e0       	ldi	r19, 0x00	; 0
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	02 2e       	mov	r0, r18
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <DIO_write+0xfe>
     e08:	88 0f       	add	r24, r24
     e0a:	99 1f       	adc	r25, r25
     e0c:	0a 94       	dec	r0
     e0e:	e2 f7       	brpl	.-8      	; 0xe08 <DIO_write+0xfa>
     e10:	80 95       	com	r24
     e12:	84 23       	and	r24, r20
     e14:	8c 93       	st	X, r24
     e16:	57 c0       	rjmp	.+174    	; 0xec6 <DIO_write+0x1b8>
			}
			break ;
			case 'C' :
			
			if(outputvalue==1)
     e18:	8b 81       	ldd	r24, Y+3	; 0x03
     e1a:	81 30       	cpi	r24, 0x01	; 1
     e1c:	a1 f4       	brne	.+40     	; 0xe46 <DIO_write+0x138>
			{
				PORTC|=(1<<pinnumber);
     e1e:	a5 e3       	ldi	r26, 0x35	; 53
     e20:	b0 e0       	ldi	r27, 0x00	; 0
     e22:	e5 e3       	ldi	r30, 0x35	; 53
     e24:	f0 e0       	ldi	r31, 0x00	; 0
     e26:	80 81       	ld	r24, Z
     e28:	48 2f       	mov	r20, r24
     e2a:	8a 81       	ldd	r24, Y+2	; 0x02
     e2c:	28 2f       	mov	r18, r24
     e2e:	30 e0       	ldi	r19, 0x00	; 0
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	90 e0       	ldi	r25, 0x00	; 0
     e34:	02 2e       	mov	r0, r18
     e36:	02 c0       	rjmp	.+4      	; 0xe3c <DIO_write+0x12e>
     e38:	88 0f       	add	r24, r24
     e3a:	99 1f       	adc	r25, r25
     e3c:	0a 94       	dec	r0
     e3e:	e2 f7       	brpl	.-8      	; 0xe38 <DIO_write+0x12a>
     e40:	84 2b       	or	r24, r20
     e42:	8c 93       	st	X, r24
     e44:	40 c0       	rjmp	.+128    	; 0xec6 <DIO_write+0x1b8>
			}
			else
			{
				PORTC&=(~(1<<pinnumber));
     e46:	a5 e3       	ldi	r26, 0x35	; 53
     e48:	b0 e0       	ldi	r27, 0x00	; 0
     e4a:	e5 e3       	ldi	r30, 0x35	; 53
     e4c:	f0 e0       	ldi	r31, 0x00	; 0
     e4e:	80 81       	ld	r24, Z
     e50:	48 2f       	mov	r20, r24
     e52:	8a 81       	ldd	r24, Y+2	; 0x02
     e54:	28 2f       	mov	r18, r24
     e56:	30 e0       	ldi	r19, 0x00	; 0
     e58:	81 e0       	ldi	r24, 0x01	; 1
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	02 2e       	mov	r0, r18
     e5e:	02 c0       	rjmp	.+4      	; 0xe64 <DIO_write+0x156>
     e60:	88 0f       	add	r24, r24
     e62:	99 1f       	adc	r25, r25
     e64:	0a 94       	dec	r0
     e66:	e2 f7       	brpl	.-8      	; 0xe60 <DIO_write+0x152>
     e68:	80 95       	com	r24
     e6a:	84 23       	and	r24, r20
     e6c:	8c 93       	st	X, r24
     e6e:	2b c0       	rjmp	.+86     	; 0xec6 <DIO_write+0x1b8>
			}
			break ;
		case 'D':
		
		if(outputvalue==1)
     e70:	8b 81       	ldd	r24, Y+3	; 0x03
     e72:	81 30       	cpi	r24, 0x01	; 1
     e74:	a1 f4       	brne	.+40     	; 0xe9e <DIO_write+0x190>
		{
			PORTD|=(1<<pinnumber);
     e76:	a2 e3       	ldi	r26, 0x32	; 50
     e78:	b0 e0       	ldi	r27, 0x00	; 0
     e7a:	e2 e3       	ldi	r30, 0x32	; 50
     e7c:	f0 e0       	ldi	r31, 0x00	; 0
     e7e:	80 81       	ld	r24, Z
     e80:	48 2f       	mov	r20, r24
     e82:	8a 81       	ldd	r24, Y+2	; 0x02
     e84:	28 2f       	mov	r18, r24
     e86:	30 e0       	ldi	r19, 0x00	; 0
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	02 2e       	mov	r0, r18
     e8e:	02 c0       	rjmp	.+4      	; 0xe94 <DIO_write+0x186>
     e90:	88 0f       	add	r24, r24
     e92:	99 1f       	adc	r25, r25
     e94:	0a 94       	dec	r0
     e96:	e2 f7       	brpl	.-8      	; 0xe90 <DIO_write+0x182>
     e98:	84 2b       	or	r24, r20
     e9a:	8c 93       	st	X, r24
     e9c:	14 c0       	rjmp	.+40     	; 0xec6 <DIO_write+0x1b8>
		}
		else
	{
			PORTD&=(~(1<<pinnumber));
     e9e:	a2 e3       	ldi	r26, 0x32	; 50
     ea0:	b0 e0       	ldi	r27, 0x00	; 0
     ea2:	e2 e3       	ldi	r30, 0x32	; 50
     ea4:	f0 e0       	ldi	r31, 0x00	; 0
     ea6:	80 81       	ld	r24, Z
     ea8:	48 2f       	mov	r20, r24
     eaa:	8a 81       	ldd	r24, Y+2	; 0x02
     eac:	28 2f       	mov	r18, r24
     eae:	30 e0       	ldi	r19, 0x00	; 0
     eb0:	81 e0       	ldi	r24, 0x01	; 1
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	02 2e       	mov	r0, r18
     eb6:	02 c0       	rjmp	.+4      	; 0xebc <DIO_write+0x1ae>
     eb8:	88 0f       	add	r24, r24
     eba:	99 1f       	adc	r25, r25
     ebc:	0a 94       	dec	r0
     ebe:	e2 f7       	brpl	.-8      	; 0xeb8 <DIO_write+0x1aa>
     ec0:	80 95       	com	r24
     ec2:	84 23       	and	r24, r20
     ec4:	8c 93       	st	X, r24
		}
		break ;
		default: break ;
	}
}
     ec6:	0f 90       	pop	r0
     ec8:	0f 90       	pop	r0
     eca:	0f 90       	pop	r0
     ecc:	0f 90       	pop	r0
     ece:	0f 90       	pop	r0
     ed0:	cf 91       	pop	r28
     ed2:	df 91       	pop	r29
     ed4:	08 95       	ret

00000ed6 <DIO_u8read>:


char DIO_u8read(char portname,char pinnumber)
{
     ed6:	df 93       	push	r29
     ed8:	cf 93       	push	r28
     eda:	00 d0       	rcall	.+0      	; 0xedc <DIO_u8read+0x6>
     edc:	00 d0       	rcall	.+0      	; 0xede <DIO_u8read+0x8>
     ede:	0f 92       	push	r0
     ee0:	cd b7       	in	r28, 0x3d	; 61
     ee2:	de b7       	in	r29, 0x3e	; 62
     ee4:	8a 83       	std	Y+2, r24	; 0x02
     ee6:	6b 83       	std	Y+3, r22	; 0x03
	char x ;
	switch(portname)
     ee8:	8a 81       	ldd	r24, Y+2	; 0x02
     eea:	28 2f       	mov	r18, r24
     eec:	30 e0       	ldi	r19, 0x00	; 0
     eee:	3d 83       	std	Y+5, r19	; 0x05
     ef0:	2c 83       	std	Y+4, r18	; 0x04
     ef2:	4c 81       	ldd	r20, Y+4	; 0x04
     ef4:	5d 81       	ldd	r21, Y+5	; 0x05
     ef6:	42 34       	cpi	r20, 0x42	; 66
     ef8:	51 05       	cpc	r21, r1
     efa:	b1 f1       	breq	.+108    	; 0xf68 <DIO_u8read+0x92>
     efc:	8c 81       	ldd	r24, Y+4	; 0x04
     efe:	9d 81       	ldd	r25, Y+5	; 0x05
     f00:	83 34       	cpi	r24, 0x43	; 67
     f02:	91 05       	cpc	r25, r1
     f04:	34 f4       	brge	.+12     	; 0xf12 <DIO_u8read+0x3c>
     f06:	2c 81       	ldd	r18, Y+4	; 0x04
     f08:	3d 81       	ldd	r19, Y+5	; 0x05
     f0a:	21 34       	cpi	r18, 0x41	; 65
     f0c:	31 05       	cpc	r19, r1
     f0e:	71 f0       	breq	.+28     	; 0xf2c <DIO_u8read+0x56>
     f10:	84 c0       	rjmp	.+264    	; 0x101a <DIO_u8read+0x144>
     f12:	4c 81       	ldd	r20, Y+4	; 0x04
     f14:	5d 81       	ldd	r21, Y+5	; 0x05
     f16:	43 34       	cpi	r20, 0x43	; 67
     f18:	51 05       	cpc	r21, r1
     f1a:	09 f4       	brne	.+2      	; 0xf1e <DIO_u8read+0x48>
     f1c:	43 c0       	rjmp	.+134    	; 0xfa4 <DIO_u8read+0xce>
     f1e:	8c 81       	ldd	r24, Y+4	; 0x04
     f20:	9d 81       	ldd	r25, Y+5	; 0x05
     f22:	84 34       	cpi	r24, 0x44	; 68
     f24:	91 05       	cpc	r25, r1
     f26:	09 f4       	brne	.+2      	; 0xf2a <DIO_u8read+0x54>
     f28:	5b c0       	rjmp	.+182    	; 0xfe0 <DIO_u8read+0x10a>
     f2a:	77 c0       	rjmp	.+238    	; 0x101a <DIO_u8read+0x144>
	{
		case 'A' :
		x=((PINA&(1<<pinnumber))>>pinnumber);
     f2c:	e9 e3       	ldi	r30, 0x39	; 57
     f2e:	f0 e0       	ldi	r31, 0x00	; 0
     f30:	80 81       	ld	r24, Z
     f32:	48 2f       	mov	r20, r24
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	8b 81       	ldd	r24, Y+3	; 0x03
     f38:	28 2f       	mov	r18, r24
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	90 e0       	ldi	r25, 0x00	; 0
     f40:	02 c0       	rjmp	.+4      	; 0xf46 <DIO_u8read+0x70>
     f42:	88 0f       	add	r24, r24
     f44:	99 1f       	adc	r25, r25
     f46:	2a 95       	dec	r18
     f48:	e2 f7       	brpl	.-8      	; 0xf42 <DIO_u8read+0x6c>
     f4a:	9a 01       	movw	r18, r20
     f4c:	28 23       	and	r18, r24
     f4e:	39 23       	and	r19, r25
     f50:	8b 81       	ldd	r24, Y+3	; 0x03
     f52:	88 2f       	mov	r24, r24
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	a9 01       	movw	r20, r18
     f58:	02 c0       	rjmp	.+4      	; 0xf5e <DIO_u8read+0x88>
     f5a:	55 95       	asr	r21
     f5c:	47 95       	ror	r20
     f5e:	8a 95       	dec	r24
     f60:	e2 f7       	brpl	.-8      	; 0xf5a <DIO_u8read+0x84>
     f62:	ca 01       	movw	r24, r20
     f64:	89 83       	std	Y+1, r24	; 0x01
     f66:	59 c0       	rjmp	.+178    	; 0x101a <DIO_u8read+0x144>
		break;
		
	case 'B' :
	x=((PINB&(1<<pinnumber))>>pinnumber) ;
     f68:	e6 e3       	ldi	r30, 0x36	; 54
     f6a:	f0 e0       	ldi	r31, 0x00	; 0
     f6c:	80 81       	ld	r24, Z
     f6e:	48 2f       	mov	r20, r24
     f70:	50 e0       	ldi	r21, 0x00	; 0
     f72:	8b 81       	ldd	r24, Y+3	; 0x03
     f74:	28 2f       	mov	r18, r24
     f76:	30 e0       	ldi	r19, 0x00	; 0
     f78:	81 e0       	ldi	r24, 0x01	; 1
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	02 c0       	rjmp	.+4      	; 0xf82 <DIO_u8read+0xac>
     f7e:	88 0f       	add	r24, r24
     f80:	99 1f       	adc	r25, r25
     f82:	2a 95       	dec	r18
     f84:	e2 f7       	brpl	.-8      	; 0xf7e <DIO_u8read+0xa8>
     f86:	9a 01       	movw	r18, r20
     f88:	28 23       	and	r18, r24
     f8a:	39 23       	and	r19, r25
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 2f       	mov	r24, r24
     f90:	90 e0       	ldi	r25, 0x00	; 0
     f92:	a9 01       	movw	r20, r18
     f94:	02 c0       	rjmp	.+4      	; 0xf9a <DIO_u8read+0xc4>
     f96:	55 95       	asr	r21
     f98:	47 95       	ror	r20
     f9a:	8a 95       	dec	r24
     f9c:	e2 f7       	brpl	.-8      	; 0xf96 <DIO_u8read+0xc0>
     f9e:	ca 01       	movw	r24, r20
     fa0:	89 83       	std	Y+1, r24	; 0x01
     fa2:	3b c0       	rjmp	.+118    	; 0x101a <DIO_u8read+0x144>
	break;
	
	case 'C' :
	x=((PINC&(1<<pinnumber))>>pinnumber) ;
     fa4:	e3 e3       	ldi	r30, 0x33	; 51
     fa6:	f0 e0       	ldi	r31, 0x00	; 0
     fa8:	80 81       	ld	r24, Z
     faa:	48 2f       	mov	r20, r24
     fac:	50 e0       	ldi	r21, 0x00	; 0
     fae:	8b 81       	ldd	r24, Y+3	; 0x03
     fb0:	28 2f       	mov	r18, r24
     fb2:	30 e0       	ldi	r19, 0x00	; 0
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	02 c0       	rjmp	.+4      	; 0xfbe <DIO_u8read+0xe8>
     fba:	88 0f       	add	r24, r24
     fbc:	99 1f       	adc	r25, r25
     fbe:	2a 95       	dec	r18
     fc0:	e2 f7       	brpl	.-8      	; 0xfba <DIO_u8read+0xe4>
     fc2:	9a 01       	movw	r18, r20
     fc4:	28 23       	and	r18, r24
     fc6:	39 23       	and	r19, r25
     fc8:	8b 81       	ldd	r24, Y+3	; 0x03
     fca:	88 2f       	mov	r24, r24
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	a9 01       	movw	r20, r18
     fd0:	02 c0       	rjmp	.+4      	; 0xfd6 <DIO_u8read+0x100>
     fd2:	55 95       	asr	r21
     fd4:	47 95       	ror	r20
     fd6:	8a 95       	dec	r24
     fd8:	e2 f7       	brpl	.-8      	; 0xfd2 <DIO_u8read+0xfc>
     fda:	ca 01       	movw	r24, r20
     fdc:	89 83       	std	Y+1, r24	; 0x01
     fde:	1d c0       	rjmp	.+58     	; 0x101a <DIO_u8read+0x144>
	break;
	
	case 'D' :
	x=((PIND&(1<<pinnumber))>>pinnumber) ;
     fe0:	e0 e3       	ldi	r30, 0x30	; 48
     fe2:	f0 e0       	ldi	r31, 0x00	; 0
     fe4:	80 81       	ld	r24, Z
     fe6:	48 2f       	mov	r20, r24
     fe8:	50 e0       	ldi	r21, 0x00	; 0
     fea:	8b 81       	ldd	r24, Y+3	; 0x03
     fec:	28 2f       	mov	r18, r24
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	81 e0       	ldi	r24, 0x01	; 1
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	02 c0       	rjmp	.+4      	; 0xffa <DIO_u8read+0x124>
     ff6:	88 0f       	add	r24, r24
     ff8:	99 1f       	adc	r25, r25
     ffa:	2a 95       	dec	r18
     ffc:	e2 f7       	brpl	.-8      	; 0xff6 <DIO_u8read+0x120>
     ffe:	9a 01       	movw	r18, r20
    1000:	28 23       	and	r18, r24
    1002:	39 23       	and	r19, r25
    1004:	8b 81       	ldd	r24, Y+3	; 0x03
    1006:	88 2f       	mov	r24, r24
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	a9 01       	movw	r20, r18
    100c:	02 c0       	rjmp	.+4      	; 0x1012 <DIO_u8read+0x13c>
    100e:	55 95       	asr	r21
    1010:	47 95       	ror	r20
    1012:	8a 95       	dec	r24
    1014:	e2 f7       	brpl	.-8      	; 0x100e <DIO_u8read+0x138>
    1016:	ca 01       	movw	r24, r20
    1018:	89 83       	std	Y+1, r24	; 0x01
	break;
	default: break;
}
return x ;
    101a:	89 81       	ldd	r24, Y+1	; 0x01
}
    101c:	0f 90       	pop	r0
    101e:	0f 90       	pop	r0
    1020:	0f 90       	pop	r0
    1022:	0f 90       	pop	r0
    1024:	0f 90       	pop	r0
    1026:	cf 91       	pop	r28
    1028:	df 91       	pop	r29
    102a:	08 95       	ret

0000102c <DIO_toggle>:
void DIO_toggle(char portname,char pinnumber)
{
    102c:	df 93       	push	r29
    102e:	cf 93       	push	r28
    1030:	00 d0       	rcall	.+0      	; 0x1032 <DIO_toggle+0x6>
    1032:	00 d0       	rcall	.+0      	; 0x1034 <DIO_toggle+0x8>
    1034:	cd b7       	in	r28, 0x3d	; 61
    1036:	de b7       	in	r29, 0x3e	; 62
    1038:	89 83       	std	Y+1, r24	; 0x01
    103a:	6a 83       	std	Y+2, r22	; 0x02
	switch(portname)
    103c:	89 81       	ldd	r24, Y+1	; 0x01
    103e:	28 2f       	mov	r18, r24
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	3c 83       	std	Y+4, r19	; 0x04
    1044:	2b 83       	std	Y+3, r18	; 0x03
    1046:	8b 81       	ldd	r24, Y+3	; 0x03
    1048:	9c 81       	ldd	r25, Y+4	; 0x04
    104a:	82 34       	cpi	r24, 0x42	; 66
    104c:	91 05       	cpc	r25, r1
    104e:	51 f1       	breq	.+84     	; 0x10a4 <DIO_toggle+0x78>
    1050:	2b 81       	ldd	r18, Y+3	; 0x03
    1052:	3c 81       	ldd	r19, Y+4	; 0x04
    1054:	23 34       	cpi	r18, 0x43	; 67
    1056:	31 05       	cpc	r19, r1
    1058:	34 f4       	brge	.+12     	; 0x1066 <DIO_toggle+0x3a>
    105a:	8b 81       	ldd	r24, Y+3	; 0x03
    105c:	9c 81       	ldd	r25, Y+4	; 0x04
    105e:	81 34       	cpi	r24, 0x41	; 65
    1060:	91 05       	cpc	r25, r1
    1062:	61 f0       	breq	.+24     	; 0x107c <DIO_toggle+0x50>
    1064:	5a c0       	rjmp	.+180    	; 0x111a <DIO_toggle+0xee>
    1066:	2b 81       	ldd	r18, Y+3	; 0x03
    1068:	3c 81       	ldd	r19, Y+4	; 0x04
    106a:	23 34       	cpi	r18, 0x43	; 67
    106c:	31 05       	cpc	r19, r1
    106e:	71 f1       	breq	.+92     	; 0x10cc <DIO_toggle+0xa0>
    1070:	8b 81       	ldd	r24, Y+3	; 0x03
    1072:	9c 81       	ldd	r25, Y+4	; 0x04
    1074:	84 34       	cpi	r24, 0x44	; 68
    1076:	91 05       	cpc	r25, r1
    1078:	e9 f1       	breq	.+122    	; 0x10f4 <DIO_toggle+0xc8>
    107a:	4f c0       	rjmp	.+158    	; 0x111a <DIO_toggle+0xee>
	{
		case 'A':
		PORTA^=(1<<pinnumber);
    107c:	ab e3       	ldi	r26, 0x3B	; 59
    107e:	b0 e0       	ldi	r27, 0x00	; 0
    1080:	eb e3       	ldi	r30, 0x3B	; 59
    1082:	f0 e0       	ldi	r31, 0x00	; 0
    1084:	80 81       	ld	r24, Z
    1086:	48 2f       	mov	r20, r24
    1088:	8a 81       	ldd	r24, Y+2	; 0x02
    108a:	28 2f       	mov	r18, r24
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	02 2e       	mov	r0, r18
    1094:	02 c0       	rjmp	.+4      	; 0x109a <DIO_toggle+0x6e>
    1096:	88 0f       	add	r24, r24
    1098:	99 1f       	adc	r25, r25
    109a:	0a 94       	dec	r0
    109c:	e2 f7       	brpl	.-8      	; 0x1096 <DIO_toggle+0x6a>
    109e:	84 27       	eor	r24, r20
    10a0:	8c 93       	st	X, r24
    10a2:	3b c0       	rjmp	.+118    	; 0x111a <DIO_toggle+0xee>
		break;
		case 'B':
		PORTB^=(1<<pinnumber);
    10a4:	a8 e3       	ldi	r26, 0x38	; 56
    10a6:	b0 e0       	ldi	r27, 0x00	; 0
    10a8:	e8 e3       	ldi	r30, 0x38	; 56
    10aa:	f0 e0       	ldi	r31, 0x00	; 0
    10ac:	80 81       	ld	r24, Z
    10ae:	48 2f       	mov	r20, r24
    10b0:	8a 81       	ldd	r24, Y+2	; 0x02
    10b2:	28 2f       	mov	r18, r24
    10b4:	30 e0       	ldi	r19, 0x00	; 0
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	02 2e       	mov	r0, r18
    10bc:	02 c0       	rjmp	.+4      	; 0x10c2 <DIO_toggle+0x96>
    10be:	88 0f       	add	r24, r24
    10c0:	99 1f       	adc	r25, r25
    10c2:	0a 94       	dec	r0
    10c4:	e2 f7       	brpl	.-8      	; 0x10be <DIO_toggle+0x92>
    10c6:	84 27       	eor	r24, r20
    10c8:	8c 93       	st	X, r24
    10ca:	27 c0       	rjmp	.+78     	; 0x111a <DIO_toggle+0xee>
		break;
		case 'C':
		PORTC^=(1<<pinnumber);
    10cc:	a5 e3       	ldi	r26, 0x35	; 53
    10ce:	b0 e0       	ldi	r27, 0x00	; 0
    10d0:	e5 e3       	ldi	r30, 0x35	; 53
    10d2:	f0 e0       	ldi	r31, 0x00	; 0
    10d4:	80 81       	ld	r24, Z
    10d6:	48 2f       	mov	r20, r24
    10d8:	8a 81       	ldd	r24, Y+2	; 0x02
    10da:	28 2f       	mov	r18, r24
    10dc:	30 e0       	ldi	r19, 0x00	; 0
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	02 2e       	mov	r0, r18
    10e4:	02 c0       	rjmp	.+4      	; 0x10ea <DIO_toggle+0xbe>
    10e6:	88 0f       	add	r24, r24
    10e8:	99 1f       	adc	r25, r25
    10ea:	0a 94       	dec	r0
    10ec:	e2 f7       	brpl	.-8      	; 0x10e6 <DIO_toggle+0xba>
    10ee:	84 27       	eor	r24, r20
    10f0:	8c 93       	st	X, r24
    10f2:	13 c0       	rjmp	.+38     	; 0x111a <DIO_toggle+0xee>
		break;
		case 'D':
		PORTD^=(1<<pinnumber);
    10f4:	a2 e3       	ldi	r26, 0x32	; 50
    10f6:	b0 e0       	ldi	r27, 0x00	; 0
    10f8:	e2 e3       	ldi	r30, 0x32	; 50
    10fa:	f0 e0       	ldi	r31, 0x00	; 0
    10fc:	80 81       	ld	r24, Z
    10fe:	48 2f       	mov	r20, r24
    1100:	8a 81       	ldd	r24, Y+2	; 0x02
    1102:	28 2f       	mov	r18, r24
    1104:	30 e0       	ldi	r19, 0x00	; 0
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	02 2e       	mov	r0, r18
    110c:	02 c0       	rjmp	.+4      	; 0x1112 <DIO_toggle+0xe6>
    110e:	88 0f       	add	r24, r24
    1110:	99 1f       	adc	r25, r25
    1112:	0a 94       	dec	r0
    1114:	e2 f7       	brpl	.-8      	; 0x110e <DIO_toggle+0xe2>
    1116:	84 27       	eor	r24, r20
    1118:	8c 93       	st	X, r24
		break;
		default: break;
	}
}
    111a:	0f 90       	pop	r0
    111c:	0f 90       	pop	r0
    111e:	0f 90       	pop	r0
    1120:	0f 90       	pop	r0
    1122:	cf 91       	pop	r28
    1124:	df 91       	pop	r29
    1126:	08 95       	ret

00001128 <DIO_write_port>:
void DIO_write_port(char portname,char portvalue)
{
    1128:	df 93       	push	r29
    112a:	cf 93       	push	r28
    112c:	00 d0       	rcall	.+0      	; 0x112e <DIO_write_port+0x6>
    112e:	00 d0       	rcall	.+0      	; 0x1130 <DIO_write_port+0x8>
    1130:	cd b7       	in	r28, 0x3d	; 61
    1132:	de b7       	in	r29, 0x3e	; 62
    1134:	89 83       	std	Y+1, r24	; 0x01
    1136:	6a 83       	std	Y+2, r22	; 0x02
	switch(portname)
    1138:	89 81       	ldd	r24, Y+1	; 0x01
    113a:	28 2f       	mov	r18, r24
    113c:	30 e0       	ldi	r19, 0x00	; 0
    113e:	3c 83       	std	Y+4, r19	; 0x04
    1140:	2b 83       	std	Y+3, r18	; 0x03
    1142:	8b 81       	ldd	r24, Y+3	; 0x03
    1144:	9c 81       	ldd	r25, Y+4	; 0x04
    1146:	82 34       	cpi	r24, 0x42	; 66
    1148:	91 05       	cpc	r25, r1
    114a:	d9 f0       	breq	.+54     	; 0x1182 <DIO_write_port+0x5a>
    114c:	2b 81       	ldd	r18, Y+3	; 0x03
    114e:	3c 81       	ldd	r19, Y+4	; 0x04
    1150:	23 34       	cpi	r18, 0x43	; 67
    1152:	31 05       	cpc	r19, r1
    1154:	34 f4       	brge	.+12     	; 0x1162 <DIO_write_port+0x3a>
    1156:	8b 81       	ldd	r24, Y+3	; 0x03
    1158:	9c 81       	ldd	r25, Y+4	; 0x04
    115a:	81 34       	cpi	r24, 0x41	; 65
    115c:	91 05       	cpc	r25, r1
    115e:	61 f0       	breq	.+24     	; 0x1178 <DIO_write_port+0x50>
    1160:	1e c0       	rjmp	.+60     	; 0x119e <DIO_write_port+0x76>
    1162:	2b 81       	ldd	r18, Y+3	; 0x03
    1164:	3c 81       	ldd	r19, Y+4	; 0x04
    1166:	23 34       	cpi	r18, 0x43	; 67
    1168:	31 05       	cpc	r19, r1
    116a:	81 f0       	breq	.+32     	; 0x118c <DIO_write_port+0x64>
    116c:	8b 81       	ldd	r24, Y+3	; 0x03
    116e:	9c 81       	ldd	r25, Y+4	; 0x04
    1170:	84 34       	cpi	r24, 0x44	; 68
    1172:	91 05       	cpc	r25, r1
    1174:	81 f0       	breq	.+32     	; 0x1196 <DIO_write_port+0x6e>
    1176:	13 c0       	rjmp	.+38     	; 0x119e <DIO_write_port+0x76>
	{
		case 'A' :
		PORTA=portvalue;
    1178:	eb e3       	ldi	r30, 0x3B	; 59
    117a:	f0 e0       	ldi	r31, 0x00	; 0
    117c:	8a 81       	ldd	r24, Y+2	; 0x02
    117e:	80 83       	st	Z, r24
    1180:	0e c0       	rjmp	.+28     	; 0x119e <DIO_write_port+0x76>
		break ;
		case 'B':
		PORTB=portvalue;
    1182:	e8 e3       	ldi	r30, 0x38	; 56
    1184:	f0 e0       	ldi	r31, 0x00	; 0
    1186:	8a 81       	ldd	r24, Y+2	; 0x02
    1188:	80 83       	st	Z, r24
    118a:	09 c0       	rjmp	.+18     	; 0x119e <DIO_write_port+0x76>
		break ;
		case 'C' :
		PORTC=portvalue;
    118c:	e5 e3       	ldi	r30, 0x35	; 53
    118e:	f0 e0       	ldi	r31, 0x00	; 0
    1190:	8a 81       	ldd	r24, Y+2	; 0x02
    1192:	80 83       	st	Z, r24
    1194:	04 c0       	rjmp	.+8      	; 0x119e <DIO_write_port+0x76>
		break ;
		case 'D':
		PORTD=portvalue;
    1196:	e2 e3       	ldi	r30, 0x32	; 50
    1198:	f0 e0       	ldi	r31, 0x00	; 0
    119a:	8a 81       	ldd	r24, Y+2	; 0x02
    119c:	80 83       	st	Z, r24
		break ;
		default: break ;
	}
}
    119e:	0f 90       	pop	r0
    11a0:	0f 90       	pop	r0
    11a2:	0f 90       	pop	r0
    11a4:	0f 90       	pop	r0
    11a6:	cf 91       	pop	r28
    11a8:	df 91       	pop	r29
    11aa:	08 95       	ret

000011ac <dio_write_highnibble>:
void dio_write_highnibble(char portname,char value)
{
    11ac:	df 93       	push	r29
    11ae:	cf 93       	push	r28
    11b0:	00 d0       	rcall	.+0      	; 0x11b2 <dio_write_highnibble+0x6>
    11b2:	00 d0       	rcall	.+0      	; 0x11b4 <dio_write_highnibble+0x8>
    11b4:	cd b7       	in	r28, 0x3d	; 61
    11b6:	de b7       	in	r29, 0x3e	; 62
    11b8:	89 83       	std	Y+1, r24	; 0x01
    11ba:	6a 83       	std	Y+2, r22	; 0x02
		switch(portname)
    11bc:	89 81       	ldd	r24, Y+1	; 0x01
    11be:	28 2f       	mov	r18, r24
    11c0:	30 e0       	ldi	r19, 0x00	; 0
    11c2:	3c 83       	std	Y+4, r19	; 0x04
    11c4:	2b 83       	std	Y+3, r18	; 0x03
    11c6:	8b 81       	ldd	r24, Y+3	; 0x03
    11c8:	9c 81       	ldd	r25, Y+4	; 0x04
    11ca:	82 34       	cpi	r24, 0x42	; 66
    11cc:	91 05       	cpc	r25, r1
    11ce:	09 f1       	breq	.+66     	; 0x1212 <dio_write_highnibble+0x66>
    11d0:	2b 81       	ldd	r18, Y+3	; 0x03
    11d2:	3c 81       	ldd	r19, Y+4	; 0x04
    11d4:	23 34       	cpi	r18, 0x43	; 67
    11d6:	31 05       	cpc	r19, r1
    11d8:	34 f4       	brge	.+12     	; 0x11e6 <dio_write_highnibble+0x3a>
    11da:	8b 81       	ldd	r24, Y+3	; 0x03
    11dc:	9c 81       	ldd	r25, Y+4	; 0x04
    11de:	81 34       	cpi	r24, 0x41	; 65
    11e0:	91 05       	cpc	r25, r1
    11e2:	61 f0       	breq	.+24     	; 0x11fc <dio_write_highnibble+0x50>
    11e4:	36 c0       	rjmp	.+108    	; 0x1252 <dio_write_highnibble+0xa6>
    11e6:	2b 81       	ldd	r18, Y+3	; 0x03
    11e8:	3c 81       	ldd	r19, Y+4	; 0x04
    11ea:	23 34       	cpi	r18, 0x43	; 67
    11ec:	31 05       	cpc	r19, r1
    11ee:	e1 f0       	breq	.+56     	; 0x1228 <dio_write_highnibble+0x7c>
    11f0:	8b 81       	ldd	r24, Y+3	; 0x03
    11f2:	9c 81       	ldd	r25, Y+4	; 0x04
    11f4:	84 34       	cpi	r24, 0x44	; 68
    11f6:	91 05       	cpc	r25, r1
    11f8:	11 f1       	breq	.+68     	; 0x123e <dio_write_highnibble+0x92>
    11fa:	2b c0       	rjmp	.+86     	; 0x1252 <dio_write_highnibble+0xa6>
		{
			case 'A' :
			PORTA|=(value&0xf0);
    11fc:	ab e3       	ldi	r26, 0x3B	; 59
    11fe:	b0 e0       	ldi	r27, 0x00	; 0
    1200:	eb e3       	ldi	r30, 0x3B	; 59
    1202:	f0 e0       	ldi	r31, 0x00	; 0
    1204:	80 81       	ld	r24, Z
    1206:	98 2f       	mov	r25, r24
    1208:	8a 81       	ldd	r24, Y+2	; 0x02
    120a:	80 7f       	andi	r24, 0xF0	; 240
    120c:	89 2b       	or	r24, r25
    120e:	8c 93       	st	X, r24
    1210:	20 c0       	rjmp	.+64     	; 0x1252 <dio_write_highnibble+0xa6>
			break ;
			case 'B':
			PORTB|=(value&0xf0);
    1212:	a8 e3       	ldi	r26, 0x38	; 56
    1214:	b0 e0       	ldi	r27, 0x00	; 0
    1216:	e8 e3       	ldi	r30, 0x38	; 56
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	80 81       	ld	r24, Z
    121c:	98 2f       	mov	r25, r24
    121e:	8a 81       	ldd	r24, Y+2	; 0x02
    1220:	80 7f       	andi	r24, 0xF0	; 240
    1222:	89 2b       	or	r24, r25
    1224:	8c 93       	st	X, r24
    1226:	15 c0       	rjmp	.+42     	; 0x1252 <dio_write_highnibble+0xa6>
			break ;
			case 'C' :
			PORTC|=(value&0xf0);
    1228:	a5 e3       	ldi	r26, 0x35	; 53
    122a:	b0 e0       	ldi	r27, 0x00	; 0
    122c:	e5 e3       	ldi	r30, 0x35	; 53
    122e:	f0 e0       	ldi	r31, 0x00	; 0
    1230:	80 81       	ld	r24, Z
    1232:	98 2f       	mov	r25, r24
    1234:	8a 81       	ldd	r24, Y+2	; 0x02
    1236:	80 7f       	andi	r24, 0xF0	; 240
    1238:	89 2b       	or	r24, r25
    123a:	8c 93       	st	X, r24
    123c:	0a c0       	rjmp	.+20     	; 0x1252 <dio_write_highnibble+0xa6>
			break ;
			case 'D':
			PORTD|=(value&0xf0);
    123e:	a2 e3       	ldi	r26, 0x32	; 50
    1240:	b0 e0       	ldi	r27, 0x00	; 0
    1242:	e2 e3       	ldi	r30, 0x32	; 50
    1244:	f0 e0       	ldi	r31, 0x00	; 0
    1246:	80 81       	ld	r24, Z
    1248:	98 2f       	mov	r25, r24
    124a:	8a 81       	ldd	r24, Y+2	; 0x02
    124c:	80 7f       	andi	r24, 0xF0	; 240
    124e:	89 2b       	or	r24, r25
    1250:	8c 93       	st	X, r24
			break ;
			default: break ;
	
}
}
    1252:	0f 90       	pop	r0
    1254:	0f 90       	pop	r0
    1256:	0f 90       	pop	r0
    1258:	0f 90       	pop	r0
    125a:	cf 91       	pop	r28
    125c:	df 91       	pop	r29
    125e:	08 95       	ret

00001260 <clear_high_nibble>:
void clear_high_nibble(char portname)
{
    1260:	df 93       	push	r29
    1262:	cf 93       	push	r28
    1264:	00 d0       	rcall	.+0      	; 0x1266 <clear_high_nibble+0x6>
    1266:	0f 92       	push	r0
    1268:	cd b7       	in	r28, 0x3d	; 61
    126a:	de b7       	in	r29, 0x3e	; 62
    126c:	89 83       	std	Y+1, r24	; 0x01
	switch(portname)
    126e:	89 81       	ldd	r24, Y+1	; 0x01
    1270:	28 2f       	mov	r18, r24
    1272:	30 e0       	ldi	r19, 0x00	; 0
    1274:	3b 83       	std	Y+3, r19	; 0x03
    1276:	2a 83       	std	Y+2, r18	; 0x02
    1278:	8a 81       	ldd	r24, Y+2	; 0x02
    127a:	9b 81       	ldd	r25, Y+3	; 0x03
    127c:	82 34       	cpi	r24, 0x42	; 66
    127e:	91 05       	cpc	r25, r1
    1280:	f1 f0       	breq	.+60     	; 0x12be <clear_high_nibble+0x5e>
    1282:	2a 81       	ldd	r18, Y+2	; 0x02
    1284:	3b 81       	ldd	r19, Y+3	; 0x03
    1286:	23 34       	cpi	r18, 0x43	; 67
    1288:	31 05       	cpc	r19, r1
    128a:	34 f4       	brge	.+12     	; 0x1298 <clear_high_nibble+0x38>
    128c:	8a 81       	ldd	r24, Y+2	; 0x02
    128e:	9b 81       	ldd	r25, Y+3	; 0x03
    1290:	81 34       	cpi	r24, 0x41	; 65
    1292:	91 05       	cpc	r25, r1
    1294:	61 f0       	breq	.+24     	; 0x12ae <clear_high_nibble+0x4e>
    1296:	2a c0       	rjmp	.+84     	; 0x12ec <clear_high_nibble+0x8c>
    1298:	2a 81       	ldd	r18, Y+2	; 0x02
    129a:	3b 81       	ldd	r19, Y+3	; 0x03
    129c:	23 34       	cpi	r18, 0x43	; 67
    129e:	31 05       	cpc	r19, r1
    12a0:	b1 f0       	breq	.+44     	; 0x12ce <clear_high_nibble+0x6e>
    12a2:	8a 81       	ldd	r24, Y+2	; 0x02
    12a4:	9b 81       	ldd	r25, Y+3	; 0x03
    12a6:	84 34       	cpi	r24, 0x44	; 68
    12a8:	91 05       	cpc	r25, r1
    12aa:	c9 f0       	breq	.+50     	; 0x12de <clear_high_nibble+0x7e>
    12ac:	1f c0       	rjmp	.+62     	; 0x12ec <clear_high_nibble+0x8c>
	{
		case 'A' :
		PORTA&=0x0f;
    12ae:	ab e3       	ldi	r26, 0x3B	; 59
    12b0:	b0 e0       	ldi	r27, 0x00	; 0
    12b2:	eb e3       	ldi	r30, 0x3B	; 59
    12b4:	f0 e0       	ldi	r31, 0x00	; 0
    12b6:	80 81       	ld	r24, Z
    12b8:	8f 70       	andi	r24, 0x0F	; 15
    12ba:	8c 93       	st	X, r24
    12bc:	17 c0       	rjmp	.+46     	; 0x12ec <clear_high_nibble+0x8c>
		break ;
		case 'B':
		PORTB&=0x0f;
    12be:	a8 e3       	ldi	r26, 0x38	; 56
    12c0:	b0 e0       	ldi	r27, 0x00	; 0
    12c2:	e8 e3       	ldi	r30, 0x38	; 56
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	80 81       	ld	r24, Z
    12c8:	8f 70       	andi	r24, 0x0F	; 15
    12ca:	8c 93       	st	X, r24
    12cc:	0f c0       	rjmp	.+30     	; 0x12ec <clear_high_nibble+0x8c>
		break ;
		case 'C' :
		PORTC&=0x0f;
    12ce:	a5 e3       	ldi	r26, 0x35	; 53
    12d0:	b0 e0       	ldi	r27, 0x00	; 0
    12d2:	e5 e3       	ldi	r30, 0x35	; 53
    12d4:	f0 e0       	ldi	r31, 0x00	; 0
    12d6:	80 81       	ld	r24, Z
    12d8:	8f 70       	andi	r24, 0x0F	; 15
    12da:	8c 93       	st	X, r24
    12dc:	07 c0       	rjmp	.+14     	; 0x12ec <clear_high_nibble+0x8c>
		break ;
		case 'D':
		PORTD&=0x0f;
    12de:	a2 e3       	ldi	r26, 0x32	; 50
    12e0:	b0 e0       	ldi	r27, 0x00	; 0
    12e2:	e2 e3       	ldi	r30, 0x32	; 50
    12e4:	f0 e0       	ldi	r31, 0x00	; 0
    12e6:	80 81       	ld	r24, Z
    12e8:	8f 70       	andi	r24, 0x0F	; 15
    12ea:	8c 93       	st	X, r24
		break ;
		default: break ;
		
	}
    12ec:	0f 90       	pop	r0
    12ee:	0f 90       	pop	r0
    12f0:	0f 90       	pop	r0
    12f2:	cf 91       	pop	r28
    12f4:	df 91       	pop	r29
    12f6:	08 95       	ret

000012f8 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    12f8:	df 93       	push	r29
    12fa:	cf 93       	push	r28
    12fc:	00 d0       	rcall	.+0      	; 0x12fe <xEventGroupCreate+0x6>
    12fe:	cd b7       	in	r28, 0x3d	; 61
    1300:	de b7       	in	r29, 0x3e	; 62
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
    1302:	8b e0       	ldi	r24, 0x0B	; 11
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	0e 94 bc 0c 	call	0x1978	; 0x1978 <pvPortMalloc>
    130a:	9a 83       	std	Y+2, r25	; 0x02
    130c:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    130e:	89 81       	ldd	r24, Y+1	; 0x01
    1310:	9a 81       	ldd	r25, Y+2	; 0x02
    1312:	00 97       	sbiw	r24, 0x00	; 0
    1314:	49 f0       	breq	.+18     	; 0x1328 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    1316:	e9 81       	ldd	r30, Y+1	; 0x01
    1318:	fa 81       	ldd	r31, Y+2	; 0x02
    131a:	11 82       	std	Z+1, r1	; 0x01
    131c:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    131e:	89 81       	ldd	r24, Y+1	; 0x01
    1320:	9a 81       	ldd	r25, Y+2	; 0x02
    1322:	02 96       	adiw	r24, 0x02	; 2
    1324:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
    1328:	89 81       	ldd	r24, Y+1	; 0x01
    132a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    132c:	0f 90       	pop	r0
    132e:	0f 90       	pop	r0
    1330:	cf 91       	pop	r28
    1332:	df 91       	pop	r29
    1334:	08 95       	ret

00001336 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    1336:	df 93       	push	r29
    1338:	cf 93       	push	r28
    133a:	cd b7       	in	r28, 0x3d	; 61
    133c:	de b7       	in	r29, 0x3e	; 62
    133e:	60 97       	sbiw	r28, 0x10	; 16
    1340:	0f b6       	in	r0, 0x3f	; 63
    1342:	f8 94       	cli
    1344:	de bf       	out	0x3e, r29	; 62
    1346:	0f be       	out	0x3f, r0	; 63
    1348:	cd bf       	out	0x3d, r28	; 61
    134a:	9a 87       	std	Y+10, r25	; 0x0a
    134c:	89 87       	std	Y+9, r24	; 0x09
    134e:	7c 87       	std	Y+12, r23	; 0x0c
    1350:	6b 87       	std	Y+11, r22	; 0x0b
    1352:	5e 87       	std	Y+14, r21	; 0x0e
    1354:	4d 87       	std	Y+13, r20	; 0x0d
    1356:	38 8b       	std	Y+16, r19	; 0x10
    1358:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    135a:	89 85       	ldd	r24, Y+9	; 0x09
    135c:	9a 85       	ldd	r25, Y+10	; 0x0a
    135e:	9c 83       	std	Y+4, r25	; 0x04
    1360:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    1362:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    1364:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    1368:	eb 81       	ldd	r30, Y+3	; 0x03
    136a:	fc 81       	ldd	r31, Y+4	; 0x04
    136c:	80 81       	ld	r24, Z
    136e:	91 81       	ldd	r25, Z+1	; 0x01
    1370:	98 87       	std	Y+8, r25	; 0x08
    1372:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    1374:	89 85       	ldd	r24, Y+9	; 0x09
    1376:	9a 85       	ldd	r25, Y+10	; 0x0a
    1378:	2b 85       	ldd	r18, Y+11	; 0x0b
    137a:	3c 85       	ldd	r19, Y+12	; 0x0c
    137c:	b9 01       	movw	r22, r18
    137e:	0e 94 6d 0b 	call	0x16da	; 0x16da <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1382:	2f 81       	ldd	r18, Y+7	; 0x07
    1384:	38 85       	ldd	r19, Y+8	; 0x08
    1386:	8b 85       	ldd	r24, Y+11	; 0x0b
    1388:	9c 85       	ldd	r25, Y+12	; 0x0c
    138a:	28 2b       	or	r18, r24
    138c:	39 2b       	or	r19, r25
    138e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1390:	9e 85       	ldd	r25, Y+14	; 0x0e
    1392:	28 23       	and	r18, r24
    1394:	39 23       	and	r19, r25
    1396:	8d 85       	ldd	r24, Y+13	; 0x0d
    1398:	9e 85       	ldd	r25, Y+14	; 0x0e
    139a:	28 17       	cp	r18, r24
    139c:	39 07       	cpc	r19, r25
    139e:	c9 f4       	brne	.+50     	; 0x13d2 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    13a0:	2f 81       	ldd	r18, Y+7	; 0x07
    13a2:	38 85       	ldd	r19, Y+8	; 0x08
    13a4:	8b 85       	ldd	r24, Y+11	; 0x0b
    13a6:	9c 85       	ldd	r25, Y+12	; 0x0c
    13a8:	82 2b       	or	r24, r18
    13aa:	93 2b       	or	r25, r19
    13ac:	9e 83       	std	Y+6, r25	; 0x06
    13ae:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    13b0:	eb 81       	ldd	r30, Y+3	; 0x03
    13b2:	fc 81       	ldd	r31, Y+4	; 0x04
    13b4:	20 81       	ld	r18, Z
    13b6:	31 81       	ldd	r19, Z+1	; 0x01
    13b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    13ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    13bc:	80 95       	com	r24
    13be:	90 95       	com	r25
    13c0:	82 23       	and	r24, r18
    13c2:	93 23       	and	r25, r19
    13c4:	eb 81       	ldd	r30, Y+3	; 0x03
    13c6:	fc 81       	ldd	r31, Y+4	; 0x04
    13c8:	91 83       	std	Z+1, r25	; 0x01
    13ca:	80 83       	st	Z, r24

			xTicksToWait = 0;
    13cc:	18 8a       	std	Y+16, r1	; 0x10
    13ce:	1f 86       	std	Y+15, r1	; 0x0f
    13d0:	1c c0       	rjmp	.+56     	; 0x140a <xEventGroupSync+0xd4>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    13d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    13d4:	98 89       	ldd	r25, Y+16	; 0x10
    13d6:	00 97       	sbiw	r24, 0x00	; 0
    13d8:	91 f0       	breq	.+36     	; 0x13fe <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    13da:	8b 81       	ldd	r24, Y+3	; 0x03
    13dc:	9c 81       	ldd	r25, Y+4	; 0x04
    13de:	bc 01       	movw	r22, r24
    13e0:	6e 5f       	subi	r22, 0xFE	; 254
    13e2:	7f 4f       	sbci	r23, 0xFF	; 255
    13e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    13e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    13e8:	9c 01       	movw	r18, r24
    13ea:	35 60       	ori	r19, 0x05	; 5
    13ec:	4f 85       	ldd	r20, Y+15	; 0x0f
    13ee:	58 89       	ldd	r21, Y+16	; 0x10
    13f0:	cb 01       	movw	r24, r22
    13f2:	b9 01       	movw	r22, r18
    13f4:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    13f8:	1e 82       	std	Y+6, r1	; 0x06
    13fa:	1d 82       	std	Y+5, r1	; 0x05
    13fc:	06 c0       	rjmp	.+12     	; 0x140a <xEventGroupSync+0xd4>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    13fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1400:	fc 81       	ldd	r31, Y+4	; 0x04
    1402:	80 81       	ld	r24, Z
    1404:	91 81       	ldd	r25, Z+1	; 0x01
    1406:	9e 83       	std	Y+6, r25	; 0x06
    1408:	8d 83       	std	Y+5, r24	; 0x05
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    140a:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    140e:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    1410:	8f 85       	ldd	r24, Y+15	; 0x0f
    1412:	98 89       	ldd	r25, Y+16	; 0x10
    1414:	00 97       	sbiw	r24, 0x00	; 0
    1416:	09 f4       	brne	.+2      	; 0x141a <xEventGroupSync+0xe4>
    1418:	3a c0       	rjmp	.+116    	; 0x148e <xEventGroupSync+0x158>
	{
		if( xAlreadyYielded == pdFALSE )
    141a:	8a 81       	ldd	r24, Y+2	; 0x02
    141c:	88 23       	and	r24, r24
    141e:	11 f4       	brne	.+4      	; 0x1424 <xEventGroupSync+0xee>
		{
			portYIELD_WITHIN_API();
    1420:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1424:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <uxTaskResetEventItemValue>
    1428:	9e 83       	std	Y+6, r25	; 0x06
    142a:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    142c:	8d 81       	ldd	r24, Y+5	; 0x05
    142e:	9e 81       	ldd	r25, Y+6	; 0x06
    1430:	80 70       	andi	r24, 0x00	; 0
    1432:	92 70       	andi	r25, 0x02	; 2
    1434:	00 97       	sbiw	r24, 0x00	; 0
    1436:	31 f5       	brne	.+76     	; 0x1484 <xEventGroupSync+0x14e>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    143e:	eb 81       	ldd	r30, Y+3	; 0x03
    1440:	fc 81       	ldd	r31, Y+4	; 0x04
    1442:	80 81       	ld	r24, Z
    1444:	91 81       	ldd	r25, Z+1	; 0x01
    1446:	9e 83       	std	Y+6, r25	; 0x06
    1448:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    144a:	2d 81       	ldd	r18, Y+5	; 0x05
    144c:	3e 81       	ldd	r19, Y+6	; 0x06
    144e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1450:	9e 85       	ldd	r25, Y+14	; 0x0e
    1452:	28 23       	and	r18, r24
    1454:	39 23       	and	r19, r25
    1456:	8d 85       	ldd	r24, Y+13	; 0x0d
    1458:	9e 85       	ldd	r25, Y+14	; 0x0e
    145a:	28 17       	cp	r18, r24
    145c:	39 07       	cpc	r19, r25
    145e:	71 f4       	brne	.+28     	; 0x147c <xEventGroupSync+0x146>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1460:	eb 81       	ldd	r30, Y+3	; 0x03
    1462:	fc 81       	ldd	r31, Y+4	; 0x04
    1464:	20 81       	ld	r18, Z
    1466:	31 81       	ldd	r19, Z+1	; 0x01
    1468:	8d 85       	ldd	r24, Y+13	; 0x0d
    146a:	9e 85       	ldd	r25, Y+14	; 0x0e
    146c:	80 95       	com	r24
    146e:	90 95       	com	r25
    1470:	82 23       	and	r24, r18
    1472:	93 23       	and	r25, r19
    1474:	eb 81       	ldd	r30, Y+3	; 0x03
    1476:	fc 81       	ldd	r31, Y+4	; 0x04
    1478:	91 83       	std	Z+1, r25	; 0x01
    147a:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    147c:	0f 90       	pop	r0
    147e:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    1480:	81 e0       	ldi	r24, 0x01	; 1
    1482:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1484:	8d 81       	ldd	r24, Y+5	; 0x05
    1486:	9e 81       	ldd	r25, Y+6	; 0x06
    1488:	90 70       	andi	r25, 0x00	; 0
    148a:	9e 83       	std	Y+6, r25	; 0x06
    148c:	8d 83       	std	Y+5, r24	; 0x05
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    148e:	8d 81       	ldd	r24, Y+5	; 0x05
    1490:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1492:	60 96       	adiw	r28, 0x10	; 16
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	f8 94       	cli
    1498:	de bf       	out	0x3e, r29	; 62
    149a:	0f be       	out	0x3f, r0	; 63
    149c:	cd bf       	out	0x3d, r28	; 61
    149e:	cf 91       	pop	r28
    14a0:	df 91       	pop	r29
    14a2:	08 95       	ret

000014a4 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    14a4:	0f 93       	push	r16
    14a6:	1f 93       	push	r17
    14a8:	df 93       	push	r29
    14aa:	cf 93       	push	r28
    14ac:	cd b7       	in	r28, 0x3d	; 61
    14ae:	de b7       	in	r29, 0x3e	; 62
    14b0:	63 97       	sbiw	r28, 0x13	; 19
    14b2:	0f b6       	in	r0, 0x3f	; 63
    14b4:	f8 94       	cli
    14b6:	de bf       	out	0x3e, r29	; 62
    14b8:	0f be       	out	0x3f, r0	; 63
    14ba:	cd bf       	out	0x3d, r28	; 61
    14bc:	9d 87       	std	Y+13, r25	; 0x0d
    14be:	8c 87       	std	Y+12, r24	; 0x0c
    14c0:	7f 87       	std	Y+15, r23	; 0x0f
    14c2:	6e 87       	std	Y+14, r22	; 0x0e
    14c4:	48 8b       	std	Y+16, r20	; 0x10
    14c6:	29 8b       	std	Y+17, r18	; 0x11
    14c8:	1b 8b       	std	Y+19, r17	; 0x13
    14ca:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    14cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    14ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    14d0:	9b 87       	std	Y+11, r25	; 0x0b
    14d2:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    14d4:	1f 82       	std	Y+7, r1	; 0x07
    14d6:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    14d8:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    14da:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    14de:	ea 85       	ldd	r30, Y+10	; 0x0a
    14e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    14e2:	80 81       	ld	r24, Z
    14e4:	91 81       	ldd	r25, Z+1	; 0x01
    14e6:	9a 83       	std	Y+2, r25	; 0x02
    14e8:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    14ea:	89 81       	ldd	r24, Y+1	; 0x01
    14ec:	9a 81       	ldd	r25, Y+2	; 0x02
    14ee:	2e 85       	ldd	r18, Y+14	; 0x0e
    14f0:	3f 85       	ldd	r19, Y+15	; 0x0f
    14f2:	b9 01       	movw	r22, r18
    14f4:	49 89       	ldd	r20, Y+17	; 0x11
    14f6:	0e 94 8a 0c 	call	0x1914	; 0x1914 <prvTestWaitCondition>
    14fa:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    14fc:	8d 81       	ldd	r24, Y+5	; 0x05
    14fe:	88 23       	and	r24, r24
    1500:	c1 f0       	breq	.+48     	; 0x1532 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    1502:	89 81       	ldd	r24, Y+1	; 0x01
    1504:	9a 81       	ldd	r25, Y+2	; 0x02
    1506:	99 87       	std	Y+9, r25	; 0x09
    1508:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    150a:	1b 8a       	std	Y+19, r1	; 0x13
    150c:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    150e:	88 89       	ldd	r24, Y+16	; 0x10
    1510:	88 23       	and	r24, r24
    1512:	d9 f1       	breq	.+118    	; 0x158a <xEventGroupWaitBits+0xe6>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1514:	ea 85       	ldd	r30, Y+10	; 0x0a
    1516:	fb 85       	ldd	r31, Y+11	; 0x0b
    1518:	20 81       	ld	r18, Z
    151a:	31 81       	ldd	r19, Z+1	; 0x01
    151c:	8e 85       	ldd	r24, Y+14	; 0x0e
    151e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1520:	80 95       	com	r24
    1522:	90 95       	com	r25
    1524:	82 23       	and	r24, r18
    1526:	93 23       	and	r25, r19
    1528:	ea 85       	ldd	r30, Y+10	; 0x0a
    152a:	fb 85       	ldd	r31, Y+11	; 0x0b
    152c:	91 83       	std	Z+1, r25	; 0x01
    152e:	80 83       	st	Z, r24
    1530:	2c c0       	rjmp	.+88     	; 0x158a <xEventGroupWaitBits+0xe6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    1532:	8a 89       	ldd	r24, Y+18	; 0x12
    1534:	9b 89       	ldd	r25, Y+19	; 0x13
    1536:	00 97       	sbiw	r24, 0x00	; 0
    1538:	29 f4       	brne	.+10     	; 0x1544 <xEventGroupWaitBits+0xa0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    153a:	89 81       	ldd	r24, Y+1	; 0x01
    153c:	9a 81       	ldd	r25, Y+2	; 0x02
    153e:	99 87       	std	Y+9, r25	; 0x09
    1540:	88 87       	std	Y+8, r24	; 0x08
    1542:	23 c0       	rjmp	.+70     	; 0x158a <xEventGroupWaitBits+0xe6>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    1544:	88 89       	ldd	r24, Y+16	; 0x10
    1546:	88 23       	and	r24, r24
    1548:	29 f0       	breq	.+10     	; 0x1554 <xEventGroupWaitBits+0xb0>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    154a:	8e 81       	ldd	r24, Y+6	; 0x06
    154c:	9f 81       	ldd	r25, Y+7	; 0x07
    154e:	91 60       	ori	r25, 0x01	; 1
    1550:	9f 83       	std	Y+7, r25	; 0x07
    1552:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    1554:	89 89       	ldd	r24, Y+17	; 0x11
    1556:	88 23       	and	r24, r24
    1558:	29 f0       	breq	.+10     	; 0x1564 <xEventGroupWaitBits+0xc0>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    155a:	8e 81       	ldd	r24, Y+6	; 0x06
    155c:	9f 81       	ldd	r25, Y+7	; 0x07
    155e:	94 60       	ori	r25, 0x04	; 4
    1560:	9f 83       	std	Y+7, r25	; 0x07
    1562:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1564:	8a 85       	ldd	r24, Y+10	; 0x0a
    1566:	9b 85       	ldd	r25, Y+11	; 0x0b
    1568:	bc 01       	movw	r22, r24
    156a:	6e 5f       	subi	r22, 0xFE	; 254
    156c:	7f 4f       	sbci	r23, 0xFF	; 255
    156e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1570:	3f 85       	ldd	r19, Y+15	; 0x0f
    1572:	8e 81       	ldd	r24, Y+6	; 0x06
    1574:	9f 81       	ldd	r25, Y+7	; 0x07
    1576:	28 2b       	or	r18, r24
    1578:	39 2b       	or	r19, r25
    157a:	4a 89       	ldd	r20, Y+18	; 0x12
    157c:	5b 89       	ldd	r21, Y+19	; 0x13
    157e:	cb 01       	movw	r24, r22
    1580:	b9 01       	movw	r22, r18
    1582:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    1586:	19 86       	std	Y+9, r1	; 0x09
    1588:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    158a:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    158e:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    1590:	8a 89       	ldd	r24, Y+18	; 0x12
    1592:	9b 89       	ldd	r25, Y+19	; 0x13
    1594:	00 97       	sbiw	r24, 0x00	; 0
    1596:	09 f4       	brne	.+2      	; 0x159a <xEventGroupWaitBits+0xf6>
    1598:	3b c0       	rjmp	.+118    	; 0x1610 <xEventGroupWaitBits+0x16c>
	{
		if( xAlreadyYielded == pdFALSE )
    159a:	8c 81       	ldd	r24, Y+4	; 0x04
    159c:	88 23       	and	r24, r24
    159e:	11 f4       	brne	.+4      	; 0x15a4 <xEventGroupWaitBits+0x100>
		{
			portYIELD_WITHIN_API();
    15a0:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    15a4:	0e 94 4c 26 	call	0x4c98	; 0x4c98 <uxTaskResetEventItemValue>
    15a8:	99 87       	std	Y+9, r25	; 0x09
    15aa:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    15ac:	88 85       	ldd	r24, Y+8	; 0x08
    15ae:	99 85       	ldd	r25, Y+9	; 0x09
    15b0:	80 70       	andi	r24, 0x00	; 0
    15b2:	92 70       	andi	r25, 0x02	; 2
    15b4:	00 97       	sbiw	r24, 0x00	; 0
    15b6:	39 f5       	brne	.+78     	; 0x1606 <xEventGroupWaitBits+0x162>
		{
			taskENTER_CRITICAL();
    15b8:	0f b6       	in	r0, 0x3f	; 63
    15ba:	f8 94       	cli
    15bc:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    15be:	ea 85       	ldd	r30, Y+10	; 0x0a
    15c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    15c2:	80 81       	ld	r24, Z
    15c4:	91 81       	ldd	r25, Z+1	; 0x01
    15c6:	99 87       	std	Y+9, r25	; 0x09
    15c8:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    15ca:	88 85       	ldd	r24, Y+8	; 0x08
    15cc:	99 85       	ldd	r25, Y+9	; 0x09
    15ce:	2e 85       	ldd	r18, Y+14	; 0x0e
    15d0:	3f 85       	ldd	r19, Y+15	; 0x0f
    15d2:	b9 01       	movw	r22, r18
    15d4:	49 89       	ldd	r20, Y+17	; 0x11
    15d6:	0e 94 8a 0c 	call	0x1914	; 0x1914 <prvTestWaitCondition>
    15da:	88 23       	and	r24, r24
    15dc:	89 f0       	breq	.+34     	; 0x1600 <xEventGroupWaitBits+0x15c>
				{
					if( xClearOnExit != pdFALSE )
    15de:	88 89       	ldd	r24, Y+16	; 0x10
    15e0:	88 23       	and	r24, r24
    15e2:	71 f0       	breq	.+28     	; 0x1600 <xEventGroupWaitBits+0x15c>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    15e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    15e8:	20 81       	ld	r18, Z
    15ea:	31 81       	ldd	r19, Z+1	; 0x01
    15ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    15ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    15f0:	80 95       	com	r24
    15f2:	90 95       	com	r25
    15f4:	82 23       	and	r24, r18
    15f6:	93 23       	and	r25, r19
    15f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    15fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    15fc:	91 83       	std	Z+1, r25	; 0x01
    15fe:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    1600:	0f 90       	pop	r0
    1602:	0f be       	out	0x3f, r0	; 63

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    1604:	1b 82       	std	Y+3, r1	; 0x03
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1606:	88 85       	ldd	r24, Y+8	; 0x08
    1608:	99 85       	ldd	r25, Y+9	; 0x09
    160a:	90 70       	andi	r25, 0x00	; 0
    160c:	99 87       	std	Y+9, r25	; 0x09
    160e:	88 87       	std	Y+8, r24	; 0x08
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    1610:	88 85       	ldd	r24, Y+8	; 0x08
    1612:	99 85       	ldd	r25, Y+9	; 0x09
}
    1614:	63 96       	adiw	r28, 0x13	; 19
    1616:	0f b6       	in	r0, 0x3f	; 63
    1618:	f8 94       	cli
    161a:	de bf       	out	0x3e, r29	; 62
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	cd bf       	out	0x3d, r28	; 61
    1620:	cf 91       	pop	r28
    1622:	df 91       	pop	r29
    1624:	1f 91       	pop	r17
    1626:	0f 91       	pop	r16
    1628:	08 95       	ret

0000162a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    162a:	df 93       	push	r29
    162c:	cf 93       	push	r28
    162e:	cd b7       	in	r28, 0x3d	; 61
    1630:	de b7       	in	r29, 0x3e	; 62
    1632:	28 97       	sbiw	r28, 0x08	; 8
    1634:	0f b6       	in	r0, 0x3f	; 63
    1636:	f8 94       	cli
    1638:	de bf       	out	0x3e, r29	; 62
    163a:	0f be       	out	0x3f, r0	; 63
    163c:	cd bf       	out	0x3d, r28	; 61
    163e:	9e 83       	std	Y+6, r25	; 0x06
    1640:	8d 83       	std	Y+5, r24	; 0x05
    1642:	78 87       	std	Y+8, r23	; 0x08
    1644:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1646:	8d 81       	ldd	r24, Y+5	; 0x05
    1648:	9e 81       	ldd	r25, Y+6	; 0x06
    164a:	9c 83       	std	Y+4, r25	; 0x04
    164c:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    164e:	0f b6       	in	r0, 0x3f	; 63
    1650:	f8 94       	cli
    1652:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    1654:	eb 81       	ldd	r30, Y+3	; 0x03
    1656:	fc 81       	ldd	r31, Y+4	; 0x04
    1658:	80 81       	ld	r24, Z
    165a:	91 81       	ldd	r25, Z+1	; 0x01
    165c:	9a 83       	std	Y+2, r25	; 0x02
    165e:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1660:	eb 81       	ldd	r30, Y+3	; 0x03
    1662:	fc 81       	ldd	r31, Y+4	; 0x04
    1664:	20 81       	ld	r18, Z
    1666:	31 81       	ldd	r19, Z+1	; 0x01
    1668:	8f 81       	ldd	r24, Y+7	; 0x07
    166a:	98 85       	ldd	r25, Y+8	; 0x08
    166c:	80 95       	com	r24
    166e:	90 95       	com	r25
    1670:	82 23       	and	r24, r18
    1672:	93 23       	and	r25, r19
    1674:	eb 81       	ldd	r30, Y+3	; 0x03
    1676:	fc 81       	ldd	r31, Y+4	; 0x04
    1678:	91 83       	std	Z+1, r25	; 0x01
    167a:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1680:	89 81       	ldd	r24, Y+1	; 0x01
    1682:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1684:	28 96       	adiw	r28, 0x08	; 8
    1686:	0f b6       	in	r0, 0x3f	; 63
    1688:	f8 94       	cli
    168a:	de bf       	out	0x3e, r29	; 62
    168c:	0f be       	out	0x3f, r0	; 63
    168e:	cd bf       	out	0x3d, r28	; 61
    1690:	cf 91       	pop	r28
    1692:	df 91       	pop	r29
    1694:	08 95       	ret

00001696 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1696:	df 93       	push	r29
    1698:	cf 93       	push	r28
    169a:	cd b7       	in	r28, 0x3d	; 61
    169c:	de b7       	in	r29, 0x3e	; 62
    169e:	27 97       	sbiw	r28, 0x07	; 7
    16a0:	0f b6       	in	r0, 0x3f	; 63
    16a2:	f8 94       	cli
    16a4:	de bf       	out	0x3e, r29	; 62
    16a6:	0f be       	out	0x3f, r0	; 63
    16a8:	cd bf       	out	0x3d, r28	; 61
    16aa:	9f 83       	std	Y+7, r25	; 0x07
    16ac:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    16ae:	8e 81       	ldd	r24, Y+6	; 0x06
    16b0:	9f 81       	ldd	r25, Y+7	; 0x07
    16b2:	9c 83       	std	Y+4, r25	; 0x04
    16b4:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    16b6:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    16b8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ba:	fc 81       	ldd	r31, Y+4	; 0x04
    16bc:	80 81       	ld	r24, Z
    16be:	91 81       	ldd	r25, Z+1	; 0x01
    16c0:	9a 83       	std	Y+2, r25	; 0x02
    16c2:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    16c4:	89 81       	ldd	r24, Y+1	; 0x01
    16c6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    16c8:	27 96       	adiw	r28, 0x07	; 7
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	de bf       	out	0x3e, r29	; 62
    16d0:	0f be       	out	0x3f, r0	; 63
    16d2:	cd bf       	out	0x3d, r28	; 61
    16d4:	cf 91       	pop	r28
    16d6:	df 91       	pop	r29
    16d8:	08 95       	ret

000016da <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    16da:	df 93       	push	r29
    16dc:	cf 93       	push	r28
    16de:	cd b7       	in	r28, 0x3d	; 61
    16e0:	de b7       	in	r29, 0x3e	; 62
    16e2:	65 97       	sbiw	r28, 0x15	; 21
    16e4:	0f b6       	in	r0, 0x3f	; 63
    16e6:	f8 94       	cli
    16e8:	de bf       	out	0x3e, r29	; 62
    16ea:	0f be       	out	0x3f, r0	; 63
    16ec:	cd bf       	out	0x3d, r28	; 61
    16ee:	9b 8b       	std	Y+19, r25	; 0x13
    16f0:	8a 8b       	std	Y+18, r24	; 0x12
    16f2:	7d 8b       	std	Y+21, r23	; 0x15
    16f4:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    16f6:	19 86       	std	Y+9, r1	; 0x09
    16f8:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    16fa:	8a 89       	ldd	r24, Y+18	; 0x12
    16fc:	9b 89       	ldd	r25, Y+19	; 0x13
    16fe:	9b 83       	std	Y+3, r25	; 0x03
    1700:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    1702:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    1704:	8a 81       	ldd	r24, Y+2	; 0x02
    1706:	9b 81       	ldd	r25, Y+3	; 0x03
    1708:	02 96       	adiw	r24, 0x02	; 2
    170a:	9b 87       	std	Y+11, r25	; 0x0b
    170c:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    170e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1710:	9b 85       	ldd	r25, Y+11	; 0x0b
    1712:	03 96       	adiw	r24, 0x03	; 3
    1714:	9d 87       	std	Y+13, r25	; 0x0d
    1716:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    1718:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    171c:	ea 85       	ldd	r30, Y+10	; 0x0a
    171e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1720:	85 81       	ldd	r24, Z+5	; 0x05
    1722:	96 81       	ldd	r25, Z+6	; 0x06
    1724:	99 8b       	std	Y+17, r25	; 0x11
    1726:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    1728:	ea 81       	ldd	r30, Y+2	; 0x02
    172a:	fb 81       	ldd	r31, Y+3	; 0x03
    172c:	20 81       	ld	r18, Z
    172e:	31 81       	ldd	r19, Z+1	; 0x01
    1730:	8c 89       	ldd	r24, Y+20	; 0x14
    1732:	9d 89       	ldd	r25, Y+21	; 0x15
    1734:	82 2b       	or	r24, r18
    1736:	93 2b       	or	r25, r19
    1738:	ea 81       	ldd	r30, Y+2	; 0x02
    173a:	fb 81       	ldd	r31, Y+3	; 0x03
    173c:	91 83       	std	Z+1, r25	; 0x01
    173e:	80 83       	st	Z, r24
    1740:	59 c0       	rjmp	.+178    	; 0x17f4 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    1742:	e8 89       	ldd	r30, Y+16	; 0x10
    1744:	f9 89       	ldd	r31, Y+17	; 0x11
    1746:	82 81       	ldd	r24, Z+2	; 0x02
    1748:	93 81       	ldd	r25, Z+3	; 0x03
    174a:	9f 87       	std	Y+15, r25	; 0x0f
    174c:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    174e:	e8 89       	ldd	r30, Y+16	; 0x10
    1750:	f9 89       	ldd	r31, Y+17	; 0x11
    1752:	80 81       	ld	r24, Z
    1754:	91 81       	ldd	r25, Z+1	; 0x01
    1756:	9f 83       	std	Y+7, r25	; 0x07
    1758:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    175a:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    175c:	8e 81       	ldd	r24, Y+6	; 0x06
    175e:	9f 81       	ldd	r25, Y+7	; 0x07
    1760:	80 70       	andi	r24, 0x00	; 0
    1762:	9d 83       	std	Y+5, r25	; 0x05
    1764:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1766:	8e 81       	ldd	r24, Y+6	; 0x06
    1768:	9f 81       	ldd	r25, Y+7	; 0x07
    176a:	90 70       	andi	r25, 0x00	; 0
    176c:	9f 83       	std	Y+7, r25	; 0x07
    176e:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1770:	8c 81       	ldd	r24, Y+4	; 0x04
    1772:	9d 81       	ldd	r25, Y+5	; 0x05
    1774:	80 70       	andi	r24, 0x00	; 0
    1776:	94 70       	andi	r25, 0x04	; 4
    1778:	00 97       	sbiw	r24, 0x00	; 0
    177a:	69 f4       	brne	.+26     	; 0x1796 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    177c:	ea 81       	ldd	r30, Y+2	; 0x02
    177e:	fb 81       	ldd	r31, Y+3	; 0x03
    1780:	20 81       	ld	r18, Z
    1782:	31 81       	ldd	r19, Z+1	; 0x01
    1784:	8e 81       	ldd	r24, Y+6	; 0x06
    1786:	9f 81       	ldd	r25, Y+7	; 0x07
    1788:	82 23       	and	r24, r18
    178a:	93 23       	and	r25, r19
    178c:	00 97       	sbiw	r24, 0x00	; 0
    178e:	91 f0       	breq	.+36     	; 0x17b4 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    1790:	81 e0       	ldi	r24, 0x01	; 1
    1792:	89 83       	std	Y+1, r24	; 0x01
    1794:	0f c0       	rjmp	.+30     	; 0x17b4 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1796:	ea 81       	ldd	r30, Y+2	; 0x02
    1798:	fb 81       	ldd	r31, Y+3	; 0x03
    179a:	20 81       	ld	r18, Z
    179c:	31 81       	ldd	r19, Z+1	; 0x01
    179e:	8e 81       	ldd	r24, Y+6	; 0x06
    17a0:	9f 81       	ldd	r25, Y+7	; 0x07
    17a2:	28 23       	and	r18, r24
    17a4:	39 23       	and	r19, r25
    17a6:	8e 81       	ldd	r24, Y+6	; 0x06
    17a8:	9f 81       	ldd	r25, Y+7	; 0x07
    17aa:	28 17       	cp	r18, r24
    17ac:	39 07       	cpc	r19, r25
    17ae:	11 f4       	brne	.+4      	; 0x17b4 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    17b4:	89 81       	ldd	r24, Y+1	; 0x01
    17b6:	88 23       	and	r24, r24
    17b8:	c9 f0       	breq	.+50     	; 0x17ec <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    17ba:	8c 81       	ldd	r24, Y+4	; 0x04
    17bc:	9d 81       	ldd	r25, Y+5	; 0x05
    17be:	80 70       	andi	r24, 0x00	; 0
    17c0:	91 70       	andi	r25, 0x01	; 1
    17c2:	00 97       	sbiw	r24, 0x00	; 0
    17c4:	41 f0       	breq	.+16     	; 0x17d6 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    17c6:	88 85       	ldd	r24, Y+8	; 0x08
    17c8:	99 85       	ldd	r25, Y+9	; 0x09
    17ca:	2e 81       	ldd	r18, Y+6	; 0x06
    17cc:	3f 81       	ldd	r19, Y+7	; 0x07
    17ce:	82 2b       	or	r24, r18
    17d0:	93 2b       	or	r25, r19
    17d2:	99 87       	std	Y+9, r25	; 0x09
    17d4:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    17d6:	ea 81       	ldd	r30, Y+2	; 0x02
    17d8:	fb 81       	ldd	r31, Y+3	; 0x03
    17da:	80 81       	ld	r24, Z
    17dc:	91 81       	ldd	r25, Z+1	; 0x01
    17de:	9c 01       	movw	r18, r24
    17e0:	32 60       	ori	r19, 0x02	; 2
    17e2:	88 89       	ldd	r24, Y+16	; 0x10
    17e4:	99 89       	ldd	r25, Y+17	; 0x11
    17e6:	b9 01       	movw	r22, r18
    17e8:	0e 94 77 23 	call	0x46ee	; 0x46ee <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    17ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    17ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    17f0:	99 8b       	std	Y+17, r25	; 0x11
    17f2:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    17f4:	28 89       	ldd	r18, Y+16	; 0x10
    17f6:	39 89       	ldd	r19, Y+17	; 0x11
    17f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    17fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    17fc:	28 17       	cp	r18, r24
    17fe:	39 07       	cpc	r19, r25
    1800:	09 f0       	breq	.+2      	; 0x1804 <xEventGroupSetBits+0x12a>
    1802:	9f cf       	rjmp	.-194    	; 0x1742 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1804:	ea 81       	ldd	r30, Y+2	; 0x02
    1806:	fb 81       	ldd	r31, Y+3	; 0x03
    1808:	20 81       	ld	r18, Z
    180a:	31 81       	ldd	r19, Z+1	; 0x01
    180c:	88 85       	ldd	r24, Y+8	; 0x08
    180e:	99 85       	ldd	r25, Y+9	; 0x09
    1810:	80 95       	com	r24
    1812:	90 95       	com	r25
    1814:	82 23       	and	r24, r18
    1816:	93 23       	and	r25, r19
    1818:	ea 81       	ldd	r30, Y+2	; 0x02
    181a:	fb 81       	ldd	r31, Y+3	; 0x03
    181c:	91 83       	std	Z+1, r25	; 0x01
    181e:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    1820:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1824:	ea 81       	ldd	r30, Y+2	; 0x02
    1826:	fb 81       	ldd	r31, Y+3	; 0x03
    1828:	80 81       	ld	r24, Z
    182a:	91 81       	ldd	r25, Z+1	; 0x01
}
    182c:	65 96       	adiw	r28, 0x15	; 21
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	de bf       	out	0x3e, r29	; 62
    1834:	0f be       	out	0x3f, r0	; 63
    1836:	cd bf       	out	0x3d, r28	; 61
    1838:	cf 91       	pop	r28
    183a:	df 91       	pop	r29
    183c:	08 95       	ret

0000183e <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    183e:	df 93       	push	r29
    1840:	cf 93       	push	r28
    1842:	00 d0       	rcall	.+0      	; 0x1844 <vEventGroupDelete+0x6>
    1844:	00 d0       	rcall	.+0      	; 0x1846 <vEventGroupDelete+0x8>
    1846:	00 d0       	rcall	.+0      	; 0x1848 <vEventGroupDelete+0xa>
    1848:	cd b7       	in	r28, 0x3d	; 61
    184a:	de b7       	in	r29, 0x3e	; 62
    184c:	9e 83       	std	Y+6, r25	; 0x06
    184e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    1850:	8d 81       	ldd	r24, Y+5	; 0x05
    1852:	9e 81       	ldd	r25, Y+6	; 0x06
    1854:	9c 83       	std	Y+4, r25	; 0x04
    1856:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1858:	8b 81       	ldd	r24, Y+3	; 0x03
    185a:	9c 81       	ldd	r25, Y+4	; 0x04
    185c:	02 96       	adiw	r24, 0x02	; 2
    185e:	9a 83       	std	Y+2, r25	; 0x02
    1860:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    1862:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
    1866:	08 c0       	rjmp	.+16     	; 0x1878 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1868:	e9 81       	ldd	r30, Y+1	; 0x01
    186a:	fa 81       	ldd	r31, Y+2	; 0x02
    186c:	85 81       	ldd	r24, Z+5	; 0x05
    186e:	96 81       	ldd	r25, Z+6	; 0x06
    1870:	60 e0       	ldi	r22, 0x00	; 0
    1872:	72 e0       	ldi	r23, 0x02	; 2
    1874:	0e 94 77 23 	call	0x46ee	; 0x46ee <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1878:	e9 81       	ldd	r30, Y+1	; 0x01
    187a:	fa 81       	ldd	r31, Y+2	; 0x02
    187c:	80 81       	ld	r24, Z
    187e:	88 23       	and	r24, r24
    1880:	99 f7       	brne	.-26     	; 0x1868 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    1882:	8b 81       	ldd	r24, Y+3	; 0x03
    1884:	9c 81       	ldd	r25, Y+4	; 0x04
    1886:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    188a:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
}
    188e:	26 96       	adiw	r28, 0x06	; 6
    1890:	0f b6       	in	r0, 0x3f	; 63
    1892:	f8 94       	cli
    1894:	de bf       	out	0x3e, r29	; 62
    1896:	0f be       	out	0x3f, r0	; 63
    1898:	cd bf       	out	0x3d, r28	; 61
    189a:	cf 91       	pop	r28
    189c:	df 91       	pop	r29
    189e:	08 95       	ret

000018a0 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    18a0:	df 93       	push	r29
    18a2:	cf 93       	push	r28
    18a4:	00 d0       	rcall	.+0      	; 0x18a6 <vEventGroupSetBitsCallback+0x6>
    18a6:	00 d0       	rcall	.+0      	; 0x18a8 <vEventGroupSetBitsCallback+0x8>
    18a8:	00 d0       	rcall	.+0      	; 0x18aa <vEventGroupSetBitsCallback+0xa>
    18aa:	cd b7       	in	r28, 0x3d	; 61
    18ac:	de b7       	in	r29, 0x3e	; 62
    18ae:	9a 83       	std	Y+2, r25	; 0x02
    18b0:	89 83       	std	Y+1, r24	; 0x01
    18b2:	4b 83       	std	Y+3, r20	; 0x03
    18b4:	5c 83       	std	Y+4, r21	; 0x04
    18b6:	6d 83       	std	Y+5, r22	; 0x05
    18b8:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    18ba:	2b 81       	ldd	r18, Y+3	; 0x03
    18bc:	3c 81       	ldd	r19, Y+4	; 0x04
    18be:	89 81       	ldd	r24, Y+1	; 0x01
    18c0:	9a 81       	ldd	r25, Y+2	; 0x02
    18c2:	b9 01       	movw	r22, r18
    18c4:	0e 94 6d 0b 	call	0x16da	; 0x16da <xEventGroupSetBits>
}
    18c8:	26 96       	adiw	r28, 0x06	; 6
    18ca:	0f b6       	in	r0, 0x3f	; 63
    18cc:	f8 94       	cli
    18ce:	de bf       	out	0x3e, r29	; 62
    18d0:	0f be       	out	0x3f, r0	; 63
    18d2:	cd bf       	out	0x3d, r28	; 61
    18d4:	cf 91       	pop	r28
    18d6:	df 91       	pop	r29
    18d8:	08 95       	ret

000018da <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    18da:	df 93       	push	r29
    18dc:	cf 93       	push	r28
    18de:	00 d0       	rcall	.+0      	; 0x18e0 <vEventGroupClearBitsCallback+0x6>
    18e0:	00 d0       	rcall	.+0      	; 0x18e2 <vEventGroupClearBitsCallback+0x8>
    18e2:	00 d0       	rcall	.+0      	; 0x18e4 <vEventGroupClearBitsCallback+0xa>
    18e4:	cd b7       	in	r28, 0x3d	; 61
    18e6:	de b7       	in	r29, 0x3e	; 62
    18e8:	9a 83       	std	Y+2, r25	; 0x02
    18ea:	89 83       	std	Y+1, r24	; 0x01
    18ec:	4b 83       	std	Y+3, r20	; 0x03
    18ee:	5c 83       	std	Y+4, r21	; 0x04
    18f0:	6d 83       	std	Y+5, r22	; 0x05
    18f2:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    18f4:	2b 81       	ldd	r18, Y+3	; 0x03
    18f6:	3c 81       	ldd	r19, Y+4	; 0x04
    18f8:	89 81       	ldd	r24, Y+1	; 0x01
    18fa:	9a 81       	ldd	r25, Y+2	; 0x02
    18fc:	b9 01       	movw	r22, r18
    18fe:	0e 94 15 0b 	call	0x162a	; 0x162a <xEventGroupClearBits>
}
    1902:	26 96       	adiw	r28, 0x06	; 6
    1904:	0f b6       	in	r0, 0x3f	; 63
    1906:	f8 94       	cli
    1908:	de bf       	out	0x3e, r29	; 62
    190a:	0f be       	out	0x3f, r0	; 63
    190c:	cd bf       	out	0x3d, r28	; 61
    190e:	cf 91       	pop	r28
    1910:	df 91       	pop	r29
    1912:	08 95       	ret

00001914 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1914:	df 93       	push	r29
    1916:	cf 93       	push	r28
    1918:	00 d0       	rcall	.+0      	; 0x191a <prvTestWaitCondition+0x6>
    191a:	00 d0       	rcall	.+0      	; 0x191c <prvTestWaitCondition+0x8>
    191c:	00 d0       	rcall	.+0      	; 0x191e <prvTestWaitCondition+0xa>
    191e:	cd b7       	in	r28, 0x3d	; 61
    1920:	de b7       	in	r29, 0x3e	; 62
    1922:	9b 83       	std	Y+3, r25	; 0x03
    1924:	8a 83       	std	Y+2, r24	; 0x02
    1926:	7d 83       	std	Y+5, r23	; 0x05
    1928:	6c 83       	std	Y+4, r22	; 0x04
    192a:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    192c:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    192e:	8e 81       	ldd	r24, Y+6	; 0x06
    1930:	88 23       	and	r24, r24
    1932:	59 f4       	brne	.+22     	; 0x194a <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1934:	8a 81       	ldd	r24, Y+2	; 0x02
    1936:	9b 81       	ldd	r25, Y+3	; 0x03
    1938:	2c 81       	ldd	r18, Y+4	; 0x04
    193a:	3d 81       	ldd	r19, Y+5	; 0x05
    193c:	82 23       	and	r24, r18
    193e:	93 23       	and	r25, r19
    1940:	00 97       	sbiw	r24, 0x00	; 0
    1942:	81 f0       	breq	.+32     	; 0x1964 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	89 83       	std	Y+1, r24	; 0x01
    1948:	0d c0       	rjmp	.+26     	; 0x1964 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    194a:	2a 81       	ldd	r18, Y+2	; 0x02
    194c:	3b 81       	ldd	r19, Y+3	; 0x03
    194e:	8c 81       	ldd	r24, Y+4	; 0x04
    1950:	9d 81       	ldd	r25, Y+5	; 0x05
    1952:	28 23       	and	r18, r24
    1954:	39 23       	and	r19, r25
    1956:	8c 81       	ldd	r24, Y+4	; 0x04
    1958:	9d 81       	ldd	r25, Y+5	; 0x05
    195a:	28 17       	cp	r18, r24
    195c:	39 07       	cpc	r19, r25
    195e:	11 f4       	brne	.+4      	; 0x1964 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1960:	81 e0       	ldi	r24, 0x01	; 1
    1962:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    1964:	89 81       	ldd	r24, Y+1	; 0x01
}
    1966:	26 96       	adiw	r28, 0x06	; 6
    1968:	0f b6       	in	r0, 0x3f	; 63
    196a:	f8 94       	cli
    196c:	de bf       	out	0x3e, r29	; 62
    196e:	0f be       	out	0x3f, r0	; 63
    1970:	cd bf       	out	0x3d, r28	; 61
    1972:	cf 91       	pop	r28
    1974:	df 91       	pop	r29
    1976:	08 95       	ret

00001978 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1978:	df 93       	push	r29
    197a:	cf 93       	push	r28
    197c:	cd b7       	in	r28, 0x3d	; 61
    197e:	de b7       	in	r29, 0x3e	; 62
    1980:	2e 97       	sbiw	r28, 0x0e	; 14
    1982:	0f b6       	in	r0, 0x3f	; 63
    1984:	f8 94       	cli
    1986:	de bf       	out	0x3e, r29	; 62
    1988:	0f be       	out	0x3f, r0	; 63
    198a:	cd bf       	out	0x3d, r28	; 61
    198c:	9e 87       	std	Y+14, r25	; 0x0e
    198e:	8d 87       	std	Y+13, r24	; 0x0d
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1990:	1e 82       	std	Y+6, r1	; 0x06
    1992:	1d 82       	std	Y+5, r1	; 0x05

	vTaskSuspendAll();
    1994:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1998:	80 91 76 00 	lds	r24, 0x0076
    199c:	88 23       	and	r24, r24
    199e:	29 f4       	brne	.+10     	; 0x19aa <pvPortMalloc+0x32>
		{
			prvHeapInit();
    19a0:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	80 93 76 00 	sts	0x0076, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    19aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    19ac:	9e 85       	ldd	r25, Y+14	; 0x0e
    19ae:	00 97       	sbiw	r24, 0x00	; 0
    19b0:	51 f0       	breq	.+20     	; 0x19c6 <pvPortMalloc+0x4e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    19b2:	80 91 73 00 	lds	r24, 0x0073
    19b6:	90 91 74 00 	lds	r25, 0x0074
    19ba:	2d 85       	ldd	r18, Y+13	; 0x0d
    19bc:	3e 85       	ldd	r19, Y+14	; 0x0e
    19be:	82 0f       	add	r24, r18
    19c0:	93 1f       	adc	r25, r19
    19c2:	9e 87       	std	Y+14, r25	; 0x0e
    19c4:	8d 87       	std	Y+13, r24	; 0x0d
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    19c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    19c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    19ca:	00 97       	sbiw	r24, 0x00	; 0
    19cc:	09 f4       	brne	.+2      	; 0x19d0 <pvPortMalloc+0x58>
    19ce:	af c0       	rjmp	.+350    	; 0x1b2e <pvPortMalloc+0x1b6>
    19d0:	8d 85       	ldd	r24, Y+13	; 0x0d
    19d2:	9e 85       	ldd	r25, Y+14	; 0x0e
    19d4:	23 e0       	ldi	r18, 0x03	; 3
    19d6:	8f 31       	cpi	r24, 0x1F	; 31
    19d8:	92 07       	cpc	r25, r18
    19da:	08 f0       	brcs	.+2      	; 0x19de <pvPortMalloc+0x66>
    19dc:	a8 c0       	rjmp	.+336    	; 0x1b2e <pvPortMalloc+0x1b6>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    19de:	87 e9       	ldi	r24, 0x97	; 151
    19e0:	93 e0       	ldi	r25, 0x03	; 3
    19e2:	9a 87       	std	Y+10, r25	; 0x0a
    19e4:	89 87       	std	Y+9, r24	; 0x09
			pxBlock = xStart.pxNextFreeBlock;
    19e6:	80 91 97 03 	lds	r24, 0x0397
    19ea:	90 91 98 03 	lds	r25, 0x0398
    19ee:	9c 87       	std	Y+12, r25	; 0x0c
    19f0:	8b 87       	std	Y+11, r24	; 0x0b
    19f2:	0a c0       	rjmp	.+20     	; 0x1a08 <pvPortMalloc+0x90>
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
			{
				pxPreviousBlock = pxBlock;
    19f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    19f6:	9c 85       	ldd	r25, Y+12	; 0x0c
    19f8:	9a 87       	std	Y+10, r25	; 0x0a
    19fa:	89 87       	std	Y+9, r24	; 0x09
				pxBlock = pxBlock->pxNextFreeBlock;
    19fc:	eb 85       	ldd	r30, Y+11	; 0x0b
    19fe:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a00:	80 81       	ld	r24, Z
    1a02:	91 81       	ldd	r25, Z+1	; 0x01
    1a04:	9c 87       	std	Y+12, r25	; 0x0c
    1a06:	8b 87       	std	Y+11, r24	; 0x0b
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1a08:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a0a:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a0c:	22 81       	ldd	r18, Z+2	; 0x02
    1a0e:	33 81       	ldd	r19, Z+3	; 0x03
    1a10:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a12:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a14:	28 17       	cp	r18, r24
    1a16:	39 07       	cpc	r19, r25
    1a18:	30 f4       	brcc	.+12     	; 0x1a26 <pvPortMalloc+0xae>
    1a1a:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a1c:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a1e:	80 81       	ld	r24, Z
    1a20:	91 81       	ldd	r25, Z+1	; 0x01
    1a22:	00 97       	sbiw	r24, 0x00	; 0
    1a24:	39 f7       	brne	.-50     	; 0x19f4 <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1a26:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a28:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a2a:	43 e0       	ldi	r20, 0x03	; 3
    1a2c:	8b 39       	cpi	r24, 0x9B	; 155
    1a2e:	94 07       	cpc	r25, r20
    1a30:	09 f4       	brne	.+2      	; 0x1a34 <pvPortMalloc+0xbc>
    1a32:	7d c0       	rjmp	.+250    	; 0x1b2e <pvPortMalloc+0x1b6>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1a34:	e9 85       	ldd	r30, Y+9	; 0x09
    1a36:	fa 85       	ldd	r31, Y+10	; 0x0a
    1a38:	20 81       	ld	r18, Z
    1a3a:	31 81       	ldd	r19, Z+1	; 0x01
    1a3c:	80 91 73 00 	lds	r24, 0x0073
    1a40:	90 91 74 00 	lds	r25, 0x0074
    1a44:	82 0f       	add	r24, r18
    1a46:	93 1f       	adc	r25, r19
    1a48:	9e 83       	std	Y+6, r25	; 0x06
    1a4a:	8d 83       	std	Y+5, r24	; 0x05

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1a4c:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a4e:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a50:	80 81       	ld	r24, Z
    1a52:	91 81       	ldd	r25, Z+1	; 0x01
    1a54:	e9 85       	ldd	r30, Y+9	; 0x09
    1a56:	fa 85       	ldd	r31, Y+10	; 0x0a
    1a58:	91 83       	std	Z+1, r25	; 0x01
    1a5a:	80 83       	st	Z, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1a5c:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a5e:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a60:	22 81       	ldd	r18, Z+2	; 0x02
    1a62:	33 81       	ldd	r19, Z+3	; 0x03
    1a64:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a66:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a68:	28 1b       	sub	r18, r24
    1a6a:	39 0b       	sbc	r19, r25
    1a6c:	80 91 73 00 	lds	r24, 0x0073
    1a70:	90 91 74 00 	lds	r25, 0x0074
    1a74:	88 0f       	add	r24, r24
    1a76:	99 1f       	adc	r25, r25
    1a78:	82 17       	cp	r24, r18
    1a7a:	93 07       	cpc	r25, r19
    1a7c:	08 f0       	brcs	.+2      	; 0x1a80 <pvPortMalloc+0x108>
    1a7e:	47 c0       	rjmp	.+142    	; 0x1b0e <pvPortMalloc+0x196>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1a80:	2b 85       	ldd	r18, Y+11	; 0x0b
    1a82:	3c 85       	ldd	r19, Y+12	; 0x0c
    1a84:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a86:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a88:	82 0f       	add	r24, r18
    1a8a:	93 1f       	adc	r25, r19
    1a8c:	98 87       	std	Y+8, r25	; 0x08
    1a8e:	8f 83       	std	Y+7, r24	; 0x07

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1a90:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a92:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a94:	22 81       	ldd	r18, Z+2	; 0x02
    1a96:	33 81       	ldd	r19, Z+3	; 0x03
    1a98:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a9a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a9c:	a9 01       	movw	r20, r18
    1a9e:	48 1b       	sub	r20, r24
    1aa0:	59 0b       	sbc	r21, r25
    1aa2:	ca 01       	movw	r24, r20
    1aa4:	ef 81       	ldd	r30, Y+7	; 0x07
    1aa6:	f8 85       	ldd	r31, Y+8	; 0x08
    1aa8:	93 83       	std	Z+3, r25	; 0x03
    1aaa:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->xBlockSize = xWantedSize;
    1aac:	eb 85       	ldd	r30, Y+11	; 0x0b
    1aae:	fc 85       	ldd	r31, Y+12	; 0x0c
    1ab0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ab2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ab4:	93 83       	std	Z+3, r25	; 0x03
    1ab6:	82 83       	std	Z+2, r24	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1ab8:	ef 81       	ldd	r30, Y+7	; 0x07
    1aba:	f8 85       	ldd	r31, Y+8	; 0x08
    1abc:	82 81       	ldd	r24, Z+2	; 0x02
    1abe:	93 81       	ldd	r25, Z+3	; 0x03
    1ac0:	9a 83       	std	Y+2, r25	; 0x02
    1ac2:	89 83       	std	Y+1, r24	; 0x01
    1ac4:	87 e9       	ldi	r24, 0x97	; 151
    1ac6:	93 e0       	ldi	r25, 0x03	; 3
    1ac8:	9c 83       	std	Y+4, r25	; 0x04
    1aca:	8b 83       	std	Y+3, r24	; 0x03
    1acc:	06 c0       	rjmp	.+12     	; 0x1ada <pvPortMalloc+0x162>
    1ace:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad2:	80 81       	ld	r24, Z
    1ad4:	91 81       	ldd	r25, Z+1	; 0x01
    1ad6:	9c 83       	std	Y+4, r25	; 0x04
    1ad8:	8b 83       	std	Y+3, r24	; 0x03
    1ada:	eb 81       	ldd	r30, Y+3	; 0x03
    1adc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ade:	01 90       	ld	r0, Z+
    1ae0:	f0 81       	ld	r31, Z
    1ae2:	e0 2d       	mov	r30, r0
    1ae4:	22 81       	ldd	r18, Z+2	; 0x02
    1ae6:	33 81       	ldd	r19, Z+3	; 0x03
    1ae8:	89 81       	ldd	r24, Y+1	; 0x01
    1aea:	9a 81       	ldd	r25, Y+2	; 0x02
    1aec:	28 17       	cp	r18, r24
    1aee:	39 07       	cpc	r19, r25
    1af0:	70 f3       	brcs	.-36     	; 0x1ace <pvPortMalloc+0x156>
    1af2:	eb 81       	ldd	r30, Y+3	; 0x03
    1af4:	fc 81       	ldd	r31, Y+4	; 0x04
    1af6:	80 81       	ld	r24, Z
    1af8:	91 81       	ldd	r25, Z+1	; 0x01
    1afa:	ef 81       	ldd	r30, Y+7	; 0x07
    1afc:	f8 85       	ldd	r31, Y+8	; 0x08
    1afe:	91 83       	std	Z+1, r25	; 0x01
    1b00:	80 83       	st	Z, r24
    1b02:	eb 81       	ldd	r30, Y+3	; 0x03
    1b04:	fc 81       	ldd	r31, Y+4	; 0x04
    1b06:	8f 81       	ldd	r24, Y+7	; 0x07
    1b08:	98 85       	ldd	r25, Y+8	; 0x08
    1b0a:	91 83       	std	Z+1, r25	; 0x01
    1b0c:	80 83       	st	Z, r24
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1b0e:	20 91 71 00 	lds	r18, 0x0071
    1b12:	30 91 72 00 	lds	r19, 0x0072
    1b16:	eb 85       	ldd	r30, Y+11	; 0x0b
    1b18:	fc 85       	ldd	r31, Y+12	; 0x0c
    1b1a:	82 81       	ldd	r24, Z+2	; 0x02
    1b1c:	93 81       	ldd	r25, Z+3	; 0x03
    1b1e:	a9 01       	movw	r20, r18
    1b20:	48 1b       	sub	r20, r24
    1b22:	59 0b       	sbc	r21, r25
    1b24:	ca 01       	movw	r24, r20
    1b26:	90 93 72 00 	sts	0x0072, r25
    1b2a:	80 93 71 00 	sts	0x0071, r24
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1b2e:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1b32:	8d 81       	ldd	r24, Y+5	; 0x05
    1b34:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1b36:	2e 96       	adiw	r28, 0x0e	; 14
    1b38:	0f b6       	in	r0, 0x3f	; 63
    1b3a:	f8 94       	cli
    1b3c:	de bf       	out	0x3e, r29	; 62
    1b3e:	0f be       	out	0x3f, r0	; 63
    1b40:	cd bf       	out	0x3d, r28	; 61
    1b42:	cf 91       	pop	r28
    1b44:	df 91       	pop	r29
    1b46:	08 95       	ret

00001b48 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b48:	df 93       	push	r29
    1b4a:	cf 93       	push	r28
    1b4c:	cd b7       	in	r28, 0x3d	; 61
    1b4e:	de b7       	in	r29, 0x3e	; 62
    1b50:	2a 97       	sbiw	r28, 0x0a	; 10
    1b52:	0f b6       	in	r0, 0x3f	; 63
    1b54:	f8 94       	cli
    1b56:	de bf       	out	0x3e, r29	; 62
    1b58:	0f be       	out	0x3f, r0	; 63
    1b5a:	cd bf       	out	0x3d, r28	; 61
    1b5c:	9a 87       	std	Y+10, r25	; 0x0a
    1b5e:	89 87       	std	Y+9, r24	; 0x09
uint8_t *puc = ( uint8_t * ) pv;
    1b60:	89 85       	ldd	r24, Y+9	; 0x09
    1b62:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b64:	98 87       	std	Y+8, r25	; 0x08
    1b66:	8f 83       	std	Y+7, r24	; 0x07
BlockLink_t *pxLink;

	if( pv != NULL )
    1b68:	89 85       	ldd	r24, Y+9	; 0x09
    1b6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b6c:	00 97       	sbiw	r24, 0x00	; 0
    1b6e:	09 f4       	brne	.+2      	; 0x1b72 <vPortFree+0x2a>
    1b70:	4f c0       	rjmp	.+158    	; 0x1c10 <vPortFree+0xc8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1b72:	80 91 73 00 	lds	r24, 0x0073
    1b76:	90 91 74 00 	lds	r25, 0x0074
    1b7a:	22 27       	eor	r18, r18
    1b7c:	33 27       	eor	r19, r19
    1b7e:	28 1b       	sub	r18, r24
    1b80:	39 0b       	sbc	r19, r25
    1b82:	8f 81       	ldd	r24, Y+7	; 0x07
    1b84:	98 85       	ldd	r25, Y+8	; 0x08
    1b86:	82 0f       	add	r24, r18
    1b88:	93 1f       	adc	r25, r19
    1b8a:	98 87       	std	Y+8, r25	; 0x08
    1b8c:	8f 83       	std	Y+7, r24	; 0x07

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    1b8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1b90:	98 85       	ldd	r25, Y+8	; 0x08
    1b92:	9e 83       	std	Y+6, r25	; 0x06
    1b94:	8d 83       	std	Y+5, r24	; 0x05

		vTaskSuspendAll();
    1b96:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1b9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1b9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1b9e:	82 81       	ldd	r24, Z+2	; 0x02
    1ba0:	93 81       	ldd	r25, Z+3	; 0x03
    1ba2:	9a 83       	std	Y+2, r25	; 0x02
    1ba4:	89 83       	std	Y+1, r24	; 0x01
    1ba6:	87 e9       	ldi	r24, 0x97	; 151
    1ba8:	93 e0       	ldi	r25, 0x03	; 3
    1baa:	9c 83       	std	Y+4, r25	; 0x04
    1bac:	8b 83       	std	Y+3, r24	; 0x03
    1bae:	06 c0       	rjmp	.+12     	; 0x1bbc <vPortFree+0x74>
    1bb0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb4:	80 81       	ld	r24, Z
    1bb6:	91 81       	ldd	r25, Z+1	; 0x01
    1bb8:	9c 83       	std	Y+4, r25	; 0x04
    1bba:	8b 83       	std	Y+3, r24	; 0x03
    1bbc:	eb 81       	ldd	r30, Y+3	; 0x03
    1bbe:	fc 81       	ldd	r31, Y+4	; 0x04
    1bc0:	01 90       	ld	r0, Z+
    1bc2:	f0 81       	ld	r31, Z
    1bc4:	e0 2d       	mov	r30, r0
    1bc6:	22 81       	ldd	r18, Z+2	; 0x02
    1bc8:	33 81       	ldd	r19, Z+3	; 0x03
    1bca:	89 81       	ldd	r24, Y+1	; 0x01
    1bcc:	9a 81       	ldd	r25, Y+2	; 0x02
    1bce:	28 17       	cp	r18, r24
    1bd0:	39 07       	cpc	r19, r25
    1bd2:	70 f3       	brcs	.-36     	; 0x1bb0 <vPortFree+0x68>
    1bd4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd8:	80 81       	ld	r24, Z
    1bda:	91 81       	ldd	r25, Z+1	; 0x01
    1bdc:	ed 81       	ldd	r30, Y+5	; 0x05
    1bde:	fe 81       	ldd	r31, Y+6	; 0x06
    1be0:	91 83       	std	Z+1, r25	; 0x01
    1be2:	80 83       	st	Z, r24
    1be4:	eb 81       	ldd	r30, Y+3	; 0x03
    1be6:	fc 81       	ldd	r31, Y+4	; 0x04
    1be8:	8d 81       	ldd	r24, Y+5	; 0x05
    1bea:	9e 81       	ldd	r25, Y+6	; 0x06
    1bec:	91 83       	std	Z+1, r25	; 0x01
    1bee:	80 83       	st	Z, r24
			xFreeBytesRemaining += pxLink->xBlockSize;
    1bf0:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf2:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf4:	22 81       	ldd	r18, Z+2	; 0x02
    1bf6:	33 81       	ldd	r19, Z+3	; 0x03
    1bf8:	80 91 71 00 	lds	r24, 0x0071
    1bfc:	90 91 72 00 	lds	r25, 0x0072
    1c00:	82 0f       	add	r24, r18
    1c02:	93 1f       	adc	r25, r19
    1c04:	90 93 72 00 	sts	0x0072, r25
    1c08:	80 93 71 00 	sts	0x0071, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    1c0c:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
	}
}
    1c10:	2a 96       	adiw	r28, 0x0a	; 10
    1c12:	0f b6       	in	r0, 0x3f	; 63
    1c14:	f8 94       	cli
    1c16:	de bf       	out	0x3e, r29	; 62
    1c18:	0f be       	out	0x3f, r0	; 63
    1c1a:	cd bf       	out	0x3d, r28	; 61
    1c1c:	cf 91       	pop	r28
    1c1e:	df 91       	pop	r29
    1c20:	08 95       	ret

00001c22 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1c22:	df 93       	push	r29
    1c24:	cf 93       	push	r28
    1c26:	cd b7       	in	r28, 0x3d	; 61
    1c28:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
    1c2a:	80 91 71 00 	lds	r24, 0x0071
    1c2e:	90 91 72 00 	lds	r25, 0x0072
}
    1c32:	cf 91       	pop	r28
    1c34:	df 91       	pop	r29
    1c36:	08 95       	ret

00001c38 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1c38:	df 93       	push	r29
    1c3a:	cf 93       	push	r28
    1c3c:	cd b7       	in	r28, 0x3d	; 61
    1c3e:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
    1c40:	cf 91       	pop	r28
    1c42:	df 91       	pop	r29
    1c44:	08 95       	ret

00001c46 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    1c46:	df 93       	push	r29
    1c48:	cf 93       	push	r28
    1c4a:	00 d0       	rcall	.+0      	; 0x1c4c <prvHeapInit+0x6>
    1c4c:	00 d0       	rcall	.+0      	; 0x1c4e <prvHeapInit+0x8>
    1c4e:	cd b7       	in	r28, 0x3d	; 61
    1c50:	de b7       	in	r29, 0x3e	; 62
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1c52:	88 e7       	ldi	r24, 0x78	; 120
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	9a 83       	std	Y+2, r25	; 0x02
    1c58:	89 83       	std	Y+1, r24	; 0x01

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    1c5a:	89 81       	ldd	r24, Y+1	; 0x01
    1c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5e:	90 93 98 03 	sts	0x0398, r25
    1c62:	80 93 97 03 	sts	0x0397, r24
	xStart.xBlockSize = ( size_t ) 0;
    1c66:	10 92 9a 03 	sts	0x039A, r1
    1c6a:	10 92 99 03 	sts	0x0399, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    1c6e:	8f e1       	ldi	r24, 0x1F	; 31
    1c70:	93 e0       	ldi	r25, 0x03	; 3
    1c72:	90 93 9e 03 	sts	0x039E, r25
    1c76:	80 93 9d 03 	sts	0x039D, r24
	xEnd.pxNextFreeBlock = NULL;
    1c7a:	10 92 9c 03 	sts	0x039C, r1
    1c7e:	10 92 9b 03 	sts	0x039B, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	9a 81       	ldd	r25, Y+2	; 0x02
    1c86:	9c 83       	std	Y+4, r25	; 0x04
    1c88:	8b 83       	std	Y+3, r24	; 0x03
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    1c8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c8e:	8f e1       	ldi	r24, 0x1F	; 31
    1c90:	93 e0       	ldi	r25, 0x03	; 3
    1c92:	93 83       	std	Z+3, r25	; 0x03
    1c94:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1c96:	eb 81       	ldd	r30, Y+3	; 0x03
    1c98:	fc 81       	ldd	r31, Y+4	; 0x04
    1c9a:	8b e9       	ldi	r24, 0x9B	; 155
    1c9c:	93 e0       	ldi	r25, 0x03	; 3
    1c9e:	91 83       	std	Z+1, r25	; 0x01
    1ca0:	80 83       	st	Z, r24
}
    1ca2:	0f 90       	pop	r0
    1ca4:	0f 90       	pop	r0
    1ca6:	0f 90       	pop	r0
    1ca8:	0f 90       	pop	r0
    1caa:	cf 91       	pop	r28
    1cac:	df 91       	pop	r29
    1cae:	08 95       	ret

00001cb0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1cb0:	df 93       	push	r29
    1cb2:	cf 93       	push	r28
    1cb4:	00 d0       	rcall	.+0      	; 0x1cb6 <vListInitialise+0x6>
    1cb6:	cd b7       	in	r28, 0x3d	; 61
    1cb8:	de b7       	in	r29, 0x3e	; 62
    1cba:	9a 83       	std	Y+2, r25	; 0x02
    1cbc:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1cbe:	89 81       	ldd	r24, Y+1	; 0x01
    1cc0:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc2:	03 96       	adiw	r24, 0x03	; 3
    1cc4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cc6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cc8:	92 83       	std	Z+2, r25	; 0x02
    1cca:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1ccc:	e9 81       	ldd	r30, Y+1	; 0x01
    1cce:	fa 81       	ldd	r31, Y+2	; 0x02
    1cd0:	8f ef       	ldi	r24, 0xFF	; 255
    1cd2:	9f ef       	ldi	r25, 0xFF	; 255
    1cd4:	94 83       	std	Z+4, r25	; 0x04
    1cd6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1cd8:	89 81       	ldd	r24, Y+1	; 0x01
    1cda:	9a 81       	ldd	r25, Y+2	; 0x02
    1cdc:	03 96       	adiw	r24, 0x03	; 3
    1cde:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce2:	96 83       	std	Z+6, r25	; 0x06
    1ce4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ce6:	89 81       	ldd	r24, Y+1	; 0x01
    1ce8:	9a 81       	ldd	r25, Y+2	; 0x02
    1cea:	03 96       	adiw	r24, 0x03	; 3
    1cec:	e9 81       	ldd	r30, Y+1	; 0x01
    1cee:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf0:	90 87       	std	Z+8, r25	; 0x08
    1cf2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf8:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1cfa:	0f 90       	pop	r0
    1cfc:	0f 90       	pop	r0
    1cfe:	cf 91       	pop	r28
    1d00:	df 91       	pop	r29
    1d02:	08 95       	ret

00001d04 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1d04:	df 93       	push	r29
    1d06:	cf 93       	push	r28
    1d08:	00 d0       	rcall	.+0      	; 0x1d0a <vListInitialiseItem+0x6>
    1d0a:	cd b7       	in	r28, 0x3d	; 61
    1d0c:	de b7       	in	r29, 0x3e	; 62
    1d0e:	9a 83       	std	Y+2, r25	; 0x02
    1d10:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1d12:	e9 81       	ldd	r30, Y+1	; 0x01
    1d14:	fa 81       	ldd	r31, Y+2	; 0x02
    1d16:	11 86       	std	Z+9, r1	; 0x09
    1d18:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1d1a:	0f 90       	pop	r0
    1d1c:	0f 90       	pop	r0
    1d1e:	cf 91       	pop	r28
    1d20:	df 91       	pop	r29
    1d22:	08 95       	ret

00001d24 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1d24:	df 93       	push	r29
    1d26:	cf 93       	push	r28
    1d28:	00 d0       	rcall	.+0      	; 0x1d2a <vListInsertEnd+0x6>
    1d2a:	00 d0       	rcall	.+0      	; 0x1d2c <vListInsertEnd+0x8>
    1d2c:	00 d0       	rcall	.+0      	; 0x1d2e <vListInsertEnd+0xa>
    1d2e:	cd b7       	in	r28, 0x3d	; 61
    1d30:	de b7       	in	r29, 0x3e	; 62
    1d32:	9c 83       	std	Y+4, r25	; 0x04
    1d34:	8b 83       	std	Y+3, r24	; 0x03
    1d36:	7e 83       	std	Y+6, r23	; 0x06
    1d38:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    1d3a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d3e:	81 81       	ldd	r24, Z+1	; 0x01
    1d40:	92 81       	ldd	r25, Z+2	; 0x02
    1d42:	9a 83       	std	Y+2, r25	; 0x02
    1d44:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1d46:	ed 81       	ldd	r30, Y+5	; 0x05
    1d48:	fe 81       	ldd	r31, Y+6	; 0x06
    1d4a:	89 81       	ldd	r24, Y+1	; 0x01
    1d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4e:	93 83       	std	Z+3, r25	; 0x03
    1d50:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1d52:	e9 81       	ldd	r30, Y+1	; 0x01
    1d54:	fa 81       	ldd	r31, Y+2	; 0x02
    1d56:	84 81       	ldd	r24, Z+4	; 0x04
    1d58:	95 81       	ldd	r25, Z+5	; 0x05
    1d5a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d5c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d5e:	95 83       	std	Z+5, r25	; 0x05
    1d60:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1d62:	e9 81       	ldd	r30, Y+1	; 0x01
    1d64:	fa 81       	ldd	r31, Y+2	; 0x02
    1d66:	04 80       	ldd	r0, Z+4	; 0x04
    1d68:	f5 81       	ldd	r31, Z+5	; 0x05
    1d6a:	e0 2d       	mov	r30, r0
    1d6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d70:	93 83       	std	Z+3, r25	; 0x03
    1d72:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1d74:	e9 81       	ldd	r30, Y+1	; 0x01
    1d76:	fa 81       	ldd	r31, Y+2	; 0x02
    1d78:	8d 81       	ldd	r24, Y+5	; 0x05
    1d7a:	9e 81       	ldd	r25, Y+6	; 0x06
    1d7c:	95 83       	std	Z+5, r25	; 0x05
    1d7e:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1d80:	ed 81       	ldd	r30, Y+5	; 0x05
    1d82:	fe 81       	ldd	r31, Y+6	; 0x06
    1d84:	8b 81       	ldd	r24, Y+3	; 0x03
    1d86:	9c 81       	ldd	r25, Y+4	; 0x04
    1d88:	91 87       	std	Z+9, r25	; 0x09
    1d8a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1d8c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d8e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d90:	80 81       	ld	r24, Z
    1d92:	8f 5f       	subi	r24, 0xFF	; 255
    1d94:	eb 81       	ldd	r30, Y+3	; 0x03
    1d96:	fc 81       	ldd	r31, Y+4	; 0x04
    1d98:	80 83       	st	Z, r24
}
    1d9a:	26 96       	adiw	r28, 0x06	; 6
    1d9c:	0f b6       	in	r0, 0x3f	; 63
    1d9e:	f8 94       	cli
    1da0:	de bf       	out	0x3e, r29	; 62
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	cd bf       	out	0x3d, r28	; 61
    1da6:	cf 91       	pop	r28
    1da8:	df 91       	pop	r29
    1daa:	08 95       	ret

00001dac <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1dac:	df 93       	push	r29
    1dae:	cf 93       	push	r28
    1db0:	cd b7       	in	r28, 0x3d	; 61
    1db2:	de b7       	in	r29, 0x3e	; 62
    1db4:	28 97       	sbiw	r28, 0x08	; 8
    1db6:	0f b6       	in	r0, 0x3f	; 63
    1db8:	f8 94       	cli
    1dba:	de bf       	out	0x3e, r29	; 62
    1dbc:	0f be       	out	0x3f, r0	; 63
    1dbe:	cd bf       	out	0x3d, r28	; 61
    1dc0:	9e 83       	std	Y+6, r25	; 0x06
    1dc2:	8d 83       	std	Y+5, r24	; 0x05
    1dc4:	78 87       	std	Y+8, r23	; 0x08
    1dc6:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1dc8:	ef 81       	ldd	r30, Y+7	; 0x07
    1dca:	f8 85       	ldd	r31, Y+8	; 0x08
    1dcc:	80 81       	ld	r24, Z
    1dce:	91 81       	ldd	r25, Z+1	; 0x01
    1dd0:	9a 83       	std	Y+2, r25	; 0x02
    1dd2:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1dd4:	89 81       	ldd	r24, Y+1	; 0x01
    1dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    1dd8:	2f ef       	ldi	r18, 0xFF	; 255
    1dda:	8f 3f       	cpi	r24, 0xFF	; 255
    1ddc:	92 07       	cpc	r25, r18
    1dde:	39 f4       	brne	.+14     	; 0x1dee <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1de0:	ed 81       	ldd	r30, Y+5	; 0x05
    1de2:	fe 81       	ldd	r31, Y+6	; 0x06
    1de4:	87 81       	ldd	r24, Z+7	; 0x07
    1de6:	90 85       	ldd	r25, Z+8	; 0x08
    1de8:	9c 83       	std	Y+4, r25	; 0x04
    1dea:	8b 83       	std	Y+3, r24	; 0x03
    1dec:	18 c0       	rjmp	.+48     	; 0x1e1e <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1dee:	8d 81       	ldd	r24, Y+5	; 0x05
    1df0:	9e 81       	ldd	r25, Y+6	; 0x06
    1df2:	03 96       	adiw	r24, 0x03	; 3
    1df4:	9c 83       	std	Y+4, r25	; 0x04
    1df6:	8b 83       	std	Y+3, r24	; 0x03
    1df8:	06 c0       	rjmp	.+12     	; 0x1e06 <vListInsert+0x5a>
    1dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfe:	82 81       	ldd	r24, Z+2	; 0x02
    1e00:	93 81       	ldd	r25, Z+3	; 0x03
    1e02:	9c 83       	std	Y+4, r25	; 0x04
    1e04:	8b 83       	std	Y+3, r24	; 0x03
    1e06:	eb 81       	ldd	r30, Y+3	; 0x03
    1e08:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0a:	02 80       	ldd	r0, Z+2	; 0x02
    1e0c:	f3 81       	ldd	r31, Z+3	; 0x03
    1e0e:	e0 2d       	mov	r30, r0
    1e10:	20 81       	ld	r18, Z
    1e12:	31 81       	ldd	r19, Z+1	; 0x01
    1e14:	89 81       	ldd	r24, Y+1	; 0x01
    1e16:	9a 81       	ldd	r25, Y+2	; 0x02
    1e18:	82 17       	cp	r24, r18
    1e1a:	93 07       	cpc	r25, r19
    1e1c:	70 f7       	brcc	.-36     	; 0x1dfa <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1e1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e20:	fc 81       	ldd	r31, Y+4	; 0x04
    1e22:	82 81       	ldd	r24, Z+2	; 0x02
    1e24:	93 81       	ldd	r25, Z+3	; 0x03
    1e26:	ef 81       	ldd	r30, Y+7	; 0x07
    1e28:	f8 85       	ldd	r31, Y+8	; 0x08
    1e2a:	93 83       	std	Z+3, r25	; 0x03
    1e2c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1e2e:	ef 81       	ldd	r30, Y+7	; 0x07
    1e30:	f8 85       	ldd	r31, Y+8	; 0x08
    1e32:	02 80       	ldd	r0, Z+2	; 0x02
    1e34:	f3 81       	ldd	r31, Z+3	; 0x03
    1e36:	e0 2d       	mov	r30, r0
    1e38:	8f 81       	ldd	r24, Y+7	; 0x07
    1e3a:	98 85       	ldd	r25, Y+8	; 0x08
    1e3c:	95 83       	std	Z+5, r25	; 0x05
    1e3e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1e40:	ef 81       	ldd	r30, Y+7	; 0x07
    1e42:	f8 85       	ldd	r31, Y+8	; 0x08
    1e44:	8b 81       	ldd	r24, Y+3	; 0x03
    1e46:	9c 81       	ldd	r25, Y+4	; 0x04
    1e48:	95 83       	std	Z+5, r25	; 0x05
    1e4a:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e50:	8f 81       	ldd	r24, Y+7	; 0x07
    1e52:	98 85       	ldd	r25, Y+8	; 0x08
    1e54:	93 83       	std	Z+3, r25	; 0x03
    1e56:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e58:	ef 81       	ldd	r30, Y+7	; 0x07
    1e5a:	f8 85       	ldd	r31, Y+8	; 0x08
    1e5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e60:	91 87       	std	Z+9, r25	; 0x09
    1e62:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1e64:	ed 81       	ldd	r30, Y+5	; 0x05
    1e66:	fe 81       	ldd	r31, Y+6	; 0x06
    1e68:	80 81       	ld	r24, Z
    1e6a:	8f 5f       	subi	r24, 0xFF	; 255
    1e6c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e6e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e70:	80 83       	st	Z, r24
}
    1e72:	28 96       	adiw	r28, 0x08	; 8
    1e74:	0f b6       	in	r0, 0x3f	; 63
    1e76:	f8 94       	cli
    1e78:	de bf       	out	0x3e, r29	; 62
    1e7a:	0f be       	out	0x3f, r0	; 63
    1e7c:	cd bf       	out	0x3d, r28	; 61
    1e7e:	cf 91       	pop	r28
    1e80:	df 91       	pop	r29
    1e82:	08 95       	ret

00001e84 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1e84:	df 93       	push	r29
    1e86:	cf 93       	push	r28
    1e88:	00 d0       	rcall	.+0      	; 0x1e8a <uxListRemove+0x6>
    1e8a:	00 d0       	rcall	.+0      	; 0x1e8c <uxListRemove+0x8>
    1e8c:	cd b7       	in	r28, 0x3d	; 61
    1e8e:	de b7       	in	r29, 0x3e	; 62
    1e90:	9c 83       	std	Y+4, r25	; 0x04
    1e92:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1e94:	eb 81       	ldd	r30, Y+3	; 0x03
    1e96:	fc 81       	ldd	r31, Y+4	; 0x04
    1e98:	80 85       	ldd	r24, Z+8	; 0x08
    1e9a:	91 85       	ldd	r25, Z+9	; 0x09
    1e9c:	9a 83       	std	Y+2, r25	; 0x02
    1e9e:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ea0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ea2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ea4:	a2 81       	ldd	r26, Z+2	; 0x02
    1ea6:	b3 81       	ldd	r27, Z+3	; 0x03
    1ea8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eaa:	fc 81       	ldd	r31, Y+4	; 0x04
    1eac:	84 81       	ldd	r24, Z+4	; 0x04
    1eae:	95 81       	ldd	r25, Z+5	; 0x05
    1eb0:	15 96       	adiw	r26, 0x05	; 5
    1eb2:	9c 93       	st	X, r25
    1eb4:	8e 93       	st	-X, r24
    1eb6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1eb8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eba:	fc 81       	ldd	r31, Y+4	; 0x04
    1ebc:	a4 81       	ldd	r26, Z+4	; 0x04
    1ebe:	b5 81       	ldd	r27, Z+5	; 0x05
    1ec0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ec2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ec4:	82 81       	ldd	r24, Z+2	; 0x02
    1ec6:	93 81       	ldd	r25, Z+3	; 0x03
    1ec8:	13 96       	adiw	r26, 0x03	; 3
    1eca:	9c 93       	st	X, r25
    1ecc:	8e 93       	st	-X, r24
    1ece:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed4:	21 81       	ldd	r18, Z+1	; 0x01
    1ed6:	32 81       	ldd	r19, Z+2	; 0x02
    1ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eda:	9c 81       	ldd	r25, Y+4	; 0x04
    1edc:	28 17       	cp	r18, r24
    1ede:	39 07       	cpc	r19, r25
    1ee0:	41 f4       	brne	.+16     	; 0x1ef2 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1ee2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ee4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ee6:	84 81       	ldd	r24, Z+4	; 0x04
    1ee8:	95 81       	ldd	r25, Z+5	; 0x05
    1eea:	e9 81       	ldd	r30, Y+1	; 0x01
    1eec:	fa 81       	ldd	r31, Y+2	; 0x02
    1eee:	92 83       	std	Z+2, r25	; 0x02
    1ef0:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1ef2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef6:	11 86       	std	Z+9, r1	; 0x09
    1ef8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1efa:	e9 81       	ldd	r30, Y+1	; 0x01
    1efc:	fa 81       	ldd	r31, Y+2	; 0x02
    1efe:	80 81       	ld	r24, Z
    1f00:	81 50       	subi	r24, 0x01	; 1
    1f02:	e9 81       	ldd	r30, Y+1	; 0x01
    1f04:	fa 81       	ldd	r31, Y+2	; 0x02
    1f06:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1f08:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0c:	80 81       	ld	r24, Z
}
    1f0e:	0f 90       	pop	r0
    1f10:	0f 90       	pop	r0
    1f12:	0f 90       	pop	r0
    1f14:	0f 90       	pop	r0
    1f16:	cf 91       	pop	r28
    1f18:	df 91       	pop	r29
    1f1a:	08 95       	ret

00001f1c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1f1c:	df 93       	push	r29
    1f1e:	cf 93       	push	r28
    1f20:	cd b7       	in	r28, 0x3d	; 61
    1f22:	de b7       	in	r29, 0x3e	; 62
    1f24:	28 97       	sbiw	r28, 0x08	; 8
    1f26:	0f b6       	in	r0, 0x3f	; 63
    1f28:	f8 94       	cli
    1f2a:	de bf       	out	0x3e, r29	; 62
    1f2c:	0f be       	out	0x3f, r0	; 63
    1f2e:	cd bf       	out	0x3d, r28	; 61
    1f30:	9c 83       	std	Y+4, r25	; 0x04
    1f32:	8b 83       	std	Y+3, r24	; 0x03
    1f34:	7e 83       	std	Y+6, r23	; 0x06
    1f36:	6d 83       	std	Y+5, r22	; 0x05
    1f38:	58 87       	std	Y+8, r21	; 0x08
    1f3a:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1f3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f40:	81 e1       	ldi	r24, 0x11	; 17
    1f42:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f44:	8b 81       	ldd	r24, Y+3	; 0x03
    1f46:	9c 81       	ldd	r25, Y+4	; 0x04
    1f48:	01 97       	sbiw	r24, 0x01	; 1
    1f4a:	9c 83       	std	Y+4, r25	; 0x04
    1f4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1f4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1f50:	fc 81       	ldd	r31, Y+4	; 0x04
    1f52:	82 e2       	ldi	r24, 0x22	; 34
    1f54:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f56:	8b 81       	ldd	r24, Y+3	; 0x03
    1f58:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5a:	01 97       	sbiw	r24, 0x01	; 1
    1f5c:	9c 83       	std	Y+4, r25	; 0x04
    1f5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1f60:	eb 81       	ldd	r30, Y+3	; 0x03
    1f62:	fc 81       	ldd	r31, Y+4	; 0x04
    1f64:	83 e3       	ldi	r24, 0x33	; 51
    1f66:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f68:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f6c:	01 97       	sbiw	r24, 0x01	; 1
    1f6e:	9c 83       	std	Y+4, r25	; 0x04
    1f70:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1f72:	8d 81       	ldd	r24, Y+5	; 0x05
    1f74:	9e 81       	ldd	r25, Y+6	; 0x06
    1f76:	9a 83       	std	Y+2, r25	; 0x02
    1f78:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1f7a:	89 81       	ldd	r24, Y+1	; 0x01
    1f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f80:	80 83       	st	Z, r24
	pxTopOfStack--;
    1f82:	8b 81       	ldd	r24, Y+3	; 0x03
    1f84:	9c 81       	ldd	r25, Y+4	; 0x04
    1f86:	01 97       	sbiw	r24, 0x01	; 1
    1f88:	9c 83       	std	Y+4, r25	; 0x04
    1f8a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1f8c:	89 81       	ldd	r24, Y+1	; 0x01
    1f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f90:	89 2f       	mov	r24, r25
    1f92:	99 27       	eor	r25, r25
    1f94:	9a 83       	std	Y+2, r25	; 0x02
    1f96:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1f98:	89 81       	ldd	r24, Y+1	; 0x01
    1f9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa4:	01 97       	sbiw	r24, 0x01	; 1
    1fa6:	9c 83       	std	Y+4, r25	; 0x04
    1fa8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1faa:	eb 81       	ldd	r30, Y+3	; 0x03
    1fac:	fc 81       	ldd	r31, Y+4	; 0x04
    1fae:	10 82       	st	Z, r1
	pxTopOfStack--;
    1fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb4:	01 97       	sbiw	r24, 0x01	; 1
    1fb6:	9c 83       	std	Y+4, r25	; 0x04
    1fb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1fba:	eb 81       	ldd	r30, Y+3	; 0x03
    1fbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1fbe:	80 e8       	ldi	r24, 0x80	; 128
    1fc0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fc6:	01 97       	sbiw	r24, 0x01	; 1
    1fc8:	9c 83       	std	Y+4, r25	; 0x04
    1fca:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1fcc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fce:	fc 81       	ldd	r31, Y+4	; 0x04
    1fd0:	10 82       	st	Z, r1
	pxTopOfStack--;
    1fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd6:	01 97       	sbiw	r24, 0x01	; 1
    1fd8:	9c 83       	std	Y+4, r25	; 0x04
    1fda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1fdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1fde:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe0:	82 e0       	ldi	r24, 0x02	; 2
    1fe2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1fe4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe8:	01 97       	sbiw	r24, 0x01	; 1
    1fea:	9c 83       	std	Y+4, r25	; 0x04
    1fec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1fee:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff2:	83 e0       	ldi	r24, 0x03	; 3
    1ff4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffa:	01 97       	sbiw	r24, 0x01	; 1
    1ffc:	9c 83       	std	Y+4, r25	; 0x04
    1ffe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    2000:	eb 81       	ldd	r30, Y+3	; 0x03
    2002:	fc 81       	ldd	r31, Y+4	; 0x04
    2004:	84 e0       	ldi	r24, 0x04	; 4
    2006:	80 83       	st	Z, r24
	pxTopOfStack--;
    2008:	8b 81       	ldd	r24, Y+3	; 0x03
    200a:	9c 81       	ldd	r25, Y+4	; 0x04
    200c:	01 97       	sbiw	r24, 0x01	; 1
    200e:	9c 83       	std	Y+4, r25	; 0x04
    2010:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2012:	eb 81       	ldd	r30, Y+3	; 0x03
    2014:	fc 81       	ldd	r31, Y+4	; 0x04
    2016:	85 e0       	ldi	r24, 0x05	; 5
    2018:	80 83       	st	Z, r24
	pxTopOfStack--;
    201a:	8b 81       	ldd	r24, Y+3	; 0x03
    201c:	9c 81       	ldd	r25, Y+4	; 0x04
    201e:	01 97       	sbiw	r24, 0x01	; 1
    2020:	9c 83       	std	Y+4, r25	; 0x04
    2022:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2024:	eb 81       	ldd	r30, Y+3	; 0x03
    2026:	fc 81       	ldd	r31, Y+4	; 0x04
    2028:	86 e0       	ldi	r24, 0x06	; 6
    202a:	80 83       	st	Z, r24
	pxTopOfStack--;
    202c:	8b 81       	ldd	r24, Y+3	; 0x03
    202e:	9c 81       	ldd	r25, Y+4	; 0x04
    2030:	01 97       	sbiw	r24, 0x01	; 1
    2032:	9c 83       	std	Y+4, r25	; 0x04
    2034:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    2036:	eb 81       	ldd	r30, Y+3	; 0x03
    2038:	fc 81       	ldd	r31, Y+4	; 0x04
    203a:	87 e0       	ldi	r24, 0x07	; 7
    203c:	80 83       	st	Z, r24
	pxTopOfStack--;
    203e:	8b 81       	ldd	r24, Y+3	; 0x03
    2040:	9c 81       	ldd	r25, Y+4	; 0x04
    2042:	01 97       	sbiw	r24, 0x01	; 1
    2044:	9c 83       	std	Y+4, r25	; 0x04
    2046:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2048:	eb 81       	ldd	r30, Y+3	; 0x03
    204a:	fc 81       	ldd	r31, Y+4	; 0x04
    204c:	88 e0       	ldi	r24, 0x08	; 8
    204e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2050:	8b 81       	ldd	r24, Y+3	; 0x03
    2052:	9c 81       	ldd	r25, Y+4	; 0x04
    2054:	01 97       	sbiw	r24, 0x01	; 1
    2056:	9c 83       	std	Y+4, r25	; 0x04
    2058:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    205a:	eb 81       	ldd	r30, Y+3	; 0x03
    205c:	fc 81       	ldd	r31, Y+4	; 0x04
    205e:	89 e0       	ldi	r24, 0x09	; 9
    2060:	80 83       	st	Z, r24
	pxTopOfStack--;
    2062:	8b 81       	ldd	r24, Y+3	; 0x03
    2064:	9c 81       	ldd	r25, Y+4	; 0x04
    2066:	01 97       	sbiw	r24, 0x01	; 1
    2068:	9c 83       	std	Y+4, r25	; 0x04
    206a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    206c:	eb 81       	ldd	r30, Y+3	; 0x03
    206e:	fc 81       	ldd	r31, Y+4	; 0x04
    2070:	80 e1       	ldi	r24, 0x10	; 16
    2072:	80 83       	st	Z, r24
	pxTopOfStack--;
    2074:	8b 81       	ldd	r24, Y+3	; 0x03
    2076:	9c 81       	ldd	r25, Y+4	; 0x04
    2078:	01 97       	sbiw	r24, 0x01	; 1
    207a:	9c 83       	std	Y+4, r25	; 0x04
    207c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    207e:	eb 81       	ldd	r30, Y+3	; 0x03
    2080:	fc 81       	ldd	r31, Y+4	; 0x04
    2082:	81 e1       	ldi	r24, 0x11	; 17
    2084:	80 83       	st	Z, r24
	pxTopOfStack--;
    2086:	8b 81       	ldd	r24, Y+3	; 0x03
    2088:	9c 81       	ldd	r25, Y+4	; 0x04
    208a:	01 97       	sbiw	r24, 0x01	; 1
    208c:	9c 83       	std	Y+4, r25	; 0x04
    208e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2090:	eb 81       	ldd	r30, Y+3	; 0x03
    2092:	fc 81       	ldd	r31, Y+4	; 0x04
    2094:	82 e1       	ldi	r24, 0x12	; 18
    2096:	80 83       	st	Z, r24
	pxTopOfStack--;
    2098:	8b 81       	ldd	r24, Y+3	; 0x03
    209a:	9c 81       	ldd	r25, Y+4	; 0x04
    209c:	01 97       	sbiw	r24, 0x01	; 1
    209e:	9c 83       	std	Y+4, r25	; 0x04
    20a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    20a2:	eb 81       	ldd	r30, Y+3	; 0x03
    20a4:	fc 81       	ldd	r31, Y+4	; 0x04
    20a6:	83 e1       	ldi	r24, 0x13	; 19
    20a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    20aa:	8b 81       	ldd	r24, Y+3	; 0x03
    20ac:	9c 81       	ldd	r25, Y+4	; 0x04
    20ae:	01 97       	sbiw	r24, 0x01	; 1
    20b0:	9c 83       	std	Y+4, r25	; 0x04
    20b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    20b4:	eb 81       	ldd	r30, Y+3	; 0x03
    20b6:	fc 81       	ldd	r31, Y+4	; 0x04
    20b8:	84 e1       	ldi	r24, 0x14	; 20
    20ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    20bc:	8b 81       	ldd	r24, Y+3	; 0x03
    20be:	9c 81       	ldd	r25, Y+4	; 0x04
    20c0:	01 97       	sbiw	r24, 0x01	; 1
    20c2:	9c 83       	std	Y+4, r25	; 0x04
    20c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    20c6:	eb 81       	ldd	r30, Y+3	; 0x03
    20c8:	fc 81       	ldd	r31, Y+4	; 0x04
    20ca:	85 e1       	ldi	r24, 0x15	; 21
    20cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    20ce:	8b 81       	ldd	r24, Y+3	; 0x03
    20d0:	9c 81       	ldd	r25, Y+4	; 0x04
    20d2:	01 97       	sbiw	r24, 0x01	; 1
    20d4:	9c 83       	std	Y+4, r25	; 0x04
    20d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    20d8:	eb 81       	ldd	r30, Y+3	; 0x03
    20da:	fc 81       	ldd	r31, Y+4	; 0x04
    20dc:	86 e1       	ldi	r24, 0x16	; 22
    20de:	80 83       	st	Z, r24
	pxTopOfStack--;
    20e0:	8b 81       	ldd	r24, Y+3	; 0x03
    20e2:	9c 81       	ldd	r25, Y+4	; 0x04
    20e4:	01 97       	sbiw	r24, 0x01	; 1
    20e6:	9c 83       	std	Y+4, r25	; 0x04
    20e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    20ea:	eb 81       	ldd	r30, Y+3	; 0x03
    20ec:	fc 81       	ldd	r31, Y+4	; 0x04
    20ee:	87 e1       	ldi	r24, 0x17	; 23
    20f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    20f2:	8b 81       	ldd	r24, Y+3	; 0x03
    20f4:	9c 81       	ldd	r25, Y+4	; 0x04
    20f6:	01 97       	sbiw	r24, 0x01	; 1
    20f8:	9c 83       	std	Y+4, r25	; 0x04
    20fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    20fc:	eb 81       	ldd	r30, Y+3	; 0x03
    20fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2100:	88 e1       	ldi	r24, 0x18	; 24
    2102:	80 83       	st	Z, r24
	pxTopOfStack--;
    2104:	8b 81       	ldd	r24, Y+3	; 0x03
    2106:	9c 81       	ldd	r25, Y+4	; 0x04
    2108:	01 97       	sbiw	r24, 0x01	; 1
    210a:	9c 83       	std	Y+4, r25	; 0x04
    210c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    210e:	eb 81       	ldd	r30, Y+3	; 0x03
    2110:	fc 81       	ldd	r31, Y+4	; 0x04
    2112:	89 e1       	ldi	r24, 0x19	; 25
    2114:	80 83       	st	Z, r24
	pxTopOfStack--;
    2116:	8b 81       	ldd	r24, Y+3	; 0x03
    2118:	9c 81       	ldd	r25, Y+4	; 0x04
    211a:	01 97       	sbiw	r24, 0x01	; 1
    211c:	9c 83       	std	Y+4, r25	; 0x04
    211e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2120:	eb 81       	ldd	r30, Y+3	; 0x03
    2122:	fc 81       	ldd	r31, Y+4	; 0x04
    2124:	80 e2       	ldi	r24, 0x20	; 32
    2126:	80 83       	st	Z, r24
	pxTopOfStack--;
    2128:	8b 81       	ldd	r24, Y+3	; 0x03
    212a:	9c 81       	ldd	r25, Y+4	; 0x04
    212c:	01 97       	sbiw	r24, 0x01	; 1
    212e:	9c 83       	std	Y+4, r25	; 0x04
    2130:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    2132:	eb 81       	ldd	r30, Y+3	; 0x03
    2134:	fc 81       	ldd	r31, Y+4	; 0x04
    2136:	81 e2       	ldi	r24, 0x21	; 33
    2138:	80 83       	st	Z, r24
	pxTopOfStack--;
    213a:	8b 81       	ldd	r24, Y+3	; 0x03
    213c:	9c 81       	ldd	r25, Y+4	; 0x04
    213e:	01 97       	sbiw	r24, 0x01	; 1
    2140:	9c 83       	std	Y+4, r25	; 0x04
    2142:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2144:	eb 81       	ldd	r30, Y+3	; 0x03
    2146:	fc 81       	ldd	r31, Y+4	; 0x04
    2148:	82 e2       	ldi	r24, 0x22	; 34
    214a:	80 83       	st	Z, r24
	pxTopOfStack--;
    214c:	8b 81       	ldd	r24, Y+3	; 0x03
    214e:	9c 81       	ldd	r25, Y+4	; 0x04
    2150:	01 97       	sbiw	r24, 0x01	; 1
    2152:	9c 83       	std	Y+4, r25	; 0x04
    2154:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2156:	eb 81       	ldd	r30, Y+3	; 0x03
    2158:	fc 81       	ldd	r31, Y+4	; 0x04
    215a:	83 e2       	ldi	r24, 0x23	; 35
    215c:	80 83       	st	Z, r24
	pxTopOfStack--;
    215e:	8b 81       	ldd	r24, Y+3	; 0x03
    2160:	9c 81       	ldd	r25, Y+4	; 0x04
    2162:	01 97       	sbiw	r24, 0x01	; 1
    2164:	9c 83       	std	Y+4, r25	; 0x04
    2166:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    2168:	8f 81       	ldd	r24, Y+7	; 0x07
    216a:	98 85       	ldd	r25, Y+8	; 0x08
    216c:	9a 83       	std	Y+2, r25	; 0x02
    216e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2170:	89 81       	ldd	r24, Y+1	; 0x01
    2172:	eb 81       	ldd	r30, Y+3	; 0x03
    2174:	fc 81       	ldd	r31, Y+4	; 0x04
    2176:	80 83       	st	Z, r24
	pxTopOfStack--;
    2178:	8b 81       	ldd	r24, Y+3	; 0x03
    217a:	9c 81       	ldd	r25, Y+4	; 0x04
    217c:	01 97       	sbiw	r24, 0x01	; 1
    217e:	9c 83       	std	Y+4, r25	; 0x04
    2180:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	9a 81       	ldd	r25, Y+2	; 0x02
    2186:	89 2f       	mov	r24, r25
    2188:	99 27       	eor	r25, r25
    218a:	9a 83       	std	Y+2, r25	; 0x02
    218c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    218e:	89 81       	ldd	r24, Y+1	; 0x01
    2190:	eb 81       	ldd	r30, Y+3	; 0x03
    2192:	fc 81       	ldd	r31, Y+4	; 0x04
    2194:	80 83       	st	Z, r24
	pxTopOfStack--;
    2196:	8b 81       	ldd	r24, Y+3	; 0x03
    2198:	9c 81       	ldd	r25, Y+4	; 0x04
    219a:	01 97       	sbiw	r24, 0x01	; 1
    219c:	9c 83       	std	Y+4, r25	; 0x04
    219e:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    21a0:	eb 81       	ldd	r30, Y+3	; 0x03
    21a2:	fc 81       	ldd	r31, Y+4	; 0x04
    21a4:	86 e2       	ldi	r24, 0x26	; 38
    21a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    21a8:	8b 81       	ldd	r24, Y+3	; 0x03
    21aa:	9c 81       	ldd	r25, Y+4	; 0x04
    21ac:	01 97       	sbiw	r24, 0x01	; 1
    21ae:	9c 83       	std	Y+4, r25	; 0x04
    21b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    21b2:	eb 81       	ldd	r30, Y+3	; 0x03
    21b4:	fc 81       	ldd	r31, Y+4	; 0x04
    21b6:	87 e2       	ldi	r24, 0x27	; 39
    21b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    21ba:	8b 81       	ldd	r24, Y+3	; 0x03
    21bc:	9c 81       	ldd	r25, Y+4	; 0x04
    21be:	01 97       	sbiw	r24, 0x01	; 1
    21c0:	9c 83       	std	Y+4, r25	; 0x04
    21c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    21c4:	eb 81       	ldd	r30, Y+3	; 0x03
    21c6:	fc 81       	ldd	r31, Y+4	; 0x04
    21c8:	88 e2       	ldi	r24, 0x28	; 40
    21ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    21cc:	8b 81       	ldd	r24, Y+3	; 0x03
    21ce:	9c 81       	ldd	r25, Y+4	; 0x04
    21d0:	01 97       	sbiw	r24, 0x01	; 1
    21d2:	9c 83       	std	Y+4, r25	; 0x04
    21d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    21d6:	eb 81       	ldd	r30, Y+3	; 0x03
    21d8:	fc 81       	ldd	r31, Y+4	; 0x04
    21da:	89 e2       	ldi	r24, 0x29	; 41
    21dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    21de:	8b 81       	ldd	r24, Y+3	; 0x03
    21e0:	9c 81       	ldd	r25, Y+4	; 0x04
    21e2:	01 97       	sbiw	r24, 0x01	; 1
    21e4:	9c 83       	std	Y+4, r25	; 0x04
    21e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    21e8:	eb 81       	ldd	r30, Y+3	; 0x03
    21ea:	fc 81       	ldd	r31, Y+4	; 0x04
    21ec:	80 e3       	ldi	r24, 0x30	; 48
    21ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    21f0:	8b 81       	ldd	r24, Y+3	; 0x03
    21f2:	9c 81       	ldd	r25, Y+4	; 0x04
    21f4:	01 97       	sbiw	r24, 0x01	; 1
    21f6:	9c 83       	std	Y+4, r25	; 0x04
    21f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    21fa:	eb 81       	ldd	r30, Y+3	; 0x03
    21fc:	fc 81       	ldd	r31, Y+4	; 0x04
    21fe:	81 e3       	ldi	r24, 0x31	; 49
    2200:	80 83       	st	Z, r24
	pxTopOfStack--;
    2202:	8b 81       	ldd	r24, Y+3	; 0x03
    2204:	9c 81       	ldd	r25, Y+4	; 0x04
    2206:	01 97       	sbiw	r24, 0x01	; 1
    2208:	9c 83       	std	Y+4, r25	; 0x04
    220a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    220c:	8b 81       	ldd	r24, Y+3	; 0x03
    220e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2210:	28 96       	adiw	r28, 0x08	; 8
    2212:	0f b6       	in	r0, 0x3f	; 63
    2214:	f8 94       	cli
    2216:	de bf       	out	0x3e, r29	; 62
    2218:	0f be       	out	0x3f, r0	; 63
    221a:	cd bf       	out	0x3d, r28	; 61
    221c:	cf 91       	pop	r28
    221e:	df 91       	pop	r29
    2220:	08 95       	ret

00002222 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    2222:	df 93       	push	r29
    2224:	cf 93       	push	r28
    2226:	cd b7       	in	r28, 0x3d	; 61
    2228:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    222a:	0e 94 03 12 	call	0x2406	; 0x2406 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    222e:	a0 91 9f 03 	lds	r26, 0x039F
    2232:	b0 91 a0 03 	lds	r27, 0x03A0
    2236:	cd 91       	ld	r28, X+
    2238:	cd bf       	out	0x3d, r28	; 61
    223a:	dd 91       	ld	r29, X+
    223c:	de bf       	out	0x3e, r29	; 62
    223e:	ff 91       	pop	r31
    2240:	ef 91       	pop	r30
    2242:	df 91       	pop	r29
    2244:	cf 91       	pop	r28
    2246:	bf 91       	pop	r27
    2248:	af 91       	pop	r26
    224a:	9f 91       	pop	r25
    224c:	8f 91       	pop	r24
    224e:	7f 91       	pop	r23
    2250:	6f 91       	pop	r22
    2252:	5f 91       	pop	r21
    2254:	4f 91       	pop	r20
    2256:	3f 91       	pop	r19
    2258:	2f 91       	pop	r18
    225a:	1f 91       	pop	r17
    225c:	0f 91       	pop	r16
    225e:	ff 90       	pop	r15
    2260:	ef 90       	pop	r14
    2262:	df 90       	pop	r13
    2264:	cf 90       	pop	r12
    2266:	bf 90       	pop	r11
    2268:	af 90       	pop	r10
    226a:	9f 90       	pop	r9
    226c:	8f 90       	pop	r8
    226e:	7f 90       	pop	r7
    2270:	6f 90       	pop	r6
    2272:	5f 90       	pop	r5
    2274:	4f 90       	pop	r4
    2276:	3f 90       	pop	r3
    2278:	2f 90       	pop	r2
    227a:	1f 90       	pop	r1
    227c:	0f 90       	pop	r0
    227e:	0f be       	out	0x3f, r0	; 63
    2280:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2282:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2284:	81 e0       	ldi	r24, 0x01	; 1
}
    2286:	cf 91       	pop	r28
    2288:	df 91       	pop	r29
    228a:	08 95       	ret

0000228c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    228c:	df 93       	push	r29
    228e:	cf 93       	push	r28
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2294:	cf 91       	pop	r28
    2296:	df 91       	pop	r29
    2298:	08 95       	ret

0000229a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    229a:	0f 92       	push	r0
    229c:	0f b6       	in	r0, 0x3f	; 63
    229e:	f8 94       	cli
    22a0:	0f 92       	push	r0
    22a2:	1f 92       	push	r1
    22a4:	11 24       	eor	r1, r1
    22a6:	2f 92       	push	r2
    22a8:	3f 92       	push	r3
    22aa:	4f 92       	push	r4
    22ac:	5f 92       	push	r5
    22ae:	6f 92       	push	r6
    22b0:	7f 92       	push	r7
    22b2:	8f 92       	push	r8
    22b4:	9f 92       	push	r9
    22b6:	af 92       	push	r10
    22b8:	bf 92       	push	r11
    22ba:	cf 92       	push	r12
    22bc:	df 92       	push	r13
    22be:	ef 92       	push	r14
    22c0:	ff 92       	push	r15
    22c2:	0f 93       	push	r16
    22c4:	1f 93       	push	r17
    22c6:	2f 93       	push	r18
    22c8:	3f 93       	push	r19
    22ca:	4f 93       	push	r20
    22cc:	5f 93       	push	r21
    22ce:	6f 93       	push	r22
    22d0:	7f 93       	push	r23
    22d2:	8f 93       	push	r24
    22d4:	9f 93       	push	r25
    22d6:	af 93       	push	r26
    22d8:	bf 93       	push	r27
    22da:	cf 93       	push	r28
    22dc:	df 93       	push	r29
    22de:	ef 93       	push	r30
    22e0:	ff 93       	push	r31
    22e2:	a0 91 9f 03 	lds	r26, 0x039F
    22e6:	b0 91 a0 03 	lds	r27, 0x03A0
    22ea:	0d b6       	in	r0, 0x3d	; 61
    22ec:	0d 92       	st	X+, r0
    22ee:	0e b6       	in	r0, 0x3e	; 62
    22f0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    22f2:	0e 94 4d 22 	call	0x449a	; 0x449a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    22f6:	a0 91 9f 03 	lds	r26, 0x039F
    22fa:	b0 91 a0 03 	lds	r27, 0x03A0
    22fe:	cd 91       	ld	r28, X+
    2300:	cd bf       	out	0x3d, r28	; 61
    2302:	dd 91       	ld	r29, X+
    2304:	de bf       	out	0x3e, r29	; 62
    2306:	ff 91       	pop	r31
    2308:	ef 91       	pop	r30
    230a:	df 91       	pop	r29
    230c:	cf 91       	pop	r28
    230e:	bf 91       	pop	r27
    2310:	af 91       	pop	r26
    2312:	9f 91       	pop	r25
    2314:	8f 91       	pop	r24
    2316:	7f 91       	pop	r23
    2318:	6f 91       	pop	r22
    231a:	5f 91       	pop	r21
    231c:	4f 91       	pop	r20
    231e:	3f 91       	pop	r19
    2320:	2f 91       	pop	r18
    2322:	1f 91       	pop	r17
    2324:	0f 91       	pop	r16
    2326:	ff 90       	pop	r15
    2328:	ef 90       	pop	r14
    232a:	df 90       	pop	r13
    232c:	cf 90       	pop	r12
    232e:	bf 90       	pop	r11
    2330:	af 90       	pop	r10
    2332:	9f 90       	pop	r9
    2334:	8f 90       	pop	r8
    2336:	7f 90       	pop	r7
    2338:	6f 90       	pop	r6
    233a:	5f 90       	pop	r5
    233c:	4f 90       	pop	r4
    233e:	3f 90       	pop	r3
    2340:	2f 90       	pop	r2
    2342:	1f 90       	pop	r1
    2344:	0f 90       	pop	r0
    2346:	0f be       	out	0x3f, r0	; 63
    2348:	0f 90       	pop	r0

	asm volatile ( "ret" );
    234a:	08 95       	ret

0000234c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    234c:	0f 92       	push	r0
    234e:	0f b6       	in	r0, 0x3f	; 63
    2350:	f8 94       	cli
    2352:	0f 92       	push	r0
    2354:	1f 92       	push	r1
    2356:	11 24       	eor	r1, r1
    2358:	2f 92       	push	r2
    235a:	3f 92       	push	r3
    235c:	4f 92       	push	r4
    235e:	5f 92       	push	r5
    2360:	6f 92       	push	r6
    2362:	7f 92       	push	r7
    2364:	8f 92       	push	r8
    2366:	9f 92       	push	r9
    2368:	af 92       	push	r10
    236a:	bf 92       	push	r11
    236c:	cf 92       	push	r12
    236e:	df 92       	push	r13
    2370:	ef 92       	push	r14
    2372:	ff 92       	push	r15
    2374:	0f 93       	push	r16
    2376:	1f 93       	push	r17
    2378:	2f 93       	push	r18
    237a:	3f 93       	push	r19
    237c:	4f 93       	push	r20
    237e:	5f 93       	push	r21
    2380:	6f 93       	push	r22
    2382:	7f 93       	push	r23
    2384:	8f 93       	push	r24
    2386:	9f 93       	push	r25
    2388:	af 93       	push	r26
    238a:	bf 93       	push	r27
    238c:	cf 93       	push	r28
    238e:	df 93       	push	r29
    2390:	ef 93       	push	r30
    2392:	ff 93       	push	r31
    2394:	a0 91 9f 03 	lds	r26, 0x039F
    2398:	b0 91 a0 03 	lds	r27, 0x03A0
    239c:	0d b6       	in	r0, 0x3d	; 61
    239e:	0d 92       	st	X+, r0
    23a0:	0e b6       	in	r0, 0x3e	; 62
    23a2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    23a4:	0e 94 68 21 	call	0x42d0	; 0x42d0 <xTaskIncrementTick>
    23a8:	88 23       	and	r24, r24
    23aa:	11 f0       	breq	.+4      	; 0x23b0 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    23ac:	0e 94 4d 22 	call	0x449a	; 0x449a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    23b0:	a0 91 9f 03 	lds	r26, 0x039F
    23b4:	b0 91 a0 03 	lds	r27, 0x03A0
    23b8:	cd 91       	ld	r28, X+
    23ba:	cd bf       	out	0x3d, r28	; 61
    23bc:	dd 91       	ld	r29, X+
    23be:	de bf       	out	0x3e, r29	; 62
    23c0:	ff 91       	pop	r31
    23c2:	ef 91       	pop	r30
    23c4:	df 91       	pop	r29
    23c6:	cf 91       	pop	r28
    23c8:	bf 91       	pop	r27
    23ca:	af 91       	pop	r26
    23cc:	9f 91       	pop	r25
    23ce:	8f 91       	pop	r24
    23d0:	7f 91       	pop	r23
    23d2:	6f 91       	pop	r22
    23d4:	5f 91       	pop	r21
    23d6:	4f 91       	pop	r20
    23d8:	3f 91       	pop	r19
    23da:	2f 91       	pop	r18
    23dc:	1f 91       	pop	r17
    23de:	0f 91       	pop	r16
    23e0:	ff 90       	pop	r15
    23e2:	ef 90       	pop	r14
    23e4:	df 90       	pop	r13
    23e6:	cf 90       	pop	r12
    23e8:	bf 90       	pop	r11
    23ea:	af 90       	pop	r10
    23ec:	9f 90       	pop	r9
    23ee:	8f 90       	pop	r8
    23f0:	7f 90       	pop	r7
    23f2:	6f 90       	pop	r6
    23f4:	5f 90       	pop	r5
    23f6:	4f 90       	pop	r4
    23f8:	3f 90       	pop	r3
    23fa:	2f 90       	pop	r2
    23fc:	1f 90       	pop	r1
    23fe:	0f 90       	pop	r0
    2400:	0f be       	out	0x3f, r0	; 63
    2402:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2404:	08 95       	ret

00002406 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2406:	df 93       	push	r29
    2408:	cf 93       	push	r28
    240a:	00 d0       	rcall	.+0      	; 0x240c <prvSetupTimerInterrupt+0x6>
    240c:	00 d0       	rcall	.+0      	; 0x240e <prvSetupTimerInterrupt+0x8>
    240e:	00 d0       	rcall	.+0      	; 0x2410 <prvSetupTimerInterrupt+0xa>
    2410:	cd b7       	in	r28, 0x3d	; 61
    2412:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2414:	80 e2       	ldi	r24, 0x20	; 32
    2416:	93 e0       	ldi	r25, 0x03	; 3
    2418:	a0 e0       	ldi	r26, 0x00	; 0
    241a:	b0 e0       	ldi	r27, 0x00	; 0
    241c:	8b 83       	std	Y+3, r24	; 0x03
    241e:	9c 83       	std	Y+4, r25	; 0x04
    2420:	ad 83       	std	Y+5, r26	; 0x05
    2422:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2424:	8b 81       	ldd	r24, Y+3	; 0x03
    2426:	9c 81       	ldd	r25, Y+4	; 0x04
    2428:	ad 81       	ldd	r26, Y+5	; 0x05
    242a:	be 81       	ldd	r27, Y+6	; 0x06
    242c:	68 94       	set
    242e:	15 f8       	bld	r1, 5
    2430:	b6 95       	lsr	r27
    2432:	a7 95       	ror	r26
    2434:	97 95       	ror	r25
    2436:	87 95       	ror	r24
    2438:	16 94       	lsr	r1
    243a:	d1 f7       	brne	.-12     	; 0x2430 <prvSetupTimerInterrupt+0x2a>
    243c:	8b 83       	std	Y+3, r24	; 0x03
    243e:	9c 83       	std	Y+4, r25	; 0x04
    2440:	ad 83       	std	Y+5, r26	; 0x05
    2442:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    2444:	8b 81       	ldd	r24, Y+3	; 0x03
    2446:	9c 81       	ldd	r25, Y+4	; 0x04
    2448:	ad 81       	ldd	r26, Y+5	; 0x05
    244a:	be 81       	ldd	r27, Y+6	; 0x06
    244c:	01 97       	sbiw	r24, 0x01	; 1
    244e:	a1 09       	sbc	r26, r1
    2450:	b1 09       	sbc	r27, r1
    2452:	8b 83       	std	Y+3, r24	; 0x03
    2454:	9c 83       	std	Y+4, r25	; 0x04
    2456:	ad 83       	std	Y+5, r26	; 0x05
    2458:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    245a:	8b 81       	ldd	r24, Y+3	; 0x03
    245c:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    245e:	8b 81       	ldd	r24, Y+3	; 0x03
    2460:	9c 81       	ldd	r25, Y+4	; 0x04
    2462:	ad 81       	ldd	r26, Y+5	; 0x05
    2464:	be 81       	ldd	r27, Y+6	; 0x06
    2466:	89 2f       	mov	r24, r25
    2468:	9a 2f       	mov	r25, r26
    246a:	ab 2f       	mov	r26, r27
    246c:	bb 27       	eor	r27, r27
    246e:	8b 83       	std	Y+3, r24	; 0x03
    2470:	9c 83       	std	Y+4, r25	; 0x04
    2472:	ad 83       	std	Y+5, r26	; 0x05
    2474:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    2476:	8b 81       	ldd	r24, Y+3	; 0x03
    2478:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    247a:	eb e4       	ldi	r30, 0x4B	; 75
    247c:	f0 e0       	ldi	r31, 0x00	; 0
    247e:	8a 81       	ldd	r24, Y+2	; 0x02
    2480:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2482:	ea e4       	ldi	r30, 0x4A	; 74
    2484:	f0 e0       	ldi	r31, 0x00	; 0
    2486:	89 81       	ldd	r24, Y+1	; 0x01
    2488:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    248a:	8b e0       	ldi	r24, 0x0B	; 11
    248c:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    248e:	ee e4       	ldi	r30, 0x4E	; 78
    2490:	f0 e0       	ldi	r31, 0x00	; 0
    2492:	89 81       	ldd	r24, Y+1	; 0x01
    2494:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2496:	e9 e5       	ldi	r30, 0x59	; 89
    2498:	f0 e0       	ldi	r31, 0x00	; 0
    249a:	80 81       	ld	r24, Z
    249c:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    249e:	89 81       	ldd	r24, Y+1	; 0x01
    24a0:	80 61       	ori	r24, 0x10	; 16
    24a2:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    24a4:	e9 e5       	ldi	r30, 0x59	; 89
    24a6:	f0 e0       	ldi	r31, 0x00	; 0
    24a8:	89 81       	ldd	r24, Y+1	; 0x01
    24aa:	80 83       	st	Z, r24
}
    24ac:	26 96       	adiw	r28, 0x06	; 6
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	de bf       	out	0x3e, r29	; 62
    24b4:	0f be       	out	0x3f, r0	; 63
    24b6:	cd bf       	out	0x3d, r28	; 61
    24b8:	cf 91       	pop	r28
    24ba:	df 91       	pop	r29
    24bc:	08 95       	ret

000024be <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    24be:	0e 94 a6 11 	call	0x234c	; 0x234c <vPortYieldFromTick>
		asm volatile ( "reti" );
    24c2:	18 95       	reti

000024c4 <main>:
#include "task.h"
void task1(void *pv);
void task2(void *pv);

int main(void)
{
    24c4:	ef 92       	push	r14
    24c6:	ff 92       	push	r15
    24c8:	0f 93       	push	r16
    24ca:	df 93       	push	r29
    24cc:	cf 93       	push	r28
    24ce:	00 d0       	rcall	.+0      	; 0x24d0 <main+0xc>
    24d0:	cd b7       	in	r28, 0x3d	; 61
    24d2:	de b7       	in	r29, 0x3e	; 62
	char x = 6;
    24d4:	86 e0       	ldi	r24, 0x06	; 6
    24d6:	8a 83       	std	Y+2, r24	; 0x02
	char y = 7;
    24d8:	87 e0       	ldi	r24, 0x07	; 7
    24da:	89 83       	std	Y+1, r24	; 0x01
	/*create the tasks */
	xTaskCreate(task2, "B", 100, 7, 1, NULL);
    24dc:	84 e3       	ldi	r24, 0x34	; 52
    24de:	93 e1       	ldi	r25, 0x13	; 19
    24e0:	20 e6       	ldi	r18, 0x60	; 96
    24e2:	30 e0       	ldi	r19, 0x00	; 0
    24e4:	b9 01       	movw	r22, r18
    24e6:	44 e6       	ldi	r20, 0x64	; 100
    24e8:	50 e0       	ldi	r21, 0x00	; 0
    24ea:	27 e0       	ldi	r18, 0x07	; 7
    24ec:	30 e0       	ldi	r19, 0x00	; 0
    24ee:	01 e0       	ldi	r16, 0x01	; 1
    24f0:	ee 24       	eor	r14, r14
    24f2:	ff 24       	eor	r15, r15
    24f4:	0e 94 ee 1a 	call	0x35dc	; 0x35dc <xTaskCreate>
	xTaskCreate(task1, "A", 100, 6, 1,NULL);
    24f8:	8d e8       	ldi	r24, 0x8D	; 141
    24fa:	92 e1       	ldi	r25, 0x12	; 18
    24fc:	22 e6       	ldi	r18, 0x62	; 98
    24fe:	30 e0       	ldi	r19, 0x00	; 0
    2500:	b9 01       	movw	r22, r18
    2502:	44 e6       	ldi	r20, 0x64	; 100
    2504:	50 e0       	ldi	r21, 0x00	; 0
    2506:	26 e0       	ldi	r18, 0x06	; 6
    2508:	30 e0       	ldi	r19, 0x00	; 0
    250a:	01 e0       	ldi	r16, 0x01	; 1
    250c:	ee 24       	eor	r14, r14
    250e:	ff 24       	eor	r15, r15
    2510:	0e 94 ee 1a 	call	0x35dc	; 0x35dc <xTaskCreate>
	/*start os*/
	vTaskStartScheduler();
    2514:	0e 94 2e 20 	call	0x405c	; 0x405c <vTaskStartScheduler>
    2518:	ff cf       	rjmp	.-2      	; 0x2518 <main+0x54>

0000251a <task1>:
		
	}
}

void task1(void *pv)
{
    251a:	df 93       	push	r29
    251c:	cf 93       	push	r28
    251e:	cd b7       	in	r28, 0x3d	; 61
    2520:	de b7       	in	r29, 0x3e	; 62
    2522:	60 97       	sbiw	r28, 0x10	; 16
    2524:	0f b6       	in	r0, 0x3f	; 63
    2526:	f8 94       	cli
    2528:	de bf       	out	0x3e, r29	; 62
    252a:	0f be       	out	0x3f, r0	; 63
    252c:	cd bf       	out	0x3d, r28	; 61
    252e:	98 8b       	std	Y+16, r25	; 0x10
    2530:	8f 87       	std	Y+15, r24	; 0x0f
	/*some initializations*/
	DDRD|=(1<<*((char*)pv));
    2532:	a1 e3       	ldi	r26, 0x31	; 49
    2534:	b0 e0       	ldi	r27, 0x00	; 0
    2536:	e1 e3       	ldi	r30, 0x31	; 49
    2538:	f0 e0       	ldi	r31, 0x00	; 0
    253a:	80 81       	ld	r24, Z
    253c:	48 2f       	mov	r20, r24
    253e:	ef 85       	ldd	r30, Y+15	; 0x0f
    2540:	f8 89       	ldd	r31, Y+16	; 0x10
    2542:	80 81       	ld	r24, Z
    2544:	28 2f       	mov	r18, r24
    2546:	30 e0       	ldi	r19, 0x00	; 0
    2548:	81 e0       	ldi	r24, 0x01	; 1
    254a:	90 e0       	ldi	r25, 0x00	; 0
    254c:	02 c0       	rjmp	.+4      	; 0x2552 <task1+0x38>
    254e:	88 0f       	add	r24, r24
    2550:	99 1f       	adc	r25, r25
    2552:	2a 95       	dec	r18
    2554:	e2 f7       	brpl	.-8      	; 0x254e <task1+0x34>
    2556:	84 2b       	or	r24, r20
    2558:	8c 93       	st	X, r24
	while(1)
	{
		PORTD ^= (1<<*((char*)pv));
    255a:	a2 e3       	ldi	r26, 0x32	; 50
    255c:	b0 e0       	ldi	r27, 0x00	; 0
    255e:	e2 e3       	ldi	r30, 0x32	; 50
    2560:	f0 e0       	ldi	r31, 0x00	; 0
    2562:	80 81       	ld	r24, Z
    2564:	48 2f       	mov	r20, r24
    2566:	ef 85       	ldd	r30, Y+15	; 0x0f
    2568:	f8 89       	ldd	r31, Y+16	; 0x10
    256a:	80 81       	ld	r24, Z
    256c:	28 2f       	mov	r18, r24
    256e:	30 e0       	ldi	r19, 0x00	; 0
    2570:	81 e0       	ldi	r24, 0x01	; 1
    2572:	90 e0       	ldi	r25, 0x00	; 0
    2574:	02 c0       	rjmp	.+4      	; 0x257a <task1+0x60>
    2576:	88 0f       	add	r24, r24
    2578:	99 1f       	adc	r25, r25
    257a:	2a 95       	dec	r18
    257c:	e2 f7       	brpl	.-8      	; 0x2576 <task1+0x5c>
    257e:	84 27       	eor	r24, r20
    2580:	8c 93       	st	X, r24
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	aa ef       	ldi	r26, 0xFA	; 250
    2588:	b3 e4       	ldi	r27, 0x43	; 67
    258a:	8b 87       	std	Y+11, r24	; 0x0b
    258c:	9c 87       	std	Y+12, r25	; 0x0c
    258e:	ad 87       	std	Y+13, r26	; 0x0d
    2590:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2592:	6b 85       	ldd	r22, Y+11	; 0x0b
    2594:	7c 85       	ldd	r23, Y+12	; 0x0c
    2596:	8d 85       	ldd	r24, Y+13	; 0x0d
    2598:	9e 85       	ldd	r25, Y+14	; 0x0e
    259a:	20 e0       	ldi	r18, 0x00	; 0
    259c:	30 e0       	ldi	r19, 0x00	; 0
    259e:	4a ef       	ldi	r20, 0xFA	; 250
    25a0:	54 e4       	ldi	r21, 0x44	; 68
    25a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25a6:	dc 01       	movw	r26, r24
    25a8:	cb 01       	movw	r24, r22
    25aa:	8f 83       	std	Y+7, r24	; 0x07
    25ac:	98 87       	std	Y+8, r25	; 0x08
    25ae:	a9 87       	std	Y+9, r26	; 0x09
    25b0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    25b2:	6f 81       	ldd	r22, Y+7	; 0x07
    25b4:	78 85       	ldd	r23, Y+8	; 0x08
    25b6:	89 85       	ldd	r24, Y+9	; 0x09
    25b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    25ba:	20 e0       	ldi	r18, 0x00	; 0
    25bc:	30 e0       	ldi	r19, 0x00	; 0
    25be:	40 e8       	ldi	r20, 0x80	; 128
    25c0:	5f e3       	ldi	r21, 0x3F	; 63
    25c2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    25c6:	88 23       	and	r24, r24
    25c8:	2c f4       	brge	.+10     	; 0x25d4 <task1+0xba>
		__ticks = 1;
    25ca:	81 e0       	ldi	r24, 0x01	; 1
    25cc:	90 e0       	ldi	r25, 0x00	; 0
    25ce:	9e 83       	std	Y+6, r25	; 0x06
    25d0:	8d 83       	std	Y+5, r24	; 0x05
    25d2:	3f c0       	rjmp	.+126    	; 0x2652 <task1+0x138>
	else if (__tmp > 65535)
    25d4:	6f 81       	ldd	r22, Y+7	; 0x07
    25d6:	78 85       	ldd	r23, Y+8	; 0x08
    25d8:	89 85       	ldd	r24, Y+9	; 0x09
    25da:	9a 85       	ldd	r25, Y+10	; 0x0a
    25dc:	20 e0       	ldi	r18, 0x00	; 0
    25de:	3f ef       	ldi	r19, 0xFF	; 255
    25e0:	4f e7       	ldi	r20, 0x7F	; 127
    25e2:	57 e4       	ldi	r21, 0x47	; 71
    25e4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    25e8:	18 16       	cp	r1, r24
    25ea:	4c f5       	brge	.+82     	; 0x263e <task1+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25ec:	6b 85       	ldd	r22, Y+11	; 0x0b
    25ee:	7c 85       	ldd	r23, Y+12	; 0x0c
    25f0:	8d 85       	ldd	r24, Y+13	; 0x0d
    25f2:	9e 85       	ldd	r25, Y+14	; 0x0e
    25f4:	20 e0       	ldi	r18, 0x00	; 0
    25f6:	30 e0       	ldi	r19, 0x00	; 0
    25f8:	40 e2       	ldi	r20, 0x20	; 32
    25fa:	51 e4       	ldi	r21, 0x41	; 65
    25fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2600:	dc 01       	movw	r26, r24
    2602:	cb 01       	movw	r24, r22
    2604:	bc 01       	movw	r22, r24
    2606:	cd 01       	movw	r24, r26
    2608:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    260c:	dc 01       	movw	r26, r24
    260e:	cb 01       	movw	r24, r22
    2610:	9e 83       	std	Y+6, r25	; 0x06
    2612:	8d 83       	std	Y+5, r24	; 0x05
    2614:	0f c0       	rjmp	.+30     	; 0x2634 <task1+0x11a>
    2616:	88 ec       	ldi	r24, 0xC8	; 200
    2618:	90 e0       	ldi	r25, 0x00	; 0
    261a:	9c 83       	std	Y+4, r25	; 0x04
    261c:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    261e:	8b 81       	ldd	r24, Y+3	; 0x03
    2620:	9c 81       	ldd	r25, Y+4	; 0x04
    2622:	01 97       	sbiw	r24, 0x01	; 1
    2624:	f1 f7       	brne	.-4      	; 0x2622 <task1+0x108>
    2626:	9c 83       	std	Y+4, r25	; 0x04
    2628:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    262a:	8d 81       	ldd	r24, Y+5	; 0x05
    262c:	9e 81       	ldd	r25, Y+6	; 0x06
    262e:	01 97       	sbiw	r24, 0x01	; 1
    2630:	9e 83       	std	Y+6, r25	; 0x06
    2632:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2634:	8d 81       	ldd	r24, Y+5	; 0x05
    2636:	9e 81       	ldd	r25, Y+6	; 0x06
    2638:	00 97       	sbiw	r24, 0x00	; 0
    263a:	69 f7       	brne	.-38     	; 0x2616 <task1+0xfc>
    263c:	8e cf       	rjmp	.-228    	; 0x255a <task1+0x40>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    263e:	6f 81       	ldd	r22, Y+7	; 0x07
    2640:	78 85       	ldd	r23, Y+8	; 0x08
    2642:	89 85       	ldd	r24, Y+9	; 0x09
    2644:	9a 85       	ldd	r25, Y+10	; 0x0a
    2646:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    264a:	dc 01       	movw	r26, r24
    264c:	cb 01       	movw	r24, r22
    264e:	9e 83       	std	Y+6, r25	; 0x06
    2650:	8d 83       	std	Y+5, r24	; 0x05
    2652:	8d 81       	ldd	r24, Y+5	; 0x05
    2654:	9e 81       	ldd	r25, Y+6	; 0x06
    2656:	9a 83       	std	Y+2, r25	; 0x02
    2658:	89 83       	std	Y+1, r24	; 0x01
    265a:	89 81       	ldd	r24, Y+1	; 0x01
    265c:	9a 81       	ldd	r25, Y+2	; 0x02
    265e:	01 97       	sbiw	r24, 0x01	; 1
    2660:	f1 f7       	brne	.-4      	; 0x265e <task1+0x144>
    2662:	9a 83       	std	Y+2, r25	; 0x02
    2664:	89 83       	std	Y+1, r24	; 0x01
    2666:	79 cf       	rjmp	.-270    	; 0x255a <task1+0x40>

00002668 <task2>:
		_delay_ms(500);
	}
}

void task2(void *pv)
{
    2668:	df 93       	push	r29
    266a:	cf 93       	push	r28
    266c:	cd b7       	in	r28, 0x3d	; 61
    266e:	de b7       	in	r29, 0x3e	; 62
    2670:	60 97       	sbiw	r28, 0x10	; 16
    2672:	0f b6       	in	r0, 0x3f	; 63
    2674:	f8 94       	cli
    2676:	de bf       	out	0x3e, r29	; 62
    2678:	0f be       	out	0x3f, r0	; 63
    267a:	cd bf       	out	0x3d, r28	; 61
    267c:	98 8b       	std	Y+16, r25	; 0x10
    267e:	8f 87       	std	Y+15, r24	; 0x0f
	//vTaskDelay(4000);
	/*some initializations*/
	DDRD|=(1<<*((char*)pv));
    2680:	a1 e3       	ldi	r26, 0x31	; 49
    2682:	b0 e0       	ldi	r27, 0x00	; 0
    2684:	e1 e3       	ldi	r30, 0x31	; 49
    2686:	f0 e0       	ldi	r31, 0x00	; 0
    2688:	80 81       	ld	r24, Z
    268a:	48 2f       	mov	r20, r24
    268c:	ef 85       	ldd	r30, Y+15	; 0x0f
    268e:	f8 89       	ldd	r31, Y+16	; 0x10
    2690:	80 81       	ld	r24, Z
    2692:	28 2f       	mov	r18, r24
    2694:	30 e0       	ldi	r19, 0x00	; 0
    2696:	81 e0       	ldi	r24, 0x01	; 1
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	02 c0       	rjmp	.+4      	; 0x26a0 <task2+0x38>
    269c:	88 0f       	add	r24, r24
    269e:	99 1f       	adc	r25, r25
    26a0:	2a 95       	dec	r18
    26a2:	e2 f7       	brpl	.-8      	; 0x269c <task2+0x34>
    26a4:	84 2b       	or	r24, r20
    26a6:	8c 93       	st	X, r24
	while(1)
	{
		PORTD^=(1<<*((char*)pv));
    26a8:	a2 e3       	ldi	r26, 0x32	; 50
    26aa:	b0 e0       	ldi	r27, 0x00	; 0
    26ac:	e2 e3       	ldi	r30, 0x32	; 50
    26ae:	f0 e0       	ldi	r31, 0x00	; 0
    26b0:	80 81       	ld	r24, Z
    26b2:	48 2f       	mov	r20, r24
    26b4:	ef 85       	ldd	r30, Y+15	; 0x0f
    26b6:	f8 89       	ldd	r31, Y+16	; 0x10
    26b8:	80 81       	ld	r24, Z
    26ba:	28 2f       	mov	r18, r24
    26bc:	30 e0       	ldi	r19, 0x00	; 0
    26be:	81 e0       	ldi	r24, 0x01	; 1
    26c0:	90 e0       	ldi	r25, 0x00	; 0
    26c2:	02 c0       	rjmp	.+4      	; 0x26c8 <task2+0x60>
    26c4:	88 0f       	add	r24, r24
    26c6:	99 1f       	adc	r25, r25
    26c8:	2a 95       	dec	r18
    26ca:	e2 f7       	brpl	.-8      	; 0x26c4 <task2+0x5c>
    26cc:	84 27       	eor	r24, r20
    26ce:	8c 93       	st	X, r24
    26d0:	80 e0       	ldi	r24, 0x00	; 0
    26d2:	90 e0       	ldi	r25, 0x00	; 0
    26d4:	aa ef       	ldi	r26, 0xFA	; 250
    26d6:	b3 e4       	ldi	r27, 0x43	; 67
    26d8:	8b 87       	std	Y+11, r24	; 0x0b
    26da:	9c 87       	std	Y+12, r25	; 0x0c
    26dc:	ad 87       	std	Y+13, r26	; 0x0d
    26de:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    26e0:	6b 85       	ldd	r22, Y+11	; 0x0b
    26e2:	7c 85       	ldd	r23, Y+12	; 0x0c
    26e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    26e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    26e8:	20 e0       	ldi	r18, 0x00	; 0
    26ea:	30 e0       	ldi	r19, 0x00	; 0
    26ec:	4a ef       	ldi	r20, 0xFA	; 250
    26ee:	54 e4       	ldi	r21, 0x44	; 68
    26f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26f4:	dc 01       	movw	r26, r24
    26f6:	cb 01       	movw	r24, r22
    26f8:	8f 83       	std	Y+7, r24	; 0x07
    26fa:	98 87       	std	Y+8, r25	; 0x08
    26fc:	a9 87       	std	Y+9, r26	; 0x09
    26fe:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2700:	6f 81       	ldd	r22, Y+7	; 0x07
    2702:	78 85       	ldd	r23, Y+8	; 0x08
    2704:	89 85       	ldd	r24, Y+9	; 0x09
    2706:	9a 85       	ldd	r25, Y+10	; 0x0a
    2708:	20 e0       	ldi	r18, 0x00	; 0
    270a:	30 e0       	ldi	r19, 0x00	; 0
    270c:	40 e8       	ldi	r20, 0x80	; 128
    270e:	5f e3       	ldi	r21, 0x3F	; 63
    2710:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2714:	88 23       	and	r24, r24
    2716:	2c f4       	brge	.+10     	; 0x2722 <task2+0xba>
		__ticks = 1;
    2718:	81 e0       	ldi	r24, 0x01	; 1
    271a:	90 e0       	ldi	r25, 0x00	; 0
    271c:	9e 83       	std	Y+6, r25	; 0x06
    271e:	8d 83       	std	Y+5, r24	; 0x05
    2720:	3f c0       	rjmp	.+126    	; 0x27a0 <task2+0x138>
	else if (__tmp > 65535)
    2722:	6f 81       	ldd	r22, Y+7	; 0x07
    2724:	78 85       	ldd	r23, Y+8	; 0x08
    2726:	89 85       	ldd	r24, Y+9	; 0x09
    2728:	9a 85       	ldd	r25, Y+10	; 0x0a
    272a:	20 e0       	ldi	r18, 0x00	; 0
    272c:	3f ef       	ldi	r19, 0xFF	; 255
    272e:	4f e7       	ldi	r20, 0x7F	; 127
    2730:	57 e4       	ldi	r21, 0x47	; 71
    2732:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2736:	18 16       	cp	r1, r24
    2738:	4c f5       	brge	.+82     	; 0x278c <task2+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    273a:	6b 85       	ldd	r22, Y+11	; 0x0b
    273c:	7c 85       	ldd	r23, Y+12	; 0x0c
    273e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2740:	9e 85       	ldd	r25, Y+14	; 0x0e
    2742:	20 e0       	ldi	r18, 0x00	; 0
    2744:	30 e0       	ldi	r19, 0x00	; 0
    2746:	40 e2       	ldi	r20, 0x20	; 32
    2748:	51 e4       	ldi	r21, 0x41	; 65
    274a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    274e:	dc 01       	movw	r26, r24
    2750:	cb 01       	movw	r24, r22
    2752:	bc 01       	movw	r22, r24
    2754:	cd 01       	movw	r24, r26
    2756:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    275a:	dc 01       	movw	r26, r24
    275c:	cb 01       	movw	r24, r22
    275e:	9e 83       	std	Y+6, r25	; 0x06
    2760:	8d 83       	std	Y+5, r24	; 0x05
    2762:	0f c0       	rjmp	.+30     	; 0x2782 <task2+0x11a>
    2764:	88 ec       	ldi	r24, 0xC8	; 200
    2766:	90 e0       	ldi	r25, 0x00	; 0
    2768:	9c 83       	std	Y+4, r25	; 0x04
    276a:	8b 83       	std	Y+3, r24	; 0x03
    276c:	8b 81       	ldd	r24, Y+3	; 0x03
    276e:	9c 81       	ldd	r25, Y+4	; 0x04
    2770:	01 97       	sbiw	r24, 0x01	; 1
    2772:	f1 f7       	brne	.-4      	; 0x2770 <task2+0x108>
    2774:	9c 83       	std	Y+4, r25	; 0x04
    2776:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2778:	8d 81       	ldd	r24, Y+5	; 0x05
    277a:	9e 81       	ldd	r25, Y+6	; 0x06
    277c:	01 97       	sbiw	r24, 0x01	; 1
    277e:	9e 83       	std	Y+6, r25	; 0x06
    2780:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2782:	8d 81       	ldd	r24, Y+5	; 0x05
    2784:	9e 81       	ldd	r25, Y+6	; 0x06
    2786:	00 97       	sbiw	r24, 0x00	; 0
    2788:	69 f7       	brne	.-38     	; 0x2764 <task2+0xfc>
    278a:	8e cf       	rjmp	.-228    	; 0x26a8 <task2+0x40>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    278c:	6f 81       	ldd	r22, Y+7	; 0x07
    278e:	78 85       	ldd	r23, Y+8	; 0x08
    2790:	89 85       	ldd	r24, Y+9	; 0x09
    2792:	9a 85       	ldd	r25, Y+10	; 0x0a
    2794:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2798:	dc 01       	movw	r26, r24
    279a:	cb 01       	movw	r24, r22
    279c:	9e 83       	std	Y+6, r25	; 0x06
    279e:	8d 83       	std	Y+5, r24	; 0x05
    27a0:	8d 81       	ldd	r24, Y+5	; 0x05
    27a2:	9e 81       	ldd	r25, Y+6	; 0x06
    27a4:	9a 83       	std	Y+2, r25	; 0x02
    27a6:	89 83       	std	Y+1, r24	; 0x01
    27a8:	89 81       	ldd	r24, Y+1	; 0x01
    27aa:	9a 81       	ldd	r25, Y+2	; 0x02
    27ac:	01 97       	sbiw	r24, 0x01	; 1
    27ae:	f1 f7       	brne	.-4      	; 0x27ac <task2+0x144>
    27b0:	9a 83       	std	Y+2, r25	; 0x02
    27b2:	89 83       	std	Y+1, r24	; 0x01
    27b4:	79 cf       	rjmp	.-270    	; 0x26a8 <task2+0x40>

000027b6 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    27b6:	df 93       	push	r29
    27b8:	cf 93       	push	r28
    27ba:	00 d0       	rcall	.+0      	; 0x27bc <xQueueGenericReset+0x6>
    27bc:	00 d0       	rcall	.+0      	; 0x27be <xQueueGenericReset+0x8>
    27be:	0f 92       	push	r0
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
    27c4:	9c 83       	std	Y+4, r25	; 0x04
    27c6:	8b 83       	std	Y+3, r24	; 0x03
    27c8:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    27ca:	8b 81       	ldd	r24, Y+3	; 0x03
    27cc:	9c 81       	ldd	r25, Y+4	; 0x04
    27ce:	9a 83       	std	Y+2, r25	; 0x02
    27d0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    27d2:	0f b6       	in	r0, 0x3f	; 63
    27d4:	f8 94       	cli
    27d6:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    27d8:	e9 81       	ldd	r30, Y+1	; 0x01
    27da:	fa 81       	ldd	r31, Y+2	; 0x02
    27dc:	40 81       	ld	r20, Z
    27de:	51 81       	ldd	r21, Z+1	; 0x01
    27e0:	e9 81       	ldd	r30, Y+1	; 0x01
    27e2:	fa 81       	ldd	r31, Y+2	; 0x02
    27e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    27e6:	28 2f       	mov	r18, r24
    27e8:	30 e0       	ldi	r19, 0x00	; 0
    27ea:	e9 81       	ldd	r30, Y+1	; 0x01
    27ec:	fa 81       	ldd	r31, Y+2	; 0x02
    27ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    27f0:	88 2f       	mov	r24, r24
    27f2:	90 e0       	ldi	r25, 0x00	; 0
    27f4:	bc 01       	movw	r22, r24
    27f6:	26 9f       	mul	r18, r22
    27f8:	c0 01       	movw	r24, r0
    27fa:	27 9f       	mul	r18, r23
    27fc:	90 0d       	add	r25, r0
    27fe:	36 9f       	mul	r19, r22
    2800:	90 0d       	add	r25, r0
    2802:	11 24       	eor	r1, r1
    2804:	84 0f       	add	r24, r20
    2806:	95 1f       	adc	r25, r21
    2808:	e9 81       	ldd	r30, Y+1	; 0x01
    280a:	fa 81       	ldd	r31, Y+2	; 0x02
    280c:	93 83       	std	Z+3, r25	; 0x03
    280e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2810:	e9 81       	ldd	r30, Y+1	; 0x01
    2812:	fa 81       	ldd	r31, Y+2	; 0x02
    2814:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2816:	e9 81       	ldd	r30, Y+1	; 0x01
    2818:	fa 81       	ldd	r31, Y+2	; 0x02
    281a:	80 81       	ld	r24, Z
    281c:	91 81       	ldd	r25, Z+1	; 0x01
    281e:	e9 81       	ldd	r30, Y+1	; 0x01
    2820:	fa 81       	ldd	r31, Y+2	; 0x02
    2822:	95 83       	std	Z+5, r25	; 0x05
    2824:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    2826:	e9 81       	ldd	r30, Y+1	; 0x01
    2828:	fa 81       	ldd	r31, Y+2	; 0x02
    282a:	40 81       	ld	r20, Z
    282c:	51 81       	ldd	r21, Z+1	; 0x01
    282e:	e9 81       	ldd	r30, Y+1	; 0x01
    2830:	fa 81       	ldd	r31, Y+2	; 0x02
    2832:	83 8d       	ldd	r24, Z+27	; 0x1b
    2834:	88 2f       	mov	r24, r24
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	9c 01       	movw	r18, r24
    283a:	21 50       	subi	r18, 0x01	; 1
    283c:	30 40       	sbci	r19, 0x00	; 0
    283e:	e9 81       	ldd	r30, Y+1	; 0x01
    2840:	fa 81       	ldd	r31, Y+2	; 0x02
    2842:	84 8d       	ldd	r24, Z+28	; 0x1c
    2844:	88 2f       	mov	r24, r24
    2846:	90 e0       	ldi	r25, 0x00	; 0
    2848:	bc 01       	movw	r22, r24
    284a:	26 9f       	mul	r18, r22
    284c:	c0 01       	movw	r24, r0
    284e:	27 9f       	mul	r18, r23
    2850:	90 0d       	add	r25, r0
    2852:	36 9f       	mul	r19, r22
    2854:	90 0d       	add	r25, r0
    2856:	11 24       	eor	r1, r1
    2858:	84 0f       	add	r24, r20
    285a:	95 1f       	adc	r25, r21
    285c:	e9 81       	ldd	r30, Y+1	; 0x01
    285e:	fa 81       	ldd	r31, Y+2	; 0x02
    2860:	97 83       	std	Z+7, r25	; 0x07
    2862:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2864:	e9 81       	ldd	r30, Y+1	; 0x01
    2866:	fa 81       	ldd	r31, Y+2	; 0x02
    2868:	8f ef       	ldi	r24, 0xFF	; 255
    286a:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    286c:	e9 81       	ldd	r30, Y+1	; 0x01
    286e:	fa 81       	ldd	r31, Y+2	; 0x02
    2870:	8f ef       	ldi	r24, 0xFF	; 255
    2872:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2874:	8d 81       	ldd	r24, Y+5	; 0x05
    2876:	88 23       	and	r24, r24
    2878:	79 f4       	brne	.+30     	; 0x2898 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    287a:	e9 81       	ldd	r30, Y+1	; 0x01
    287c:	fa 81       	ldd	r31, Y+2	; 0x02
    287e:	80 85       	ldd	r24, Z+8	; 0x08
    2880:	88 23       	and	r24, r24
    2882:	a1 f0       	breq	.+40     	; 0x28ac <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2884:	89 81       	ldd	r24, Y+1	; 0x01
    2886:	9a 81       	ldd	r25, Y+2	; 0x02
    2888:	08 96       	adiw	r24, 0x08	; 8
    288a:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    288e:	88 23       	and	r24, r24
    2890:	69 f0       	breq	.+26     	; 0x28ac <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2892:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
    2896:	0a c0       	rjmp	.+20     	; 0x28ac <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2898:	89 81       	ldd	r24, Y+1	; 0x01
    289a:	9a 81       	ldd	r25, Y+2	; 0x02
    289c:	08 96       	adiw	r24, 0x08	; 8
    289e:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    28a2:	89 81       	ldd	r24, Y+1	; 0x01
    28a4:	9a 81       	ldd	r25, Y+2	; 0x02
    28a6:	41 96       	adiw	r24, 0x11	; 17
    28a8:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    28ac:	0f 90       	pop	r0
    28ae:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    28b0:	81 e0       	ldi	r24, 0x01	; 1
}
    28b2:	0f 90       	pop	r0
    28b4:	0f 90       	pop	r0
    28b6:	0f 90       	pop	r0
    28b8:	0f 90       	pop	r0
    28ba:	0f 90       	pop	r0
    28bc:	cf 91       	pop	r28
    28be:	df 91       	pop	r29
    28c0:	08 95       	ret

000028c2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    28c2:	0f 93       	push	r16
    28c4:	1f 93       	push	r17
    28c6:	df 93       	push	r29
    28c8:	cf 93       	push	r28
    28ca:	cd b7       	in	r28, 0x3d	; 61
    28cc:	de b7       	in	r29, 0x3e	; 62
    28ce:	29 97       	sbiw	r28, 0x09	; 9
    28d0:	0f b6       	in	r0, 0x3f	; 63
    28d2:	f8 94       	cli
    28d4:	de bf       	out	0x3e, r29	; 62
    28d6:	0f be       	out	0x3f, r0	; 63
    28d8:	cd bf       	out	0x3d, r28	; 61
    28da:	8f 83       	std	Y+7, r24	; 0x07
    28dc:	68 87       	std	Y+8, r22	; 0x08
    28de:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    28e0:	88 85       	ldd	r24, Y+8	; 0x08
    28e2:	88 23       	and	r24, r24
    28e4:	19 f4       	brne	.+6      	; 0x28ec <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    28e6:	1c 82       	std	Y+4, r1	; 0x04
    28e8:	1b 82       	std	Y+3, r1	; 0x03
    28ea:	10 c0       	rjmp	.+32     	; 0x290c <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    28ec:	8f 81       	ldd	r24, Y+7	; 0x07
    28ee:	28 2f       	mov	r18, r24
    28f0:	30 e0       	ldi	r19, 0x00	; 0
    28f2:	88 85       	ldd	r24, Y+8	; 0x08
    28f4:	88 2f       	mov	r24, r24
    28f6:	90 e0       	ldi	r25, 0x00	; 0
    28f8:	ac 01       	movw	r20, r24
    28fa:	24 9f       	mul	r18, r20
    28fc:	c0 01       	movw	r24, r0
    28fe:	25 9f       	mul	r18, r21
    2900:	90 0d       	add	r25, r0
    2902:	34 9f       	mul	r19, r20
    2904:	90 0d       	add	r25, r0
    2906:	11 24       	eor	r1, r1
    2908:	9c 83       	std	Y+4, r25	; 0x04
    290a:	8b 83       	std	Y+3, r24	; 0x03
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    290c:	8b 81       	ldd	r24, Y+3	; 0x03
    290e:	9c 81       	ldd	r25, Y+4	; 0x04
    2910:	4f 96       	adiw	r24, 0x1f	; 31
    2912:	0e 94 bc 0c 	call	0x1978	; 0x1978 <pvPortMalloc>
    2916:	9e 83       	std	Y+6, r25	; 0x06
    2918:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    291a:	8d 81       	ldd	r24, Y+5	; 0x05
    291c:	9e 81       	ldd	r25, Y+6	; 0x06
    291e:	00 97       	sbiw	r24, 0x00	; 0
    2920:	81 f0       	breq	.+32     	; 0x2942 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
    2922:	8d 81       	ldd	r24, Y+5	; 0x05
    2924:	9e 81       	ldd	r25, Y+6	; 0x06
    2926:	4f 96       	adiw	r24, 0x1f	; 31
    2928:	9a 83       	std	Y+2, r25	; 0x02
    292a:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    292c:	29 81       	ldd	r18, Y+1	; 0x01
    292e:	3a 81       	ldd	r19, Y+2	; 0x02
    2930:	ed 81       	ldd	r30, Y+5	; 0x05
    2932:	fe 81       	ldd	r31, Y+6	; 0x06
    2934:	8f 81       	ldd	r24, Y+7	; 0x07
    2936:	68 85       	ldd	r22, Y+8	; 0x08
    2938:	a9 01       	movw	r20, r18
    293a:	29 85       	ldd	r18, Y+9	; 0x09
    293c:	8f 01       	movw	r16, r30
    293e:	0e 94 ae 14 	call	0x295c	; 0x295c <prvInitialiseNewQueue>
		}

		return pxNewQueue;
    2942:	8d 81       	ldd	r24, Y+5	; 0x05
    2944:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    2946:	29 96       	adiw	r28, 0x09	; 9
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	cf 91       	pop	r28
    2954:	df 91       	pop	r29
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	08 95       	ret

0000295c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    295c:	0f 93       	push	r16
    295e:	1f 93       	push	r17
    2960:	df 93       	push	r29
    2962:	cf 93       	push	r28
    2964:	cd b7       	in	r28, 0x3d	; 61
    2966:	de b7       	in	r29, 0x3e	; 62
    2968:	27 97       	sbiw	r28, 0x07	; 7
    296a:	0f b6       	in	r0, 0x3f	; 63
    296c:	f8 94       	cli
    296e:	de bf       	out	0x3e, r29	; 62
    2970:	0f be       	out	0x3f, r0	; 63
    2972:	cd bf       	out	0x3d, r28	; 61
    2974:	89 83       	std	Y+1, r24	; 0x01
    2976:	6a 83       	std	Y+2, r22	; 0x02
    2978:	5c 83       	std	Y+4, r21	; 0x04
    297a:	4b 83       	std	Y+3, r20	; 0x03
    297c:	2d 83       	std	Y+5, r18	; 0x05
    297e:	1f 83       	std	Y+7, r17	; 0x07
    2980:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    2982:	8a 81       	ldd	r24, Y+2	; 0x02
    2984:	88 23       	and	r24, r24
    2986:	39 f4       	brne	.+14     	; 0x2996 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2988:	8e 81       	ldd	r24, Y+6	; 0x06
    298a:	9f 81       	ldd	r25, Y+7	; 0x07
    298c:	ee 81       	ldd	r30, Y+6	; 0x06
    298e:	ff 81       	ldd	r31, Y+7	; 0x07
    2990:	91 83       	std	Z+1, r25	; 0x01
    2992:	80 83       	st	Z, r24
    2994:	06 c0       	rjmp	.+12     	; 0x29a2 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2996:	8b 81       	ldd	r24, Y+3	; 0x03
    2998:	9c 81       	ldd	r25, Y+4	; 0x04
    299a:	ee 81       	ldd	r30, Y+6	; 0x06
    299c:	ff 81       	ldd	r31, Y+7	; 0x07
    299e:	91 83       	std	Z+1, r25	; 0x01
    29a0:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    29a2:	ee 81       	ldd	r30, Y+6	; 0x06
    29a4:	ff 81       	ldd	r31, Y+7	; 0x07
    29a6:	89 81       	ldd	r24, Y+1	; 0x01
    29a8:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    29aa:	ee 81       	ldd	r30, Y+6	; 0x06
    29ac:	ff 81       	ldd	r31, Y+7	; 0x07
    29ae:	8a 81       	ldd	r24, Y+2	; 0x02
    29b0:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    29b2:	8e 81       	ldd	r24, Y+6	; 0x06
    29b4:	9f 81       	ldd	r25, Y+7	; 0x07
    29b6:	61 e0       	ldi	r22, 0x01	; 1
    29b8:	0e 94 db 13 	call	0x27b6	; 0x27b6 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    29bc:	27 96       	adiw	r28, 0x07	; 7
    29be:	0f b6       	in	r0, 0x3f	; 63
    29c0:	f8 94       	cli
    29c2:	de bf       	out	0x3e, r29	; 62
    29c4:	0f be       	out	0x3f, r0	; 63
    29c6:	cd bf       	out	0x3d, r28	; 61
    29c8:	cf 91       	pop	r28
    29ca:	df 91       	pop	r29
    29cc:	1f 91       	pop	r17
    29ce:	0f 91       	pop	r16
    29d0:	08 95       	ret

000029d2 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    29d2:	df 93       	push	r29
    29d4:	cf 93       	push	r28
    29d6:	00 d0       	rcall	.+0      	; 0x29d8 <prvInitialiseMutex+0x6>
    29d8:	cd b7       	in	r28, 0x3d	; 61
    29da:	de b7       	in	r29, 0x3e	; 62
    29dc:	9a 83       	std	Y+2, r25	; 0x02
    29de:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    29e0:	89 81       	ldd	r24, Y+1	; 0x01
    29e2:	9a 81       	ldd	r25, Y+2	; 0x02
    29e4:	00 97       	sbiw	r24, 0x00	; 0
    29e6:	a1 f0       	breq	.+40     	; 0x2a10 <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    29e8:	e9 81       	ldd	r30, Y+1	; 0x01
    29ea:	fa 81       	ldd	r31, Y+2	; 0x02
    29ec:	13 82       	std	Z+3, r1	; 0x03
    29ee:	12 82       	std	Z+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    29f0:	e9 81       	ldd	r30, Y+1	; 0x01
    29f2:	fa 81       	ldd	r31, Y+2	; 0x02
    29f4:	11 82       	std	Z+1, r1	; 0x01
    29f6:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
    29f8:	e9 81       	ldd	r30, Y+1	; 0x01
    29fa:	fa 81       	ldd	r31, Y+2	; 0x02
    29fc:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    29fe:	89 81       	ldd	r24, Y+1	; 0x01
    2a00:	9a 81       	ldd	r25, Y+2	; 0x02
    2a02:	60 e0       	ldi	r22, 0x00	; 0
    2a04:	70 e0       	ldi	r23, 0x00	; 0
    2a06:	40 e0       	ldi	r20, 0x00	; 0
    2a08:	50 e0       	ldi	r21, 0x00	; 0
    2a0a:	20 e0       	ldi	r18, 0x00	; 0
    2a0c:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    2a10:	0f 90       	pop	r0
    2a12:	0f 90       	pop	r0
    2a14:	cf 91       	pop	r28
    2a16:	df 91       	pop	r29
    2a18:	08 95       	ret

00002a1a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2a1a:	df 93       	push	r29
    2a1c:	cf 93       	push	r28
    2a1e:	00 d0       	rcall	.+0      	; 0x2a20 <xQueueCreateMutex+0x6>
    2a20:	00 d0       	rcall	.+0      	; 0x2a22 <xQueueCreateMutex+0x8>
    2a22:	0f 92       	push	r0
    2a24:	cd b7       	in	r28, 0x3d	; 61
    2a26:	de b7       	in	r29, 0x3e	; 62
    2a28:	8d 83       	std	Y+5, r24	; 0x05
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
    2a2c:	8a 83       	std	Y+2, r24	; 0x02
    2a2e:	19 82       	std	Y+1, r1	; 0x01

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    2a30:	8a 81       	ldd	r24, Y+2	; 0x02
    2a32:	69 81       	ldd	r22, Y+1	; 0x01
    2a34:	4d 81       	ldd	r20, Y+5	; 0x05
    2a36:	0e 94 61 14 	call	0x28c2	; 0x28c2 <xQueueGenericCreate>
    2a3a:	9c 83       	std	Y+4, r25	; 0x04
    2a3c:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( pxNewQueue );
    2a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a40:	9c 81       	ldd	r25, Y+4	; 0x04
    2a42:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <prvInitialiseMutex>

		return pxNewQueue;
    2a46:	8b 81       	ldd	r24, Y+3	; 0x03
    2a48:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    2a4a:	0f 90       	pop	r0
    2a4c:	0f 90       	pop	r0
    2a4e:	0f 90       	pop	r0
    2a50:	0f 90       	pop	r0
    2a52:	0f 90       	pop	r0
    2a54:	cf 91       	pop	r28
    2a56:	df 91       	pop	r29
    2a58:	08 95       	ret

00002a5a <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2a5a:	df 93       	push	r29
    2a5c:	cf 93       	push	r28
    2a5e:	cd b7       	in	r28, 0x3d	; 61
    2a60:	de b7       	in	r29, 0x3e	; 62
    2a62:	2f 97       	sbiw	r28, 0x0f	; 15
    2a64:	0f b6       	in	r0, 0x3f	; 63
    2a66:	f8 94       	cli
    2a68:	de bf       	out	0x3e, r29	; 62
    2a6a:	0f be       	out	0x3f, r0	; 63
    2a6c:	cd bf       	out	0x3d, r28	; 61
    2a6e:	99 87       	std	Y+9, r25	; 0x09
    2a70:	88 87       	std	Y+8, r24	; 0x08
    2a72:	7b 87       	std	Y+11, r23	; 0x0b
    2a74:	6a 87       	std	Y+10, r22	; 0x0a
    2a76:	5d 87       	std	Y+13, r21	; 0x0d
    2a78:	4c 87       	std	Y+12, r20	; 0x0c
    2a7a:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2a7c:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2a7e:	88 85       	ldd	r24, Y+8	; 0x08
    2a80:	99 85       	ldd	r25, Y+9	; 0x09
    2a82:	9a 83       	std	Y+2, r25	; 0x02
    2a84:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2a86:	0f b6       	in	r0, 0x3f	; 63
    2a88:	f8 94       	cli
    2a8a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2a8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a90:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a92:	e9 81       	ldd	r30, Y+1	; 0x01
    2a94:	fa 81       	ldd	r31, Y+2	; 0x02
    2a96:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a98:	98 17       	cp	r25, r24
    2a9a:	18 f0       	brcs	.+6      	; 0x2aa2 <xQueueGenericSend+0x48>
    2a9c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a9e:	82 30       	cpi	r24, 0x02	; 2
    2aa0:	11 f5       	brne	.+68     	; 0x2ae6 <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2aa2:	89 81       	ldd	r24, Y+1	; 0x01
    2aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    2aa6:	2a 85       	ldd	r18, Y+10	; 0x0a
    2aa8:	3b 85       	ldd	r19, Y+11	; 0x0b
    2aaa:	b9 01       	movw	r22, r18
    2aac:	4e 85       	ldd	r20, Y+14	; 0x0e
    2aae:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvCopyDataToQueue>
    2ab2:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ab4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ab6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ab8:	81 89       	ldd	r24, Z+17	; 0x11
    2aba:	88 23       	and	r24, r24
    2abc:	51 f0       	breq	.+20     	; 0x2ad2 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2abe:	89 81       	ldd	r24, Y+1	; 0x01
    2ac0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ac2:	41 96       	adiw	r24, 0x11	; 17
    2ac4:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    2ac8:	88 23       	and	r24, r24
    2aca:	41 f0       	breq	.+16     	; 0x2adc <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2acc:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
    2ad0:	05 c0       	rjmp	.+10     	; 0x2adc <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad4:	88 23       	and	r24, r24
    2ad6:	11 f0       	breq	.+4      	; 0x2adc <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2ad8:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2adc:	0f 90       	pop	r0
    2ade:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2ae0:	81 e0       	ldi	r24, 0x01	; 1
    2ae2:	8f 87       	std	Y+15, r24	; 0x0f
    2ae4:	5c c0       	rjmp	.+184    	; 0x2b9e <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2ae6:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ae8:	9d 85       	ldd	r25, Y+13	; 0x0d
    2aea:	00 97       	sbiw	r24, 0x00	; 0
    2aec:	21 f4       	brne	.+8      	; 0x2af6 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2aee:	0f 90       	pop	r0
    2af0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2af2:	1f 86       	std	Y+15, r1	; 0x0f
    2af4:	54 c0       	rjmp	.+168    	; 0x2b9e <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    2af6:	8c 81       	ldd	r24, Y+4	; 0x04
    2af8:	88 23       	and	r24, r24
    2afa:	31 f4       	brne	.+12     	; 0x2b08 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2afc:	ce 01       	movw	r24, r28
    2afe:	05 96       	adiw	r24, 0x05	; 5
    2b00:	0e 94 dc 23 	call	0x47b8	; 0x47b8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2b04:	81 e0       	ldi	r24, 0x01	; 1
    2b06:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2b08:	0f 90       	pop	r0
    2b0a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2b0c:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2b10:	0f b6       	in	r0, 0x3f	; 63
    2b12:	f8 94       	cli
    2b14:	0f 92       	push	r0
    2b16:	e9 81       	ldd	r30, Y+1	; 0x01
    2b18:	fa 81       	ldd	r31, Y+2	; 0x02
    2b1a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b1c:	8f 3f       	cpi	r24, 0xFF	; 255
    2b1e:	19 f4       	brne	.+6      	; 0x2b26 <xQueueGenericSend+0xcc>
    2b20:	e9 81       	ldd	r30, Y+1	; 0x01
    2b22:	fa 81       	ldd	r31, Y+2	; 0x02
    2b24:	15 8e       	std	Z+29, r1	; 0x1d
    2b26:	e9 81       	ldd	r30, Y+1	; 0x01
    2b28:	fa 81       	ldd	r31, Y+2	; 0x02
    2b2a:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b2c:	8f 3f       	cpi	r24, 0xFF	; 255
    2b2e:	19 f4       	brne	.+6      	; 0x2b36 <xQueueGenericSend+0xdc>
    2b30:	e9 81       	ldd	r30, Y+1	; 0x01
    2b32:	fa 81       	ldd	r31, Y+2	; 0x02
    2b34:	16 8e       	std	Z+30, r1	; 0x1e
    2b36:	0f 90       	pop	r0
    2b38:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b3a:	ce 01       	movw	r24, r28
    2b3c:	05 96       	adiw	r24, 0x05	; 5
    2b3e:	9e 01       	movw	r18, r28
    2b40:	24 5f       	subi	r18, 0xF4	; 244
    2b42:	3f 4f       	sbci	r19, 0xFF	; 255
    2b44:	b9 01       	movw	r22, r18
    2b46:	0e 94 f5 23 	call	0x47ea	; 0x47ea <xTaskCheckForTimeOut>
    2b4a:	88 23       	and	r24, r24
    2b4c:	09 f5       	brne	.+66     	; 0x2b90 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2b4e:	89 81       	ldd	r24, Y+1	; 0x01
    2b50:	9a 81       	ldd	r25, Y+2	; 0x02
    2b52:	0e 94 ec 19 	call	0x33d8	; 0x33d8 <prvIsQueueFull>
    2b56:	88 23       	and	r24, r24
    2b58:	a1 f0       	breq	.+40     	; 0x2b82 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2b5a:	89 81       	ldd	r24, Y+1	; 0x01
    2b5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b5e:	08 96       	adiw	r24, 0x08	; 8
    2b60:	2c 85       	ldd	r18, Y+12	; 0x0c
    2b62:	3d 85       	ldd	r19, Y+13	; 0x0d
    2b64:	b9 01       	movw	r22, r18
    2b66:	0e 94 ba 22 	call	0x4574	; 0x4574 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2b6a:	89 81       	ldd	r24, Y+1	; 0x01
    2b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2b6e:	0e 94 64 19 	call	0x32c8	; 0x32c8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2b72:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    2b76:	88 23       	and	r24, r24
    2b78:	09 f0       	breq	.+2      	; 0x2b7c <xQueueGenericSend+0x122>
    2b7a:	85 cf       	rjmp	.-246    	; 0x2a86 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2b7c:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
    2b80:	82 cf       	rjmp	.-252    	; 0x2a86 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
    2b84:	9a 81       	ldd	r25, Y+2	; 0x02
    2b86:	0e 94 64 19 	call	0x32c8	; 0x32c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2b8a:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    2b8e:	7b cf       	rjmp	.-266    	; 0x2a86 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2b90:	89 81       	ldd	r24, Y+1	; 0x01
    2b92:	9a 81       	ldd	r25, Y+2	; 0x02
    2b94:	0e 94 64 19 	call	0x32c8	; 0x32c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2b98:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2b9c:	1f 86       	std	Y+15, r1	; 0x0f
    2b9e:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    2ba0:	2f 96       	adiw	r28, 0x0f	; 15
    2ba2:	0f b6       	in	r0, 0x3f	; 63
    2ba4:	f8 94       	cli
    2ba6:	de bf       	out	0x3e, r29	; 62
    2ba8:	0f be       	out	0x3f, r0	; 63
    2baa:	cd bf       	out	0x3d, r28	; 61
    2bac:	cf 91       	pop	r28
    2bae:	df 91       	pop	r29
    2bb0:	08 95       	ret

00002bb2 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2bb2:	df 93       	push	r29
    2bb4:	cf 93       	push	r28
    2bb6:	cd b7       	in	r28, 0x3d	; 61
    2bb8:	de b7       	in	r29, 0x3e	; 62
    2bba:	2c 97       	sbiw	r28, 0x0c	; 12
    2bbc:	0f b6       	in	r0, 0x3f	; 63
    2bbe:	f8 94       	cli
    2bc0:	de bf       	out	0x3e, r29	; 62
    2bc2:	0f be       	out	0x3f, r0	; 63
    2bc4:	cd bf       	out	0x3d, r28	; 61
    2bc6:	9f 83       	std	Y+7, r25	; 0x07
    2bc8:	8e 83       	std	Y+6, r24	; 0x06
    2bca:	79 87       	std	Y+9, r23	; 0x09
    2bcc:	68 87       	std	Y+8, r22	; 0x08
    2bce:	5b 87       	std	Y+11, r21	; 0x0b
    2bd0:	4a 87       	std	Y+10, r20	; 0x0a
    2bd2:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2bd4:	8e 81       	ldd	r24, Y+6	; 0x06
    2bd6:	9f 81       	ldd	r25, Y+7	; 0x07
    2bd8:	9b 83       	std	Y+3, r25	; 0x03
    2bda:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2bdc:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2bde:	ea 81       	ldd	r30, Y+2	; 0x02
    2be0:	fb 81       	ldd	r31, Y+3	; 0x03
    2be2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2be4:	ea 81       	ldd	r30, Y+2	; 0x02
    2be6:	fb 81       	ldd	r31, Y+3	; 0x03
    2be8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2bea:	98 17       	cp	r25, r24
    2bec:	18 f0       	brcs	.+6      	; 0x2bf4 <xQueueGenericSendFromISR+0x42>
    2bee:	8c 85       	ldd	r24, Y+12	; 0x0c
    2bf0:	82 30       	cpi	r24, 0x02	; 2
    2bf2:	61 f5       	brne	.+88     	; 0x2c4c <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2bf4:	ea 81       	ldd	r30, Y+2	; 0x02
    2bf6:	fb 81       	ldd	r31, Y+3	; 0x03
    2bf8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2bfa:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bfe:	9b 81       	ldd	r25, Y+3	; 0x03
    2c00:	28 85       	ldd	r18, Y+8	; 0x08
    2c02:	39 85       	ldd	r19, Y+9	; 0x09
    2c04:	b9 01       	movw	r22, r18
    2c06:	4c 85       	ldd	r20, Y+12	; 0x0c
    2c08:	0e 94 65 18 	call	0x30ca	; 0x30ca <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2c0c:	89 81       	ldd	r24, Y+1	; 0x01
    2c0e:	8f 3f       	cpi	r24, 0xFF	; 255
    2c10:	a9 f4       	brne	.+42     	; 0x2c3c <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c12:	ea 81       	ldd	r30, Y+2	; 0x02
    2c14:	fb 81       	ldd	r31, Y+3	; 0x03
    2c16:	81 89       	ldd	r24, Z+17	; 0x11
    2c18:	88 23       	and	r24, r24
    2c1a:	a9 f0       	breq	.+42     	; 0x2c46 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c20:	41 96       	adiw	r24, 0x11	; 17
    2c22:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    2c26:	88 23       	and	r24, r24
    2c28:	71 f0       	breq	.+28     	; 0x2c46 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2c2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c2c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c2e:	00 97       	sbiw	r24, 0x00	; 0
    2c30:	51 f0       	breq	.+20     	; 0x2c46 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2c32:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c34:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c36:	81 e0       	ldi	r24, 0x01	; 1
    2c38:	80 83       	st	Z, r24
    2c3a:	05 c0       	rjmp	.+10     	; 0x2c46 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2c3c:	89 81       	ldd	r24, Y+1	; 0x01
    2c3e:	8f 5f       	subi	r24, 0xFF	; 255
    2c40:	ea 81       	ldd	r30, Y+2	; 0x02
    2c42:	fb 81       	ldd	r31, Y+3	; 0x03
    2c44:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	8d 83       	std	Y+5, r24	; 0x05
    2c4a:	01 c0       	rjmp	.+2      	; 0x2c4e <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2c4c:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2c4e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2c50:	2c 96       	adiw	r28, 0x0c	; 12
    2c52:	0f b6       	in	r0, 0x3f	; 63
    2c54:	f8 94       	cli
    2c56:	de bf       	out	0x3e, r29	; 62
    2c58:	0f be       	out	0x3f, r0	; 63
    2c5a:	cd bf       	out	0x3d, r28	; 61
    2c5c:	cf 91       	pop	r28
    2c5e:	df 91       	pop	r29
    2c60:	08 95       	ret

00002c62 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2c62:	df 93       	push	r29
    2c64:	cf 93       	push	r28
    2c66:	cd b7       	in	r28, 0x3d	; 61
    2c68:	de b7       	in	r29, 0x3e	; 62
    2c6a:	2a 97       	sbiw	r28, 0x0a	; 10
    2c6c:	0f b6       	in	r0, 0x3f	; 63
    2c6e:	f8 94       	cli
    2c70:	de bf       	out	0x3e, r29	; 62
    2c72:	0f be       	out	0x3f, r0	; 63
    2c74:	cd bf       	out	0x3d, r28	; 61
    2c76:	98 87       	std	Y+8, r25	; 0x08
    2c78:	8f 83       	std	Y+7, r24	; 0x07
    2c7a:	7a 87       	std	Y+10, r23	; 0x0a
    2c7c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2c7e:	8f 81       	ldd	r24, Y+7	; 0x07
    2c80:	98 85       	ldd	r25, Y+8	; 0x08
    2c82:	9c 83       	std	Y+4, r25	; 0x04
    2c84:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2c86:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2c88:	eb 81       	ldd	r30, Y+3	; 0x03
    2c8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c8e:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2c90:	eb 81       	ldd	r30, Y+3	; 0x03
    2c92:	fc 81       	ldd	r31, Y+4	; 0x04
    2c94:	93 8d       	ldd	r25, Z+27	; 0x1b
    2c96:	8a 81       	ldd	r24, Y+2	; 0x02
    2c98:	89 17       	cp	r24, r25
    2c9a:	48 f5       	brcc	.+82     	; 0x2cee <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca0:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ca2:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    2ca4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ca6:	8f 5f       	subi	r24, 0xFF	; 255
    2ca8:	eb 81       	ldd	r30, Y+3	; 0x03
    2caa:	fc 81       	ldd	r31, Y+4	; 0x04
    2cac:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2cae:	89 81       	ldd	r24, Y+1	; 0x01
    2cb0:	8f 3f       	cpi	r24, 0xFF	; 255
    2cb2:	a9 f4       	brne	.+42     	; 0x2cde <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2cb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb8:	81 89       	ldd	r24, Z+17	; 0x11
    2cba:	88 23       	and	r24, r24
    2cbc:	a9 f0       	breq	.+42     	; 0x2ce8 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2cbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc2:	41 96       	adiw	r24, 0x11	; 17
    2cc4:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    2cc8:	88 23       	and	r24, r24
    2cca:	71 f0       	breq	.+28     	; 0x2ce8 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2ccc:	89 85       	ldd	r24, Y+9	; 0x09
    2cce:	9a 85       	ldd	r25, Y+10	; 0x0a
    2cd0:	00 97       	sbiw	r24, 0x00	; 0
    2cd2:	51 f0       	breq	.+20     	; 0x2ce8 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2cd4:	e9 85       	ldd	r30, Y+9	; 0x09
    2cd6:	fa 85       	ldd	r31, Y+10	; 0x0a
    2cd8:	81 e0       	ldi	r24, 0x01	; 1
    2cda:	80 83       	st	Z, r24
    2cdc:	05 c0       	rjmp	.+10     	; 0x2ce8 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2cde:	89 81       	ldd	r24, Y+1	; 0x01
    2ce0:	8f 5f       	subi	r24, 0xFF	; 255
    2ce2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ce6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2ce8:	81 e0       	ldi	r24, 0x01	; 1
    2cea:	8e 83       	std	Y+6, r24	; 0x06
    2cec:	01 c0       	rjmp	.+2      	; 0x2cf0 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2cee:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2cf0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2cf2:	2a 96       	adiw	r28, 0x0a	; 10
    2cf4:	0f b6       	in	r0, 0x3f	; 63
    2cf6:	f8 94       	cli
    2cf8:	de bf       	out	0x3e, r29	; 62
    2cfa:	0f be       	out	0x3f, r0	; 63
    2cfc:	cd bf       	out	0x3d, r28	; 61
    2cfe:	cf 91       	pop	r28
    2d00:	df 91       	pop	r29
    2d02:	08 95       	ret

00002d04 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2d04:	df 93       	push	r29
    2d06:	cf 93       	push	r28
    2d08:	cd b7       	in	r28, 0x3d	; 61
    2d0a:	de b7       	in	r29, 0x3e	; 62
    2d0c:	61 97       	sbiw	r28, 0x11	; 17
    2d0e:	0f b6       	in	r0, 0x3f	; 63
    2d10:	f8 94       	cli
    2d12:	de bf       	out	0x3e, r29	; 62
    2d14:	0f be       	out	0x3f, r0	; 63
    2d16:	cd bf       	out	0x3d, r28	; 61
    2d18:	9b 87       	std	Y+11, r25	; 0x0b
    2d1a:	8a 87       	std	Y+10, r24	; 0x0a
    2d1c:	7d 87       	std	Y+13, r23	; 0x0d
    2d1e:	6c 87       	std	Y+12, r22	; 0x0c
    2d20:	5f 87       	std	Y+15, r21	; 0x0f
    2d22:	4e 87       	std	Y+14, r20	; 0x0e
    2d24:	28 8b       	std	Y+16, r18	; 0x10
BaseType_t xEntryTimeSet = pdFALSE;
    2d26:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2d28:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d2a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d2c:	9b 83       	std	Y+3, r25	; 0x03
    2d2e:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2d30:	0f b6       	in	r0, 0x3f	; 63
    2d32:	f8 94       	cli
    2d34:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2d36:	ea 81       	ldd	r30, Y+2	; 0x02
    2d38:	fb 81       	ldd	r31, Y+3	; 0x03
    2d3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d3c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d3e:	89 81       	ldd	r24, Y+1	; 0x01
    2d40:	88 23       	and	r24, r24
    2d42:	09 f4       	brne	.+2      	; 0x2d46 <xQueueGenericReceive+0x42>
    2d44:	49 c0       	rjmp	.+146    	; 0x2dd8 <xQueueGenericReceive+0xd4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2d46:	ea 81       	ldd	r30, Y+2	; 0x02
    2d48:	fb 81       	ldd	r31, Y+3	; 0x03
    2d4a:	86 81       	ldd	r24, Z+6	; 0x06
    2d4c:	97 81       	ldd	r25, Z+7	; 0x07
    2d4e:	9d 83       	std	Y+5, r25	; 0x05
    2d50:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2d52:	8a 81       	ldd	r24, Y+2	; 0x02
    2d54:	9b 81       	ldd	r25, Y+3	; 0x03
    2d56:	2c 85       	ldd	r18, Y+12	; 0x0c
    2d58:	3d 85       	ldd	r19, Y+13	; 0x0d
    2d5a:	b9 01       	movw	r22, r18
    2d5c:	0e 94 1d 19 	call	0x323a	; 0x323a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2d60:	88 89       	ldd	r24, Y+16	; 0x10
    2d62:	88 23       	and	r24, r24
    2d64:	01 f5       	brne	.+64     	; 0x2da6 <xQueueGenericReceive+0xa2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    2d66:	89 81       	ldd	r24, Y+1	; 0x01
    2d68:	81 50       	subi	r24, 0x01	; 1
    2d6a:	ea 81       	ldd	r30, Y+2	; 0x02
    2d6c:	fb 81       	ldd	r31, Y+3	; 0x03
    2d6e:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2d70:	ea 81       	ldd	r30, Y+2	; 0x02
    2d72:	fb 81       	ldd	r31, Y+3	; 0x03
    2d74:	80 81       	ld	r24, Z
    2d76:	91 81       	ldd	r25, Z+1	; 0x01
    2d78:	00 97       	sbiw	r24, 0x00	; 0
    2d7a:	31 f4       	brne	.+12     	; 0x2d88 <xQueueGenericReceive+0x84>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2d7c:	0e 94 73 26 	call	0x4ce6	; 0x4ce6 <pvTaskIncrementMutexHeldCount>
    2d80:	ea 81       	ldd	r30, Y+2	; 0x02
    2d82:	fb 81       	ldd	r31, Y+3	; 0x03
    2d84:	93 83       	std	Z+3, r25	; 0x03
    2d86:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2d88:	ea 81       	ldd	r30, Y+2	; 0x02
    2d8a:	fb 81       	ldd	r31, Y+3	; 0x03
    2d8c:	80 85       	ldd	r24, Z+8	; 0x08
    2d8e:	88 23       	and	r24, r24
    2d90:	f1 f0       	breq	.+60     	; 0x2dce <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2d92:	8a 81       	ldd	r24, Y+2	; 0x02
    2d94:	9b 81       	ldd	r25, Y+3	; 0x03
    2d96:	08 96       	adiw	r24, 0x08	; 8
    2d98:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    2d9c:	88 23       	and	r24, r24
    2d9e:	b9 f0       	breq	.+46     	; 0x2dce <xQueueGenericReceive+0xca>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2da0:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
    2da4:	14 c0       	rjmp	.+40     	; 0x2dce <xQueueGenericReceive+0xca>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2da6:	ea 81       	ldd	r30, Y+2	; 0x02
    2da8:	fb 81       	ldd	r31, Y+3	; 0x03
    2daa:	8c 81       	ldd	r24, Y+4	; 0x04
    2dac:	9d 81       	ldd	r25, Y+5	; 0x05
    2dae:	97 83       	std	Z+7, r25	; 0x07
    2db0:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2db2:	ea 81       	ldd	r30, Y+2	; 0x02
    2db4:	fb 81       	ldd	r31, Y+3	; 0x03
    2db6:	81 89       	ldd	r24, Z+17	; 0x11
    2db8:	88 23       	and	r24, r24
    2dba:	49 f0       	breq	.+18     	; 0x2dce <xQueueGenericReceive+0xca>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    2dbe:	9b 81       	ldd	r25, Y+3	; 0x03
    2dc0:	41 96       	adiw	r24, 0x11	; 17
    2dc2:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    2dc6:	88 23       	and	r24, r24
    2dc8:	11 f0       	breq	.+4      	; 0x2dce <xQueueGenericReceive+0xca>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2dca:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2dce:	0f 90       	pop	r0
    2dd0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2dd2:	81 e0       	ldi	r24, 0x01	; 1
    2dd4:	89 8b       	std	Y+17, r24	; 0x11
    2dd6:	74 c0       	rjmp	.+232    	; 0x2ec0 <xQueueGenericReceive+0x1bc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2dd8:	8e 85       	ldd	r24, Y+14	; 0x0e
    2dda:	9f 85       	ldd	r25, Y+15	; 0x0f
    2ddc:	00 97       	sbiw	r24, 0x00	; 0
    2dde:	21 f4       	brne	.+8      	; 0x2de8 <xQueueGenericReceive+0xe4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2de0:	0f 90       	pop	r0
    2de2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2de4:	19 8a       	std	Y+17, r1	; 0x11
    2de6:	6c c0       	rjmp	.+216    	; 0x2ec0 <xQueueGenericReceive+0x1bc>
				}
				else if( xEntryTimeSet == pdFALSE )
    2de8:	8e 81       	ldd	r24, Y+6	; 0x06
    2dea:	88 23       	and	r24, r24
    2dec:	31 f4       	brne	.+12     	; 0x2dfa <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2dee:	ce 01       	movw	r24, r28
    2df0:	07 96       	adiw	r24, 0x07	; 7
    2df2:	0e 94 dc 23 	call	0x47b8	; 0x47b8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2df6:	81 e0       	ldi	r24, 0x01	; 1
    2df8:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2dfa:	0f 90       	pop	r0
    2dfc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2dfe:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2e02:	0f b6       	in	r0, 0x3f	; 63
    2e04:	f8 94       	cli
    2e06:	0f 92       	push	r0
    2e08:	ea 81       	ldd	r30, Y+2	; 0x02
    2e0a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e0e:	8f 3f       	cpi	r24, 0xFF	; 255
    2e10:	19 f4       	brne	.+6      	; 0x2e18 <xQueueGenericReceive+0x114>
    2e12:	ea 81       	ldd	r30, Y+2	; 0x02
    2e14:	fb 81       	ldd	r31, Y+3	; 0x03
    2e16:	15 8e       	std	Z+29, r1	; 0x1d
    2e18:	ea 81       	ldd	r30, Y+2	; 0x02
    2e1a:	fb 81       	ldd	r31, Y+3	; 0x03
    2e1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2e1e:	8f 3f       	cpi	r24, 0xFF	; 255
    2e20:	19 f4       	brne	.+6      	; 0x2e28 <xQueueGenericReceive+0x124>
    2e22:	ea 81       	ldd	r30, Y+2	; 0x02
    2e24:	fb 81       	ldd	r31, Y+3	; 0x03
    2e26:	16 8e       	std	Z+30, r1	; 0x1e
    2e28:	0f 90       	pop	r0
    2e2a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2e2c:	ce 01       	movw	r24, r28
    2e2e:	07 96       	adiw	r24, 0x07	; 7
    2e30:	9e 01       	movw	r18, r28
    2e32:	22 5f       	subi	r18, 0xF2	; 242
    2e34:	3f 4f       	sbci	r19, 0xFF	; 255
    2e36:	b9 01       	movw	r22, r18
    2e38:	0e 94 f5 23 	call	0x47ea	; 0x47ea <xTaskCheckForTimeOut>
    2e3c:	88 23       	and	r24, r24
    2e3e:	91 f5       	brne	.+100    	; 0x2ea4 <xQueueGenericReceive+0x1a0>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2e40:	8a 81       	ldd	r24, Y+2	; 0x02
    2e42:	9b 81       	ldd	r25, Y+3	; 0x03
    2e44:	0e 94 b7 19 	call	0x336e	; 0x336e <prvIsQueueEmpty>
    2e48:	88 23       	and	r24, r24
    2e4a:	29 f1       	breq	.+74     	; 0x2e96 <xQueueGenericReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2e4c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e4e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e50:	80 81       	ld	r24, Z
    2e52:	91 81       	ldd	r25, Z+1	; 0x01
    2e54:	00 97       	sbiw	r24, 0x00	; 0
    2e56:	59 f4       	brne	.+22     	; 0x2e6e <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
    2e58:	0f b6       	in	r0, 0x3f	; 63
    2e5a:	f8 94       	cli
    2e5c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2e5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e60:	fb 81       	ldd	r31, Y+3	; 0x03
    2e62:	82 81       	ldd	r24, Z+2	; 0x02
    2e64:	93 81       	ldd	r25, Z+3	; 0x03
    2e66:	0e 94 4f 25 	call	0x4a9e	; 0x4a9e <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    2e6a:	0f 90       	pop	r0
    2e6c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2e6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e70:	9b 81       	ldd	r25, Y+3	; 0x03
    2e72:	41 96       	adiw	r24, 0x11	; 17
    2e74:	2e 85       	ldd	r18, Y+14	; 0x0e
    2e76:	3f 85       	ldd	r19, Y+15	; 0x0f
    2e78:	b9 01       	movw	r22, r18
    2e7a:	0e 94 ba 22 	call	0x4574	; 0x4574 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e80:	9b 81       	ldd	r25, Y+3	; 0x03
    2e82:	0e 94 64 19 	call	0x32c8	; 0x32c8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2e86:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    2e8a:	88 23       	and	r24, r24
    2e8c:	09 f0       	breq	.+2      	; 0x2e90 <xQueueGenericReceive+0x18c>
    2e8e:	50 cf       	rjmp	.-352    	; 0x2d30 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    2e90:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
    2e94:	4d cf       	rjmp	.-358    	; 0x2d30 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2e96:	8a 81       	ldd	r24, Y+2	; 0x02
    2e98:	9b 81       	ldd	r25, Y+3	; 0x03
    2e9a:	0e 94 64 19 	call	0x32c8	; 0x32c8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2e9e:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    2ea2:	46 cf       	rjmp	.-372    	; 0x2d30 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea8:	0e 94 64 19 	call	0x32c8	; 0x32c8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2eac:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    2eb2:	9b 81       	ldd	r25, Y+3	; 0x03
    2eb4:	0e 94 b7 19 	call	0x336e	; 0x336e <prvIsQueueEmpty>
    2eb8:	88 23       	and	r24, r24
    2eba:	09 f4       	brne	.+2      	; 0x2ebe <xQueueGenericReceive+0x1ba>
    2ebc:	39 cf       	rjmp	.-398    	; 0x2d30 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2ebe:	19 8a       	std	Y+17, r1	; 0x11
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2ec0:	89 89       	ldd	r24, Y+17	; 0x11
}
    2ec2:	61 96       	adiw	r28, 0x11	; 17
    2ec4:	0f b6       	in	r0, 0x3f	; 63
    2ec6:	f8 94       	cli
    2ec8:	de bf       	out	0x3e, r29	; 62
    2eca:	0f be       	out	0x3f, r0	; 63
    2ecc:	cd bf       	out	0x3d, r28	; 61
    2ece:	cf 91       	pop	r28
    2ed0:	df 91       	pop	r29
    2ed2:	08 95       	ret

00002ed4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2ed4:	df 93       	push	r29
    2ed6:	cf 93       	push	r28
    2ed8:	cd b7       	in	r28, 0x3d	; 61
    2eda:	de b7       	in	r29, 0x3e	; 62
    2edc:	2c 97       	sbiw	r28, 0x0c	; 12
    2ede:	0f b6       	in	r0, 0x3f	; 63
    2ee0:	f8 94       	cli
    2ee2:	de bf       	out	0x3e, r29	; 62
    2ee4:	0f be       	out	0x3f, r0	; 63
    2ee6:	cd bf       	out	0x3d, r28	; 61
    2ee8:	98 87       	std	Y+8, r25	; 0x08
    2eea:	8f 83       	std	Y+7, r24	; 0x07
    2eec:	7a 87       	std	Y+10, r23	; 0x0a
    2eee:	69 87       	std	Y+9, r22	; 0x09
    2ef0:	5c 87       	std	Y+12, r21	; 0x0c
    2ef2:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2ef4:	8f 81       	ldd	r24, Y+7	; 0x07
    2ef6:	98 85       	ldd	r25, Y+8	; 0x08
    2ef8:	9c 83       	std	Y+4, r25	; 0x04
    2efa:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2efc:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2efe:	eb 81       	ldd	r30, Y+3	; 0x03
    2f00:	fc 81       	ldd	r31, Y+4	; 0x04
    2f02:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f04:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f06:	8a 81       	ldd	r24, Y+2	; 0x02
    2f08:	88 23       	and	r24, r24
    2f0a:	81 f1       	breq	.+96     	; 0x2f6c <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    2f0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f10:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f12:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2f14:	8b 81       	ldd	r24, Y+3	; 0x03
    2f16:	9c 81       	ldd	r25, Y+4	; 0x04
    2f18:	29 85       	ldd	r18, Y+9	; 0x09
    2f1a:	3a 85       	ldd	r19, Y+10	; 0x0a
    2f1c:	b9 01       	movw	r22, r18
    2f1e:	0e 94 1d 19 	call	0x323a	; 0x323a <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    2f22:	8a 81       	ldd	r24, Y+2	; 0x02
    2f24:	81 50       	subi	r24, 0x01	; 1
    2f26:	eb 81       	ldd	r30, Y+3	; 0x03
    2f28:	fc 81       	ldd	r31, Y+4	; 0x04
    2f2a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2f2c:	89 81       	ldd	r24, Y+1	; 0x01
    2f2e:	8f 3f       	cpi	r24, 0xFF	; 255
    2f30:	a9 f4       	brne	.+42     	; 0x2f5c <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f32:	eb 81       	ldd	r30, Y+3	; 0x03
    2f34:	fc 81       	ldd	r31, Y+4	; 0x04
    2f36:	80 85       	ldd	r24, Z+8	; 0x08
    2f38:	88 23       	and	r24, r24
    2f3a:	a9 f0       	breq	.+42     	; 0x2f66 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f40:	08 96       	adiw	r24, 0x08	; 8
    2f42:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    2f46:	88 23       	and	r24, r24
    2f48:	71 f0       	breq	.+28     	; 0x2f66 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2f4a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2f4c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2f4e:	00 97       	sbiw	r24, 0x00	; 0
    2f50:	51 f0       	breq	.+20     	; 0x2f66 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2f52:	eb 85       	ldd	r30, Y+11	; 0x0b
    2f54:	fc 85       	ldd	r31, Y+12	; 0x0c
    2f56:	81 e0       	ldi	r24, 0x01	; 1
    2f58:	80 83       	st	Z, r24
    2f5a:	05 c0       	rjmp	.+10     	; 0x2f66 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2f5c:	89 81       	ldd	r24, Y+1	; 0x01
    2f5e:	8f 5f       	subi	r24, 0xFF	; 255
    2f60:	eb 81       	ldd	r30, Y+3	; 0x03
    2f62:	fc 81       	ldd	r31, Y+4	; 0x04
    2f64:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2f66:	81 e0       	ldi	r24, 0x01	; 1
    2f68:	8e 83       	std	Y+6, r24	; 0x06
    2f6a:	01 c0       	rjmp	.+2      	; 0x2f6e <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2f6c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2f6e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2f70:	2c 96       	adiw	r28, 0x0c	; 12
    2f72:	0f b6       	in	r0, 0x3f	; 63
    2f74:	f8 94       	cli
    2f76:	de bf       	out	0x3e, r29	; 62
    2f78:	0f be       	out	0x3f, r0	; 63
    2f7a:	cd bf       	out	0x3d, r28	; 61
    2f7c:	cf 91       	pop	r28
    2f7e:	df 91       	pop	r29
    2f80:	08 95       	ret

00002f82 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2f82:	df 93       	push	r29
    2f84:	cf 93       	push	r28
    2f86:	cd b7       	in	r28, 0x3d	; 61
    2f88:	de b7       	in	r29, 0x3e	; 62
    2f8a:	2a 97       	sbiw	r28, 0x0a	; 10
    2f8c:	0f b6       	in	r0, 0x3f	; 63
    2f8e:	f8 94       	cli
    2f90:	de bf       	out	0x3e, r29	; 62
    2f92:	0f be       	out	0x3f, r0	; 63
    2f94:	cd bf       	out	0x3d, r28	; 61
    2f96:	98 87       	std	Y+8, r25	; 0x08
    2f98:	8f 83       	std	Y+7, r24	; 0x07
    2f9a:	7a 87       	std	Y+10, r23	; 0x0a
    2f9c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2f9e:	8f 81       	ldd	r24, Y+7	; 0x07
    2fa0:	98 85       	ldd	r25, Y+8	; 0x08
    2fa2:	9a 83       	std	Y+2, r25	; 0x02
    2fa4:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2fa6:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2faa:	fa 81       	ldd	r31, Y+2	; 0x02
    2fac:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fae:	88 23       	and	r24, r24
    2fb0:	b1 f0       	breq	.+44     	; 0x2fde <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb6:	86 81       	ldd	r24, Z+6	; 0x06
    2fb8:	97 81       	ldd	r25, Z+7	; 0x07
    2fba:	9c 83       	std	Y+4, r25	; 0x04
    2fbc:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2fbe:	89 81       	ldd	r24, Y+1	; 0x01
    2fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc2:	29 85       	ldd	r18, Y+9	; 0x09
    2fc4:	3a 85       	ldd	r19, Y+10	; 0x0a
    2fc6:	b9 01       	movw	r22, r18
    2fc8:	0e 94 1d 19 	call	0x323a	; 0x323a <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    2fce:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fd2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fd4:	97 83       	std	Z+7, r25	; 0x07
    2fd6:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2fd8:	81 e0       	ldi	r24, 0x01	; 1
    2fda:	8e 83       	std	Y+6, r24	; 0x06
    2fdc:	01 c0       	rjmp	.+2      	; 0x2fe0 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2fde:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2fe0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2fe2:	2a 96       	adiw	r28, 0x0a	; 10
    2fe4:	0f b6       	in	r0, 0x3f	; 63
    2fe6:	f8 94       	cli
    2fe8:	de bf       	out	0x3e, r29	; 62
    2fea:	0f be       	out	0x3f, r0	; 63
    2fec:	cd bf       	out	0x3d, r28	; 61
    2fee:	cf 91       	pop	r28
    2ff0:	df 91       	pop	r29
    2ff2:	08 95       	ret

00002ff4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2ff4:	df 93       	push	r29
    2ff6:	cf 93       	push	r28
    2ff8:	00 d0       	rcall	.+0      	; 0x2ffa <uxQueueMessagesWaiting+0x6>
    2ffa:	0f 92       	push	r0
    2ffc:	cd b7       	in	r28, 0x3d	; 61
    2ffe:	de b7       	in	r29, 0x3e	; 62
    3000:	9b 83       	std	Y+3, r25	; 0x03
    3002:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3004:	0f b6       	in	r0, 0x3f	; 63
    3006:	f8 94       	cli
    3008:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    300a:	ea 81       	ldd	r30, Y+2	; 0x02
    300c:	fb 81       	ldd	r31, Y+3	; 0x03
    300e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3010:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3012:	0f 90       	pop	r0
    3014:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3016:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3018:	0f 90       	pop	r0
    301a:	0f 90       	pop	r0
    301c:	0f 90       	pop	r0
    301e:	cf 91       	pop	r28
    3020:	df 91       	pop	r29
    3022:	08 95       	ret

00003024 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    3024:	df 93       	push	r29
    3026:	cf 93       	push	r28
    3028:	00 d0       	rcall	.+0      	; 0x302a <uxQueueSpacesAvailable+0x6>
    302a:	00 d0       	rcall	.+0      	; 0x302c <uxQueueSpacesAvailable+0x8>
    302c:	0f 92       	push	r0
    302e:	cd b7       	in	r28, 0x3d	; 61
    3030:	de b7       	in	r29, 0x3e	; 62
    3032:	9d 83       	std	Y+5, r25	; 0x05
    3034:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    3036:	8c 81       	ldd	r24, Y+4	; 0x04
    3038:	9d 81       	ldd	r25, Y+5	; 0x05
    303a:	9a 83       	std	Y+2, r25	; 0x02
    303c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    303e:	0f b6       	in	r0, 0x3f	; 63
    3040:	f8 94       	cli
    3042:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3044:	e9 81       	ldd	r30, Y+1	; 0x01
    3046:	fa 81       	ldd	r31, Y+2	; 0x02
    3048:	93 8d       	ldd	r25, Z+27	; 0x1b
    304a:	e9 81       	ldd	r30, Y+1	; 0x01
    304c:	fa 81       	ldd	r31, Y+2	; 0x02
    304e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3050:	29 2f       	mov	r18, r25
    3052:	28 1b       	sub	r18, r24
    3054:	82 2f       	mov	r24, r18
    3056:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    3058:	0f 90       	pop	r0
    305a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    305c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    305e:	0f 90       	pop	r0
    3060:	0f 90       	pop	r0
    3062:	0f 90       	pop	r0
    3064:	0f 90       	pop	r0
    3066:	0f 90       	pop	r0
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	08 95       	ret

0000306e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    306e:	df 93       	push	r29
    3070:	cf 93       	push	r28
    3072:	00 d0       	rcall	.+0      	; 0x3074 <uxQueueMessagesWaitingFromISR+0x6>
    3074:	0f 92       	push	r0
    3076:	cd b7       	in	r28, 0x3d	; 61
    3078:	de b7       	in	r29, 0x3e	; 62
    307a:	9b 83       	std	Y+3, r25	; 0x03
    307c:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    307e:	ea 81       	ldd	r30, Y+2	; 0x02
    3080:	fb 81       	ldd	r31, Y+3	; 0x03
    3082:	82 8d       	ldd	r24, Z+26	; 0x1a
    3084:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3086:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3088:	0f 90       	pop	r0
    308a:	0f 90       	pop	r0
    308c:	0f 90       	pop	r0
    308e:	cf 91       	pop	r28
    3090:	df 91       	pop	r29
    3092:	08 95       	ret

00003094 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    3094:	df 93       	push	r29
    3096:	cf 93       	push	r28
    3098:	00 d0       	rcall	.+0      	; 0x309a <vQueueDelete+0x6>
    309a:	00 d0       	rcall	.+0      	; 0x309c <vQueueDelete+0x8>
    309c:	cd b7       	in	r28, 0x3d	; 61
    309e:	de b7       	in	r29, 0x3e	; 62
    30a0:	9c 83       	std	Y+4, r25	; 0x04
    30a2:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    30a4:	8b 81       	ldd	r24, Y+3	; 0x03
    30a6:	9c 81       	ldd	r25, Y+4	; 0x04
    30a8:	9a 83       	std	Y+2, r25	; 0x02
    30aa:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    30ac:	89 81       	ldd	r24, Y+1	; 0x01
    30ae:	9a 81       	ldd	r25, Y+2	; 0x02
    30b0:	0e 94 ac 1a 	call	0x3558	; 0x3558 <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    30b4:	89 81       	ldd	r24, Y+1	; 0x01
    30b6:	9a 81       	ldd	r25, Y+2	; 0x02
    30b8:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    30bc:	0f 90       	pop	r0
    30be:	0f 90       	pop	r0
    30c0:	0f 90       	pop	r0
    30c2:	0f 90       	pop	r0
    30c4:	cf 91       	pop	r28
    30c6:	df 91       	pop	r29
    30c8:	08 95       	ret

000030ca <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    30ca:	df 93       	push	r29
    30cc:	cf 93       	push	r28
    30ce:	cd b7       	in	r28, 0x3d	; 61
    30d0:	de b7       	in	r29, 0x3e	; 62
    30d2:	27 97       	sbiw	r28, 0x07	; 7
    30d4:	0f b6       	in	r0, 0x3f	; 63
    30d6:	f8 94       	cli
    30d8:	de bf       	out	0x3e, r29	; 62
    30da:	0f be       	out	0x3f, r0	; 63
    30dc:	cd bf       	out	0x3d, r28	; 61
    30de:	9c 83       	std	Y+4, r25	; 0x04
    30e0:	8b 83       	std	Y+3, r24	; 0x03
    30e2:	7e 83       	std	Y+6, r23	; 0x06
    30e4:	6d 83       	std	Y+5, r22	; 0x05
    30e6:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    30e8:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    30ea:	eb 81       	ldd	r30, Y+3	; 0x03
    30ec:	fc 81       	ldd	r31, Y+4	; 0x04
    30ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    30f0:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    30f2:	eb 81       	ldd	r30, Y+3	; 0x03
    30f4:	fc 81       	ldd	r31, Y+4	; 0x04
    30f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    30f8:	88 23       	and	r24, r24
    30fa:	99 f4       	brne	.+38     	; 0x3122 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    30fc:	eb 81       	ldd	r30, Y+3	; 0x03
    30fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3100:	80 81       	ld	r24, Z
    3102:	91 81       	ldd	r25, Z+1	; 0x01
    3104:	00 97       	sbiw	r24, 0x00	; 0
    3106:	09 f0       	breq	.+2      	; 0x310a <prvCopyDataToQueue+0x40>
    3108:	89 c0       	rjmp	.+274    	; 0x321c <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    310a:	eb 81       	ldd	r30, Y+3	; 0x03
    310c:	fc 81       	ldd	r31, Y+4	; 0x04
    310e:	82 81       	ldd	r24, Z+2	; 0x02
    3110:	93 81       	ldd	r25, Z+3	; 0x03
    3112:	0e 94 da 25 	call	0x4bb4	; 0x4bb4 <xTaskPriorityDisinherit>
    3116:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->pxMutexHolder = NULL;
    3118:	eb 81       	ldd	r30, Y+3	; 0x03
    311a:	fc 81       	ldd	r31, Y+4	; 0x04
    311c:	13 82       	std	Z+3, r1	; 0x03
    311e:	12 82       	std	Z+2, r1	; 0x02
    3120:	7d c0       	rjmp	.+250    	; 0x321c <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    3122:	8f 81       	ldd	r24, Y+7	; 0x07
    3124:	88 23       	and	r24, r24
    3126:	99 f5       	brne	.+102    	; 0x318e <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    3128:	eb 81       	ldd	r30, Y+3	; 0x03
    312a:	fc 81       	ldd	r31, Y+4	; 0x04
    312c:	64 81       	ldd	r22, Z+4	; 0x04
    312e:	75 81       	ldd	r23, Z+5	; 0x05
    3130:	eb 81       	ldd	r30, Y+3	; 0x03
    3132:	fc 81       	ldd	r31, Y+4	; 0x04
    3134:	84 8d       	ldd	r24, Z+28	; 0x1c
    3136:	48 2f       	mov	r20, r24
    3138:	50 e0       	ldi	r21, 0x00	; 0
    313a:	2d 81       	ldd	r18, Y+5	; 0x05
    313c:	3e 81       	ldd	r19, Y+6	; 0x06
    313e:	cb 01       	movw	r24, r22
    3140:	b9 01       	movw	r22, r18
    3142:	0e 94 e8 2a 	call	0x55d0	; 0x55d0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3146:	eb 81       	ldd	r30, Y+3	; 0x03
    3148:	fc 81       	ldd	r31, Y+4	; 0x04
    314a:	24 81       	ldd	r18, Z+4	; 0x04
    314c:	35 81       	ldd	r19, Z+5	; 0x05
    314e:	eb 81       	ldd	r30, Y+3	; 0x03
    3150:	fc 81       	ldd	r31, Y+4	; 0x04
    3152:	84 8d       	ldd	r24, Z+28	; 0x1c
    3154:	88 2f       	mov	r24, r24
    3156:	90 e0       	ldi	r25, 0x00	; 0
    3158:	82 0f       	add	r24, r18
    315a:	93 1f       	adc	r25, r19
    315c:	eb 81       	ldd	r30, Y+3	; 0x03
    315e:	fc 81       	ldd	r31, Y+4	; 0x04
    3160:	95 83       	std	Z+5, r25	; 0x05
    3162:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3164:	eb 81       	ldd	r30, Y+3	; 0x03
    3166:	fc 81       	ldd	r31, Y+4	; 0x04
    3168:	24 81       	ldd	r18, Z+4	; 0x04
    316a:	35 81       	ldd	r19, Z+5	; 0x05
    316c:	eb 81       	ldd	r30, Y+3	; 0x03
    316e:	fc 81       	ldd	r31, Y+4	; 0x04
    3170:	82 81       	ldd	r24, Z+2	; 0x02
    3172:	93 81       	ldd	r25, Z+3	; 0x03
    3174:	28 17       	cp	r18, r24
    3176:	39 07       	cpc	r19, r25
    3178:	08 f4       	brcc	.+2      	; 0x317c <prvCopyDataToQueue+0xb2>
    317a:	50 c0       	rjmp	.+160    	; 0x321c <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    317c:	eb 81       	ldd	r30, Y+3	; 0x03
    317e:	fc 81       	ldd	r31, Y+4	; 0x04
    3180:	80 81       	ld	r24, Z
    3182:	91 81       	ldd	r25, Z+1	; 0x01
    3184:	eb 81       	ldd	r30, Y+3	; 0x03
    3186:	fc 81       	ldd	r31, Y+4	; 0x04
    3188:	95 83       	std	Z+5, r25	; 0x05
    318a:	84 83       	std	Z+4, r24	; 0x04
    318c:	47 c0       	rjmp	.+142    	; 0x321c <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    318e:	eb 81       	ldd	r30, Y+3	; 0x03
    3190:	fc 81       	ldd	r31, Y+4	; 0x04
    3192:	66 81       	ldd	r22, Z+6	; 0x06
    3194:	77 81       	ldd	r23, Z+7	; 0x07
    3196:	eb 81       	ldd	r30, Y+3	; 0x03
    3198:	fc 81       	ldd	r31, Y+4	; 0x04
    319a:	84 8d       	ldd	r24, Z+28	; 0x1c
    319c:	48 2f       	mov	r20, r24
    319e:	50 e0       	ldi	r21, 0x00	; 0
    31a0:	2d 81       	ldd	r18, Y+5	; 0x05
    31a2:	3e 81       	ldd	r19, Y+6	; 0x06
    31a4:	cb 01       	movw	r24, r22
    31a6:	b9 01       	movw	r22, r18
    31a8:	0e 94 e8 2a 	call	0x55d0	; 0x55d0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    31ac:	eb 81       	ldd	r30, Y+3	; 0x03
    31ae:	fc 81       	ldd	r31, Y+4	; 0x04
    31b0:	26 81       	ldd	r18, Z+6	; 0x06
    31b2:	37 81       	ldd	r19, Z+7	; 0x07
    31b4:	eb 81       	ldd	r30, Y+3	; 0x03
    31b6:	fc 81       	ldd	r31, Y+4	; 0x04
    31b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    31ba:	88 2f       	mov	r24, r24
    31bc:	90 e0       	ldi	r25, 0x00	; 0
    31be:	90 95       	com	r25
    31c0:	81 95       	neg	r24
    31c2:	9f 4f       	sbci	r25, 0xFF	; 255
    31c4:	82 0f       	add	r24, r18
    31c6:	93 1f       	adc	r25, r19
    31c8:	eb 81       	ldd	r30, Y+3	; 0x03
    31ca:	fc 81       	ldd	r31, Y+4	; 0x04
    31cc:	97 83       	std	Z+7, r25	; 0x07
    31ce:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    31d0:	eb 81       	ldd	r30, Y+3	; 0x03
    31d2:	fc 81       	ldd	r31, Y+4	; 0x04
    31d4:	26 81       	ldd	r18, Z+6	; 0x06
    31d6:	37 81       	ldd	r19, Z+7	; 0x07
    31d8:	eb 81       	ldd	r30, Y+3	; 0x03
    31da:	fc 81       	ldd	r31, Y+4	; 0x04
    31dc:	80 81       	ld	r24, Z
    31de:	91 81       	ldd	r25, Z+1	; 0x01
    31e0:	28 17       	cp	r18, r24
    31e2:	39 07       	cpc	r19, r25
    31e4:	90 f4       	brcc	.+36     	; 0x320a <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    31e6:	eb 81       	ldd	r30, Y+3	; 0x03
    31e8:	fc 81       	ldd	r31, Y+4	; 0x04
    31ea:	22 81       	ldd	r18, Z+2	; 0x02
    31ec:	33 81       	ldd	r19, Z+3	; 0x03
    31ee:	eb 81       	ldd	r30, Y+3	; 0x03
    31f0:	fc 81       	ldd	r31, Y+4	; 0x04
    31f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    31f4:	88 2f       	mov	r24, r24
    31f6:	90 e0       	ldi	r25, 0x00	; 0
    31f8:	90 95       	com	r25
    31fa:	81 95       	neg	r24
    31fc:	9f 4f       	sbci	r25, 0xFF	; 255
    31fe:	82 0f       	add	r24, r18
    3200:	93 1f       	adc	r25, r19
    3202:	eb 81       	ldd	r30, Y+3	; 0x03
    3204:	fc 81       	ldd	r31, Y+4	; 0x04
    3206:	97 83       	std	Z+7, r25	; 0x07
    3208:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    320a:	8f 81       	ldd	r24, Y+7	; 0x07
    320c:	82 30       	cpi	r24, 0x02	; 2
    320e:	31 f4       	brne	.+12     	; 0x321c <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3210:	89 81       	ldd	r24, Y+1	; 0x01
    3212:	88 23       	and	r24, r24
    3214:	19 f0       	breq	.+6      	; 0x321c <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    3216:	89 81       	ldd	r24, Y+1	; 0x01
    3218:	81 50       	subi	r24, 0x01	; 1
    321a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
    321c:	89 81       	ldd	r24, Y+1	; 0x01
    321e:	8f 5f       	subi	r24, 0xFF	; 255
    3220:	eb 81       	ldd	r30, Y+3	; 0x03
    3222:	fc 81       	ldd	r31, Y+4	; 0x04
    3224:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    3226:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3228:	27 96       	adiw	r28, 0x07	; 7
    322a:	0f b6       	in	r0, 0x3f	; 63
    322c:	f8 94       	cli
    322e:	de bf       	out	0x3e, r29	; 62
    3230:	0f be       	out	0x3f, r0	; 63
    3232:	cd bf       	out	0x3d, r28	; 61
    3234:	cf 91       	pop	r28
    3236:	df 91       	pop	r29
    3238:	08 95       	ret

0000323a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    323a:	df 93       	push	r29
    323c:	cf 93       	push	r28
    323e:	00 d0       	rcall	.+0      	; 0x3240 <prvCopyDataFromQueue+0x6>
    3240:	00 d0       	rcall	.+0      	; 0x3242 <prvCopyDataFromQueue+0x8>
    3242:	cd b7       	in	r28, 0x3d	; 61
    3244:	de b7       	in	r29, 0x3e	; 62
    3246:	9a 83       	std	Y+2, r25	; 0x02
    3248:	89 83       	std	Y+1, r24	; 0x01
    324a:	7c 83       	std	Y+4, r23	; 0x04
    324c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    324e:	e9 81       	ldd	r30, Y+1	; 0x01
    3250:	fa 81       	ldd	r31, Y+2	; 0x02
    3252:	84 8d       	ldd	r24, Z+28	; 0x1c
    3254:	88 23       	and	r24, r24
    3256:	89 f1       	breq	.+98     	; 0x32ba <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3258:	e9 81       	ldd	r30, Y+1	; 0x01
    325a:	fa 81       	ldd	r31, Y+2	; 0x02
    325c:	26 81       	ldd	r18, Z+6	; 0x06
    325e:	37 81       	ldd	r19, Z+7	; 0x07
    3260:	e9 81       	ldd	r30, Y+1	; 0x01
    3262:	fa 81       	ldd	r31, Y+2	; 0x02
    3264:	84 8d       	ldd	r24, Z+28	; 0x1c
    3266:	88 2f       	mov	r24, r24
    3268:	90 e0       	ldi	r25, 0x00	; 0
    326a:	82 0f       	add	r24, r18
    326c:	93 1f       	adc	r25, r19
    326e:	e9 81       	ldd	r30, Y+1	; 0x01
    3270:	fa 81       	ldd	r31, Y+2	; 0x02
    3272:	97 83       	std	Z+7, r25	; 0x07
    3274:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3276:	e9 81       	ldd	r30, Y+1	; 0x01
    3278:	fa 81       	ldd	r31, Y+2	; 0x02
    327a:	26 81       	ldd	r18, Z+6	; 0x06
    327c:	37 81       	ldd	r19, Z+7	; 0x07
    327e:	e9 81       	ldd	r30, Y+1	; 0x01
    3280:	fa 81       	ldd	r31, Y+2	; 0x02
    3282:	82 81       	ldd	r24, Z+2	; 0x02
    3284:	93 81       	ldd	r25, Z+3	; 0x03
    3286:	28 17       	cp	r18, r24
    3288:	39 07       	cpc	r19, r25
    328a:	40 f0       	brcs	.+16     	; 0x329c <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    328c:	e9 81       	ldd	r30, Y+1	; 0x01
    328e:	fa 81       	ldd	r31, Y+2	; 0x02
    3290:	80 81       	ld	r24, Z
    3292:	91 81       	ldd	r25, Z+1	; 0x01
    3294:	e9 81       	ldd	r30, Y+1	; 0x01
    3296:	fa 81       	ldd	r31, Y+2	; 0x02
    3298:	97 83       	std	Z+7, r25	; 0x07
    329a:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    329c:	e9 81       	ldd	r30, Y+1	; 0x01
    329e:	fa 81       	ldd	r31, Y+2	; 0x02
    32a0:	46 81       	ldd	r20, Z+6	; 0x06
    32a2:	57 81       	ldd	r21, Z+7	; 0x07
    32a4:	e9 81       	ldd	r30, Y+1	; 0x01
    32a6:	fa 81       	ldd	r31, Y+2	; 0x02
    32a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    32aa:	28 2f       	mov	r18, r24
    32ac:	30 e0       	ldi	r19, 0x00	; 0
    32ae:	8b 81       	ldd	r24, Y+3	; 0x03
    32b0:	9c 81       	ldd	r25, Y+4	; 0x04
    32b2:	ba 01       	movw	r22, r20
    32b4:	a9 01       	movw	r20, r18
    32b6:	0e 94 e8 2a 	call	0x55d0	; 0x55d0 <memcpy>
	}
}
    32ba:	0f 90       	pop	r0
    32bc:	0f 90       	pop	r0
    32be:	0f 90       	pop	r0
    32c0:	0f 90       	pop	r0
    32c2:	cf 91       	pop	r28
    32c4:	df 91       	pop	r29
    32c6:	08 95       	ret

000032c8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    32c8:	df 93       	push	r29
    32ca:	cf 93       	push	r28
    32cc:	00 d0       	rcall	.+0      	; 0x32ce <prvUnlockQueue+0x6>
    32ce:	00 d0       	rcall	.+0      	; 0x32d0 <prvUnlockQueue+0x8>
    32d0:	cd b7       	in	r28, 0x3d	; 61
    32d2:	de b7       	in	r29, 0x3e	; 62
    32d4:	9c 83       	std	Y+4, r25	; 0x04
    32d6:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    32d8:	0f b6       	in	r0, 0x3f	; 63
    32da:	f8 94       	cli
    32dc:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    32de:	eb 81       	ldd	r30, Y+3	; 0x03
    32e0:	fc 81       	ldd	r31, Y+4	; 0x04
    32e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    32e4:	8a 83       	std	Y+2, r24	; 0x02
    32e6:	11 c0       	rjmp	.+34     	; 0x330a <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    32e8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ea:	fc 81       	ldd	r31, Y+4	; 0x04
    32ec:	81 89       	ldd	r24, Z+17	; 0x11
    32ee:	88 23       	and	r24, r24
    32f0:	79 f0       	breq	.+30     	; 0x3310 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    32f2:	8b 81       	ldd	r24, Y+3	; 0x03
    32f4:	9c 81       	ldd	r25, Y+4	; 0x04
    32f6:	41 96       	adiw	r24, 0x11	; 17
    32f8:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    32fc:	88 23       	and	r24, r24
    32fe:	11 f0       	breq	.+4      	; 0x3304 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    3300:	0e 94 62 24 	call	0x48c4	; 0x48c4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    3304:	8a 81       	ldd	r24, Y+2	; 0x02
    3306:	81 50       	subi	r24, 0x01	; 1
    3308:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    330a:	8a 81       	ldd	r24, Y+2	; 0x02
    330c:	18 16       	cp	r1, r24
    330e:	64 f3       	brlt	.-40     	; 0x32e8 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    3310:	eb 81       	ldd	r30, Y+3	; 0x03
    3312:	fc 81       	ldd	r31, Y+4	; 0x04
    3314:	8f ef       	ldi	r24, 0xFF	; 255
    3316:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3318:	0f 90       	pop	r0
    331a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    331c:	0f b6       	in	r0, 0x3f	; 63
    331e:	f8 94       	cli
    3320:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    3322:	eb 81       	ldd	r30, Y+3	; 0x03
    3324:	fc 81       	ldd	r31, Y+4	; 0x04
    3326:	85 8d       	ldd	r24, Z+29	; 0x1d
    3328:	89 83       	std	Y+1, r24	; 0x01
    332a:	11 c0       	rjmp	.+34     	; 0x334e <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    332c:	eb 81       	ldd	r30, Y+3	; 0x03
    332e:	fc 81       	ldd	r31, Y+4	; 0x04
    3330:	80 85       	ldd	r24, Z+8	; 0x08
    3332:	88 23       	and	r24, r24
    3334:	79 f0       	breq	.+30     	; 0x3354 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3336:	8b 81       	ldd	r24, Y+3	; 0x03
    3338:	9c 81       	ldd	r25, Y+4	; 0x04
    333a:	08 96       	adiw	r24, 0x08	; 8
    333c:	0e 94 0c 23 	call	0x4618	; 0x4618 <xTaskRemoveFromEventList>
    3340:	88 23       	and	r24, r24
    3342:	11 f0       	breq	.+4      	; 0x3348 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    3344:	0e 94 62 24 	call	0x48c4	; 0x48c4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    3348:	89 81       	ldd	r24, Y+1	; 0x01
    334a:	81 50       	subi	r24, 0x01	; 1
    334c:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    334e:	89 81       	ldd	r24, Y+1	; 0x01
    3350:	18 16       	cp	r1, r24
    3352:	64 f3       	brlt	.-40     	; 0x332c <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    3354:	eb 81       	ldd	r30, Y+3	; 0x03
    3356:	fc 81       	ldd	r31, Y+4	; 0x04
    3358:	8f ef       	ldi	r24, 0xFF	; 255
    335a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    335c:	0f 90       	pop	r0
    335e:	0f be       	out	0x3f, r0	; 63
}
    3360:	0f 90       	pop	r0
    3362:	0f 90       	pop	r0
    3364:	0f 90       	pop	r0
    3366:	0f 90       	pop	r0
    3368:	cf 91       	pop	r28
    336a:	df 91       	pop	r29
    336c:	08 95       	ret

0000336e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    336e:	df 93       	push	r29
    3370:	cf 93       	push	r28
    3372:	00 d0       	rcall	.+0      	; 0x3374 <prvIsQueueEmpty+0x6>
    3374:	0f 92       	push	r0
    3376:	cd b7       	in	r28, 0x3d	; 61
    3378:	de b7       	in	r29, 0x3e	; 62
    337a:	9b 83       	std	Y+3, r25	; 0x03
    337c:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    337e:	0f b6       	in	r0, 0x3f	; 63
    3380:	f8 94       	cli
    3382:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3384:	ea 81       	ldd	r30, Y+2	; 0x02
    3386:	fb 81       	ldd	r31, Y+3	; 0x03
    3388:	82 8d       	ldd	r24, Z+26	; 0x1a
    338a:	88 23       	and	r24, r24
    338c:	19 f4       	brne	.+6      	; 0x3394 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    338e:	81 e0       	ldi	r24, 0x01	; 1
    3390:	89 83       	std	Y+1, r24	; 0x01
    3392:	01 c0       	rjmp	.+2      	; 0x3396 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    3394:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3396:	0f 90       	pop	r0
    3398:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    339a:	89 81       	ldd	r24, Y+1	; 0x01
}
    339c:	0f 90       	pop	r0
    339e:	0f 90       	pop	r0
    33a0:	0f 90       	pop	r0
    33a2:	cf 91       	pop	r28
    33a4:	df 91       	pop	r29
    33a6:	08 95       	ret

000033a8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    33a8:	df 93       	push	r29
    33aa:	cf 93       	push	r28
    33ac:	00 d0       	rcall	.+0      	; 0x33ae <xQueueIsQueueEmptyFromISR+0x6>
    33ae:	0f 92       	push	r0
    33b0:	cd b7       	in	r28, 0x3d	; 61
    33b2:	de b7       	in	r29, 0x3e	; 62
    33b4:	9b 83       	std	Y+3, r25	; 0x03
    33b6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    33b8:	ea 81       	ldd	r30, Y+2	; 0x02
    33ba:	fb 81       	ldd	r31, Y+3	; 0x03
    33bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    33be:	88 23       	and	r24, r24
    33c0:	19 f4       	brne	.+6      	; 0x33c8 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    33c2:	81 e0       	ldi	r24, 0x01	; 1
    33c4:	89 83       	std	Y+1, r24	; 0x01
    33c6:	01 c0       	rjmp	.+2      	; 0x33ca <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    33c8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    33ca:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    33cc:	0f 90       	pop	r0
    33ce:	0f 90       	pop	r0
    33d0:	0f 90       	pop	r0
    33d2:	cf 91       	pop	r28
    33d4:	df 91       	pop	r29
    33d6:	08 95       	ret

000033d8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    33d8:	df 93       	push	r29
    33da:	cf 93       	push	r28
    33dc:	00 d0       	rcall	.+0      	; 0x33de <prvIsQueueFull+0x6>
    33de:	0f 92       	push	r0
    33e0:	cd b7       	in	r28, 0x3d	; 61
    33e2:	de b7       	in	r29, 0x3e	; 62
    33e4:	9b 83       	std	Y+3, r25	; 0x03
    33e6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    33e8:	0f b6       	in	r0, 0x3f	; 63
    33ea:	f8 94       	cli
    33ec:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    33ee:	ea 81       	ldd	r30, Y+2	; 0x02
    33f0:	fb 81       	ldd	r31, Y+3	; 0x03
    33f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    33f4:	ea 81       	ldd	r30, Y+2	; 0x02
    33f6:	fb 81       	ldd	r31, Y+3	; 0x03
    33f8:	83 8d       	ldd	r24, Z+27	; 0x1b
    33fa:	98 17       	cp	r25, r24
    33fc:	19 f4       	brne	.+6      	; 0x3404 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    33fe:	81 e0       	ldi	r24, 0x01	; 1
    3400:	89 83       	std	Y+1, r24	; 0x01
    3402:	01 c0       	rjmp	.+2      	; 0x3406 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    3404:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3406:	0f 90       	pop	r0
    3408:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    340a:	89 81       	ldd	r24, Y+1	; 0x01
}
    340c:	0f 90       	pop	r0
    340e:	0f 90       	pop	r0
    3410:	0f 90       	pop	r0
    3412:	cf 91       	pop	r28
    3414:	df 91       	pop	r29
    3416:	08 95       	ret

00003418 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3418:	df 93       	push	r29
    341a:	cf 93       	push	r28
    341c:	00 d0       	rcall	.+0      	; 0x341e <xQueueIsQueueFullFromISR+0x6>
    341e:	0f 92       	push	r0
    3420:	cd b7       	in	r28, 0x3d	; 61
    3422:	de b7       	in	r29, 0x3e	; 62
    3424:	9b 83       	std	Y+3, r25	; 0x03
    3426:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    3428:	ea 81       	ldd	r30, Y+2	; 0x02
    342a:	fb 81       	ldd	r31, Y+3	; 0x03
    342c:	92 8d       	ldd	r25, Z+26	; 0x1a
    342e:	ea 81       	ldd	r30, Y+2	; 0x02
    3430:	fb 81       	ldd	r31, Y+3	; 0x03
    3432:	83 8d       	ldd	r24, Z+27	; 0x1b
    3434:	98 17       	cp	r25, r24
    3436:	19 f4       	brne	.+6      	; 0x343e <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    3438:	81 e0       	ldi	r24, 0x01	; 1
    343a:	89 83       	std	Y+1, r24	; 0x01
    343c:	01 c0       	rjmp	.+2      	; 0x3440 <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    343e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3440:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3442:	0f 90       	pop	r0
    3444:	0f 90       	pop	r0
    3446:	0f 90       	pop	r0
    3448:	cf 91       	pop	r28
    344a:	df 91       	pop	r29
    344c:	08 95       	ret

0000344e <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    344e:	df 93       	push	r29
    3450:	cf 93       	push	r28
    3452:	00 d0       	rcall	.+0      	; 0x3454 <vQueueAddToRegistry+0x6>
    3454:	00 d0       	rcall	.+0      	; 0x3456 <vQueueAddToRegistry+0x8>
    3456:	0f 92       	push	r0
    3458:	cd b7       	in	r28, 0x3d	; 61
    345a:	de b7       	in	r29, 0x3e	; 62
    345c:	9b 83       	std	Y+3, r25	; 0x03
    345e:	8a 83       	std	Y+2, r24	; 0x02
    3460:	7d 83       	std	Y+5, r23	; 0x05
    3462:	6c 83       	std	Y+4, r22	; 0x04
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    3464:	19 82       	std	Y+1, r1	; 0x01
    3466:	2f c0       	rjmp	.+94     	; 0x34c6 <vQueueAddToRegistry+0x78>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    3468:	89 81       	ldd	r24, Y+1	; 0x01
    346a:	88 2f       	mov	r24, r24
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	88 0f       	add	r24, r24
    3470:	99 1f       	adc	r25, r25
    3472:	88 0f       	add	r24, r24
    3474:	99 1f       	adc	r25, r25
    3476:	fc 01       	movw	r30, r24
    3478:	e2 5f       	subi	r30, 0xF2	; 242
    347a:	fb 4f       	sbci	r31, 0xFB	; 251
    347c:	80 81       	ld	r24, Z
    347e:	91 81       	ldd	r25, Z+1	; 0x01
    3480:	00 97       	sbiw	r24, 0x00	; 0
    3482:	f1 f4       	brne	.+60     	; 0x34c0 <vQueueAddToRegistry+0x72>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    3484:	89 81       	ldd	r24, Y+1	; 0x01
    3486:	88 2f       	mov	r24, r24
    3488:	90 e0       	ldi	r25, 0x00	; 0
    348a:	88 0f       	add	r24, r24
    348c:	99 1f       	adc	r25, r25
    348e:	88 0f       	add	r24, r24
    3490:	99 1f       	adc	r25, r25
    3492:	fc 01       	movw	r30, r24
    3494:	e2 5f       	subi	r30, 0xF2	; 242
    3496:	fb 4f       	sbci	r31, 0xFB	; 251
    3498:	8c 81       	ldd	r24, Y+4	; 0x04
    349a:	9d 81       	ldd	r25, Y+5	; 0x05
    349c:	91 83       	std	Z+1, r25	; 0x01
    349e:	80 83       	st	Z, r24
				xQueueRegistry[ ux ].xHandle = xQueue;
    34a0:	89 81       	ldd	r24, Y+1	; 0x01
    34a2:	88 2f       	mov	r24, r24
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	88 0f       	add	r24, r24
    34a8:	99 1f       	adc	r25, r25
    34aa:	01 96       	adiw	r24, 0x01	; 1
    34ac:	88 0f       	add	r24, r24
    34ae:	99 1f       	adc	r25, r25
    34b0:	fc 01       	movw	r30, r24
    34b2:	e2 5f       	subi	r30, 0xF2	; 242
    34b4:	fb 4f       	sbci	r31, 0xFB	; 251
    34b6:	8a 81       	ldd	r24, Y+2	; 0x02
    34b8:	9b 81       	ldd	r25, Y+3	; 0x03
    34ba:	91 83       	std	Z+1, r25	; 0x01
    34bc:	80 83       	st	Z, r24
    34be:	06 c0       	rjmp	.+12     	; 0x34cc <vQueueAddToRegistry+0x7e>
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    34c0:	89 81       	ldd	r24, Y+1	; 0x01
    34c2:	8f 5f       	subi	r24, 0xFF	; 255
    34c4:	89 83       	std	Y+1, r24	; 0x01
    34c6:	89 81       	ldd	r24, Y+1	; 0x01
    34c8:	88 30       	cpi	r24, 0x08	; 8
    34ca:	70 f2       	brcs	.-100    	; 0x3468 <vQueueAddToRegistry+0x1a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    34cc:	0f 90       	pop	r0
    34ce:	0f 90       	pop	r0
    34d0:	0f 90       	pop	r0
    34d2:	0f 90       	pop	r0
    34d4:	0f 90       	pop	r0
    34d6:	cf 91       	pop	r28
    34d8:	df 91       	pop	r29
    34da:	08 95       	ret

000034dc <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    34dc:	df 93       	push	r29
    34de:	cf 93       	push	r28
    34e0:	00 d0       	rcall	.+0      	; 0x34e2 <pcQueueGetName+0x6>
    34e2:	00 d0       	rcall	.+0      	; 0x34e4 <pcQueueGetName+0x8>
    34e4:	0f 92       	push	r0
    34e6:	cd b7       	in	r28, 0x3d	; 61
    34e8:	de b7       	in	r29, 0x3e	; 62
    34ea:	9d 83       	std	Y+5, r25	; 0x05
    34ec:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    34ee:	1a 82       	std	Y+2, r1	; 0x02
    34f0:	19 82       	std	Y+1, r1	; 0x01

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    34f2:	1b 82       	std	Y+3, r1	; 0x03
    34f4:	24 c0       	rjmp	.+72     	; 0x353e <pcQueueGetName+0x62>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    34f6:	8b 81       	ldd	r24, Y+3	; 0x03
    34f8:	88 2f       	mov	r24, r24
    34fa:	90 e0       	ldi	r25, 0x00	; 0
    34fc:	88 0f       	add	r24, r24
    34fe:	99 1f       	adc	r25, r25
    3500:	01 96       	adiw	r24, 0x01	; 1
    3502:	88 0f       	add	r24, r24
    3504:	99 1f       	adc	r25, r25
    3506:	fc 01       	movw	r30, r24
    3508:	e2 5f       	subi	r30, 0xF2	; 242
    350a:	fb 4f       	sbci	r31, 0xFB	; 251
    350c:	20 81       	ld	r18, Z
    350e:	31 81       	ldd	r19, Z+1	; 0x01
    3510:	8c 81       	ldd	r24, Y+4	; 0x04
    3512:	9d 81       	ldd	r25, Y+5	; 0x05
    3514:	28 17       	cp	r18, r24
    3516:	39 07       	cpc	r19, r25
    3518:	79 f4       	brne	.+30     	; 0x3538 <pcQueueGetName+0x5c>
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    351a:	8b 81       	ldd	r24, Y+3	; 0x03
    351c:	88 2f       	mov	r24, r24
    351e:	90 e0       	ldi	r25, 0x00	; 0
    3520:	88 0f       	add	r24, r24
    3522:	99 1f       	adc	r25, r25
    3524:	88 0f       	add	r24, r24
    3526:	99 1f       	adc	r25, r25
    3528:	fc 01       	movw	r30, r24
    352a:	e2 5f       	subi	r30, 0xF2	; 242
    352c:	fb 4f       	sbci	r31, 0xFB	; 251
    352e:	80 81       	ld	r24, Z
    3530:	91 81       	ldd	r25, Z+1	; 0x01
    3532:	9a 83       	std	Y+2, r25	; 0x02
    3534:	89 83       	std	Y+1, r24	; 0x01
    3536:	06 c0       	rjmp	.+12     	; 0x3544 <pcQueueGetName+0x68>
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    3538:	8b 81       	ldd	r24, Y+3	; 0x03
    353a:	8f 5f       	subi	r24, 0xFF	; 255
    353c:	8b 83       	std	Y+3, r24	; 0x03
    353e:	8b 81       	ldd	r24, Y+3	; 0x03
    3540:	88 30       	cpi	r24, 0x08	; 8
    3542:	c8 f2       	brcs	.-78     	; 0x34f6 <pcQueueGetName+0x1a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
    3544:	89 81       	ldd	r24, Y+1	; 0x01
    3546:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3548:	0f 90       	pop	r0
    354a:	0f 90       	pop	r0
    354c:	0f 90       	pop	r0
    354e:	0f 90       	pop	r0
    3550:	0f 90       	pop	r0
    3552:	cf 91       	pop	r28
    3554:	df 91       	pop	r29
    3556:	08 95       	ret

00003558 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    3558:	df 93       	push	r29
    355a:	cf 93       	push	r28
    355c:	00 d0       	rcall	.+0      	; 0x355e <vQueueUnregisterQueue+0x6>
    355e:	0f 92       	push	r0
    3560:	cd b7       	in	r28, 0x3d	; 61
    3562:	de b7       	in	r29, 0x3e	; 62
    3564:	9b 83       	std	Y+3, r25	; 0x03
    3566:	8a 83       	std	Y+2, r24	; 0x02
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    3568:	19 82       	std	Y+1, r1	; 0x01
    356a:	2f c0       	rjmp	.+94     	; 0x35ca <vQueueUnregisterQueue+0x72>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    356c:	89 81       	ldd	r24, Y+1	; 0x01
    356e:	88 2f       	mov	r24, r24
    3570:	90 e0       	ldi	r25, 0x00	; 0
    3572:	88 0f       	add	r24, r24
    3574:	99 1f       	adc	r25, r25
    3576:	01 96       	adiw	r24, 0x01	; 1
    3578:	88 0f       	add	r24, r24
    357a:	99 1f       	adc	r25, r25
    357c:	fc 01       	movw	r30, r24
    357e:	e2 5f       	subi	r30, 0xF2	; 242
    3580:	fb 4f       	sbci	r31, 0xFB	; 251
    3582:	20 81       	ld	r18, Z
    3584:	31 81       	ldd	r19, Z+1	; 0x01
    3586:	8a 81       	ldd	r24, Y+2	; 0x02
    3588:	9b 81       	ldd	r25, Y+3	; 0x03
    358a:	28 17       	cp	r18, r24
    358c:	39 07       	cpc	r19, r25
    358e:	d1 f4       	brne	.+52     	; 0x35c4 <vQueueUnregisterQueue+0x6c>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    3590:	89 81       	ldd	r24, Y+1	; 0x01
    3592:	88 2f       	mov	r24, r24
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	88 0f       	add	r24, r24
    3598:	99 1f       	adc	r25, r25
    359a:	88 0f       	add	r24, r24
    359c:	99 1f       	adc	r25, r25
    359e:	fc 01       	movw	r30, r24
    35a0:	e2 5f       	subi	r30, 0xF2	; 242
    35a2:	fb 4f       	sbci	r31, 0xFB	; 251
    35a4:	11 82       	std	Z+1, r1	; 0x01
    35a6:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    35a8:	89 81       	ldd	r24, Y+1	; 0x01
    35aa:	88 2f       	mov	r24, r24
    35ac:	90 e0       	ldi	r25, 0x00	; 0
    35ae:	88 0f       	add	r24, r24
    35b0:	99 1f       	adc	r25, r25
    35b2:	01 96       	adiw	r24, 0x01	; 1
    35b4:	88 0f       	add	r24, r24
    35b6:	99 1f       	adc	r25, r25
    35b8:	fc 01       	movw	r30, r24
    35ba:	e2 5f       	subi	r30, 0xF2	; 242
    35bc:	fb 4f       	sbci	r31, 0xFB	; 251
    35be:	11 82       	std	Z+1, r1	; 0x01
    35c0:	10 82       	st	Z, r1
    35c2:	06 c0       	rjmp	.+12     	; 0x35d0 <vQueueUnregisterQueue+0x78>
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    35c4:	89 81       	ldd	r24, Y+1	; 0x01
    35c6:	8f 5f       	subi	r24, 0xFF	; 255
    35c8:	89 83       	std	Y+1, r24	; 0x01
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	88 30       	cpi	r24, 0x08	; 8
    35ce:	70 f2       	brcs	.-100    	; 0x356c <vQueueUnregisterQueue+0x14>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    35d0:	0f 90       	pop	r0
    35d2:	0f 90       	pop	r0
    35d4:	0f 90       	pop	r0
    35d6:	cf 91       	pop	r28
    35d8:	df 91       	pop	r29
    35da:	08 95       	ret

000035dc <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    35dc:	8f 92       	push	r8
    35de:	9f 92       	push	r9
    35e0:	af 92       	push	r10
    35e2:	bf 92       	push	r11
    35e4:	cf 92       	push	r12
    35e6:	df 92       	push	r13
    35e8:	ef 92       	push	r14
    35ea:	ff 92       	push	r15
    35ec:	0f 93       	push	r16
    35ee:	1f 93       	push	r17
    35f0:	df 93       	push	r29
    35f2:	cf 93       	push	r28
    35f4:	cd b7       	in	r28, 0x3d	; 61
    35f6:	de b7       	in	r29, 0x3e	; 62
    35f8:	60 97       	sbiw	r28, 0x10	; 16
    35fa:	0f b6       	in	r0, 0x3f	; 63
    35fc:	f8 94       	cli
    35fe:	de bf       	out	0x3e, r29	; 62
    3600:	0f be       	out	0x3f, r0	; 63
    3602:	cd bf       	out	0x3d, r28	; 61
    3604:	9f 83       	std	Y+7, r25	; 0x07
    3606:	8e 83       	std	Y+6, r24	; 0x06
    3608:	79 87       	std	Y+9, r23	; 0x09
    360a:	68 87       	std	Y+8, r22	; 0x08
    360c:	5b 87       	std	Y+11, r21	; 0x0b
    360e:	4a 87       	std	Y+10, r20	; 0x0a
    3610:	3d 87       	std	Y+13, r19	; 0x0d
    3612:	2c 87       	std	Y+12, r18	; 0x0c
    3614:	0e 87       	std	Y+14, r16	; 0x0e
    3616:	f8 8a       	std	Y+16, r15	; 0x10
    3618:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    361a:	8a 85       	ldd	r24, Y+10	; 0x0a
    361c:	9b 85       	ldd	r25, Y+11	; 0x0b
    361e:	0e 94 bc 0c 	call	0x1978	; 0x1978 <pvPortMalloc>
    3622:	9a 83       	std	Y+2, r25	; 0x02
    3624:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3626:	89 81       	ldd	r24, Y+1	; 0x01
    3628:	9a 81       	ldd	r25, Y+2	; 0x02
    362a:	00 97       	sbiw	r24, 0x00	; 0
    362c:	b1 f0       	breq	.+44     	; 0x365a <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    362e:	8a e2       	ldi	r24, 0x2A	; 42
    3630:	90 e0       	ldi	r25, 0x00	; 0
    3632:	0e 94 bc 0c 	call	0x1978	; 0x1978 <pvPortMalloc>
    3636:	9d 83       	std	Y+5, r25	; 0x05
    3638:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    363a:	8c 81       	ldd	r24, Y+4	; 0x04
    363c:	9d 81       	ldd	r25, Y+5	; 0x05
    363e:	00 97       	sbiw	r24, 0x00	; 0
    3640:	39 f0       	breq	.+14     	; 0x3650 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3642:	ec 81       	ldd	r30, Y+4	; 0x04
    3644:	fd 81       	ldd	r31, Y+5	; 0x05
    3646:	89 81       	ldd	r24, Y+1	; 0x01
    3648:	9a 81       	ldd	r25, Y+2	; 0x02
    364a:	90 8f       	std	Z+24, r25	; 0x18
    364c:	87 8b       	std	Z+23, r24	; 0x17
    364e:	07 c0       	rjmp	.+14     	; 0x365e <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3650:	89 81       	ldd	r24, Y+1	; 0x01
    3652:	9a 81       	ldd	r25, Y+2	; 0x02
    3654:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <vPortFree>
    3658:	02 c0       	rjmp	.+4      	; 0x365e <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    365a:	1d 82       	std	Y+5, r1	; 0x05
    365c:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    365e:	8c 81       	ldd	r24, Y+4	; 0x04
    3660:	9d 81       	ldd	r25, Y+5	; 0x05
    3662:	00 97       	sbiw	r24, 0x00	; 0
    3664:	e9 f0       	breq	.+58     	; 0x36a0 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3666:	8a 85       	ldd	r24, Y+10	; 0x0a
    3668:	9b 85       	ldd	r25, Y+11	; 0x0b
    366a:	9c 01       	movw	r18, r24
    366c:	40 e0       	ldi	r20, 0x00	; 0
    366e:	50 e0       	ldi	r21, 0x00	; 0
    3670:	8e 81       	ldd	r24, Y+6	; 0x06
    3672:	9f 81       	ldd	r25, Y+7	; 0x07
    3674:	68 85       	ldd	r22, Y+8	; 0x08
    3676:	79 85       	ldd	r23, Y+9	; 0x09
    3678:	ec 85       	ldd	r30, Y+12	; 0x0c
    367a:	fd 85       	ldd	r31, Y+13	; 0x0d
    367c:	af 85       	ldd	r26, Y+15	; 0x0f
    367e:	b8 89       	ldd	r27, Y+16	; 0x10
    3680:	ac 80       	ldd	r10, Y+4	; 0x04
    3682:	bd 80       	ldd	r11, Y+5	; 0x05
    3684:	8f 01       	movw	r16, r30
    3686:	ee 84       	ldd	r14, Y+14	; 0x0e
    3688:	6d 01       	movw	r12, r26
    368a:	88 24       	eor	r8, r8
    368c:	99 24       	eor	r9, r9
    368e:	0e 94 66 1b 	call	0x36cc	; 0x36cc <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3692:	8c 81       	ldd	r24, Y+4	; 0x04
    3694:	9d 81       	ldd	r25, Y+5	; 0x05
    3696:	0e 94 21 1c 	call	0x3842	; 0x3842 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    369a:	81 e0       	ldi	r24, 0x01	; 1
    369c:	8b 83       	std	Y+3, r24	; 0x03
    369e:	02 c0       	rjmp	.+4      	; 0x36a4 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    36a0:	8f ef       	ldi	r24, 0xFF	; 255
    36a2:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    36a4:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    36a6:	60 96       	adiw	r28, 0x10	; 16
    36a8:	0f b6       	in	r0, 0x3f	; 63
    36aa:	f8 94       	cli
    36ac:	de bf       	out	0x3e, r29	; 62
    36ae:	0f be       	out	0x3f, r0	; 63
    36b0:	cd bf       	out	0x3d, r28	; 61
    36b2:	cf 91       	pop	r28
    36b4:	df 91       	pop	r29
    36b6:	1f 91       	pop	r17
    36b8:	0f 91       	pop	r16
    36ba:	ff 90       	pop	r15
    36bc:	ef 90       	pop	r14
    36be:	df 90       	pop	r13
    36c0:	cf 90       	pop	r12
    36c2:	bf 90       	pop	r11
    36c4:	af 90       	pop	r10
    36c6:	9f 90       	pop	r9
    36c8:	8f 90       	pop	r8
    36ca:	08 95       	ret

000036cc <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    36cc:	8f 92       	push	r8
    36ce:	9f 92       	push	r9
    36d0:	af 92       	push	r10
    36d2:	bf 92       	push	r11
    36d4:	cf 92       	push	r12
    36d6:	df 92       	push	r13
    36d8:	ef 92       	push	r14
    36da:	0f 93       	push	r16
    36dc:	1f 93       	push	r17
    36de:	df 93       	push	r29
    36e0:	cf 93       	push	r28
    36e2:	cd b7       	in	r28, 0x3d	; 61
    36e4:	de b7       	in	r29, 0x3e	; 62
    36e6:	64 97       	sbiw	r28, 0x14	; 20
    36e8:	0f b6       	in	r0, 0x3f	; 63
    36ea:	f8 94       	cli
    36ec:	de bf       	out	0x3e, r29	; 62
    36ee:	0f be       	out	0x3f, r0	; 63
    36f0:	cd bf       	out	0x3d, r28	; 61
    36f2:	9d 83       	std	Y+5, r25	; 0x05
    36f4:	8c 83       	std	Y+4, r24	; 0x04
    36f6:	7f 83       	std	Y+7, r23	; 0x07
    36f8:	6e 83       	std	Y+6, r22	; 0x06
    36fa:	28 87       	std	Y+8, r18	; 0x08
    36fc:	39 87       	std	Y+9, r19	; 0x09
    36fe:	4a 87       	std	Y+10, r20	; 0x0a
    3700:	5b 87       	std	Y+11, r21	; 0x0b
    3702:	1d 87       	std	Y+13, r17	; 0x0d
    3704:	0c 87       	std	Y+12, r16	; 0x0c
    3706:	ee 86       	std	Y+14, r14	; 0x0e
    3708:	d8 8a       	std	Y+16, r13	; 0x10
    370a:	cf 86       	std	Y+15, r12	; 0x0f
    370c:	ba 8a       	std	Y+18, r11	; 0x12
    370e:	a9 8a       	std	Y+17, r10	; 0x11
    3710:	9c 8a       	std	Y+20, r9	; 0x14
    3712:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    3714:	e9 89       	ldd	r30, Y+17	; 0x11
    3716:	fa 89       	ldd	r31, Y+18	; 0x12
    3718:	27 89       	ldd	r18, Z+23	; 0x17
    371a:	30 8d       	ldd	r19, Z+24	; 0x18
    371c:	88 85       	ldd	r24, Y+8	; 0x08
    371e:	99 85       	ldd	r25, Y+9	; 0x09
    3720:	01 97       	sbiw	r24, 0x01	; 1
    3722:	82 0f       	add	r24, r18
    3724:	93 1f       	adc	r25, r19
    3726:	9b 83       	std	Y+3, r25	; 0x03
    3728:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    372a:	19 82       	std	Y+1, r1	; 0x01
    372c:	21 c0       	rjmp	.+66     	; 0x3770 <prvInitialiseNewTask+0xa4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    372e:	89 81       	ldd	r24, Y+1	; 0x01
    3730:	48 2f       	mov	r20, r24
    3732:	50 e0       	ldi	r21, 0x00	; 0
    3734:	89 81       	ldd	r24, Y+1	; 0x01
    3736:	28 2f       	mov	r18, r24
    3738:	30 e0       	ldi	r19, 0x00	; 0
    373a:	8e 81       	ldd	r24, Y+6	; 0x06
    373c:	9f 81       	ldd	r25, Y+7	; 0x07
    373e:	fc 01       	movw	r30, r24
    3740:	e2 0f       	add	r30, r18
    3742:	f3 1f       	adc	r31, r19
    3744:	20 81       	ld	r18, Z
    3746:	89 89       	ldd	r24, Y+17	; 0x11
    3748:	9a 89       	ldd	r25, Y+18	; 0x12
    374a:	84 0f       	add	r24, r20
    374c:	95 1f       	adc	r25, r21
    374e:	fc 01       	movw	r30, r24
    3750:	79 96       	adiw	r30, 0x19	; 25
    3752:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3754:	89 81       	ldd	r24, Y+1	; 0x01
    3756:	28 2f       	mov	r18, r24
    3758:	30 e0       	ldi	r19, 0x00	; 0
    375a:	8e 81       	ldd	r24, Y+6	; 0x06
    375c:	9f 81       	ldd	r25, Y+7	; 0x07
    375e:	fc 01       	movw	r30, r24
    3760:	e2 0f       	add	r30, r18
    3762:	f3 1f       	adc	r31, r19
    3764:	80 81       	ld	r24, Z
    3766:	88 23       	and	r24, r24
    3768:	31 f0       	breq	.+12     	; 0x3776 <prvInitialiseNewTask+0xaa>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    376a:	89 81       	ldd	r24, Y+1	; 0x01
    376c:	8f 5f       	subi	r24, 0xFF	; 255
    376e:	89 83       	std	Y+1, r24	; 0x01
    3770:	89 81       	ldd	r24, Y+1	; 0x01
    3772:	8a 30       	cpi	r24, 0x0A	; 10
    3774:	e0 f2       	brcs	.-72     	; 0x372e <prvInitialiseNewTask+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3776:	e9 89       	ldd	r30, Y+17	; 0x11
    3778:	fa 89       	ldd	r31, Y+18	; 0x12
    377a:	12 a2       	std	Z+34, r1	; 0x22

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    377c:	8e 85       	ldd	r24, Y+14	; 0x0e
    377e:	85 30       	cpi	r24, 0x05	; 5
    3780:	10 f0       	brcs	.+4      	; 0x3786 <prvInitialiseNewTask+0xba>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3782:	84 e0       	ldi	r24, 0x04	; 4
    3784:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3786:	e9 89       	ldd	r30, Y+17	; 0x11
    3788:	fa 89       	ldd	r31, Y+18	; 0x12
    378a:	8e 85       	ldd	r24, Y+14	; 0x0e
    378c:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    378e:	e9 89       	ldd	r30, Y+17	; 0x11
    3790:	fa 89       	ldd	r31, Y+18	; 0x12
    3792:	8e 85       	ldd	r24, Y+14	; 0x0e
    3794:	83 a3       	std	Z+35, r24	; 0x23
		pxNewTCB->uxMutexesHeld = 0;
    3796:	e9 89       	ldd	r30, Y+17	; 0x11
    3798:	fa 89       	ldd	r31, Y+18	; 0x12
    379a:	14 a2       	std	Z+36, r1	; 0x24
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    379c:	89 89       	ldd	r24, Y+17	; 0x11
    379e:	9a 89       	ldd	r25, Y+18	; 0x12
    37a0:	02 96       	adiw	r24, 0x02	; 2
    37a2:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    37a6:	89 89       	ldd	r24, Y+17	; 0x11
    37a8:	9a 89       	ldd	r25, Y+18	; 0x12
    37aa:	0c 96       	adiw	r24, 0x0c	; 12
    37ac:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    37b0:	e9 89       	ldd	r30, Y+17	; 0x11
    37b2:	fa 89       	ldd	r31, Y+18	; 0x12
    37b4:	89 89       	ldd	r24, Y+17	; 0x11
    37b6:	9a 89       	ldd	r25, Y+18	; 0x12
    37b8:	91 87       	std	Z+9, r25	; 0x09
    37ba:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    37bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    37be:	28 2f       	mov	r18, r24
    37c0:	30 e0       	ldi	r19, 0x00	; 0
    37c2:	85 e0       	ldi	r24, 0x05	; 5
    37c4:	90 e0       	ldi	r25, 0x00	; 0
    37c6:	82 1b       	sub	r24, r18
    37c8:	93 0b       	sbc	r25, r19
    37ca:	e9 89       	ldd	r30, Y+17	; 0x11
    37cc:	fa 89       	ldd	r31, Y+18	; 0x12
    37ce:	95 87       	std	Z+13, r25	; 0x0d
    37d0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    37d2:	e9 89       	ldd	r30, Y+17	; 0x11
    37d4:	fa 89       	ldd	r31, Y+18	; 0x12
    37d6:	89 89       	ldd	r24, Y+17	; 0x11
    37d8:	9a 89       	ldd	r25, Y+18	; 0x12
    37da:	93 8b       	std	Z+19, r25	; 0x13
    37dc:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    37de:	e9 89       	ldd	r30, Y+17	; 0x11
    37e0:	fa 89       	ldd	r31, Y+18	; 0x12
    37e2:	15 a2       	std	Z+37, r1	; 0x25
    37e4:	16 a2       	std	Z+38, r1	; 0x26
    37e6:	17 a2       	std	Z+39, r1	; 0x27
    37e8:	10 a6       	std	Z+40, r1	; 0x28
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    37ea:	e9 89       	ldd	r30, Y+17	; 0x11
    37ec:	fa 89       	ldd	r31, Y+18	; 0x12
    37ee:	11 a6       	std	Z+41, r1	; 0x29
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    37f0:	8a 81       	ldd	r24, Y+2	; 0x02
    37f2:	9b 81       	ldd	r25, Y+3	; 0x03
    37f4:	2c 81       	ldd	r18, Y+4	; 0x04
    37f6:	3d 81       	ldd	r19, Y+5	; 0x05
    37f8:	4c 85       	ldd	r20, Y+12	; 0x0c
    37fa:	5d 85       	ldd	r21, Y+13	; 0x0d
    37fc:	b9 01       	movw	r22, r18
    37fe:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <pxPortInitialiseStack>
    3802:	e9 89       	ldd	r30, Y+17	; 0x11
    3804:	fa 89       	ldd	r31, Y+18	; 0x12
    3806:	91 83       	std	Z+1, r25	; 0x01
    3808:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    380a:	8f 85       	ldd	r24, Y+15	; 0x0f
    380c:	98 89       	ldd	r25, Y+16	; 0x10
    380e:	00 97       	sbiw	r24, 0x00	; 0
    3810:	31 f0       	breq	.+12     	; 0x381e <prvInitialiseNewTask+0x152>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3812:	ef 85       	ldd	r30, Y+15	; 0x0f
    3814:	f8 89       	ldd	r31, Y+16	; 0x10
    3816:	89 89       	ldd	r24, Y+17	; 0x11
    3818:	9a 89       	ldd	r25, Y+18	; 0x12
    381a:	91 83       	std	Z+1, r25	; 0x01
    381c:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    381e:	64 96       	adiw	r28, 0x14	; 20
    3820:	0f b6       	in	r0, 0x3f	; 63
    3822:	f8 94       	cli
    3824:	de bf       	out	0x3e, r29	; 62
    3826:	0f be       	out	0x3f, r0	; 63
    3828:	cd bf       	out	0x3d, r28	; 61
    382a:	cf 91       	pop	r28
    382c:	df 91       	pop	r29
    382e:	1f 91       	pop	r17
    3830:	0f 91       	pop	r16
    3832:	ef 90       	pop	r14
    3834:	df 90       	pop	r13
    3836:	cf 90       	pop	r12
    3838:	bf 90       	pop	r11
    383a:	af 90       	pop	r10
    383c:	9f 90       	pop	r9
    383e:	8f 90       	pop	r8
    3840:	08 95       	ret

00003842 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3842:	df 93       	push	r29
    3844:	cf 93       	push	r28
    3846:	00 d0       	rcall	.+0      	; 0x3848 <prvAddNewTaskToReadyList+0x6>
    3848:	cd b7       	in	r28, 0x3d	; 61
    384a:	de b7       	in	r29, 0x3e	; 62
    384c:	9a 83       	std	Y+2, r25	; 0x02
    384e:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3850:	0f b6       	in	r0, 0x3f	; 63
    3852:	f8 94       	cli
    3854:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3856:	80 91 a2 03 	lds	r24, 0x03A2
    385a:	8f 5f       	subi	r24, 0xFF	; 255
    385c:	80 93 a2 03 	sts	0x03A2, r24
		if( pxCurrentTCB == NULL )
    3860:	80 91 9f 03 	lds	r24, 0x039F
    3864:	90 91 a0 03 	lds	r25, 0x03A0
    3868:	00 97       	sbiw	r24, 0x00	; 0
    386a:	69 f4       	brne	.+26     	; 0x3886 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    386c:	89 81       	ldd	r24, Y+1	; 0x01
    386e:	9a 81       	ldd	r25, Y+2	; 0x02
    3870:	90 93 a0 03 	sts	0x03A0, r25
    3874:	80 93 9f 03 	sts	0x039F, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3878:	80 91 a2 03 	lds	r24, 0x03A2
    387c:	81 30       	cpi	r24, 0x01	; 1
    387e:	b9 f4       	brne	.+46     	; 0x38ae <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3880:	0e 94 7c 24 	call	0x48f8	; 0x48f8 <prvInitialiseTaskLists>
    3884:	14 c0       	rjmp	.+40     	; 0x38ae <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3886:	80 91 a6 03 	lds	r24, 0x03A6
    388a:	88 23       	and	r24, r24
    388c:	81 f4       	brne	.+32     	; 0x38ae <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    388e:	e0 91 9f 03 	lds	r30, 0x039F
    3892:	f0 91 a0 03 	lds	r31, 0x03A0
    3896:	96 89       	ldd	r25, Z+22	; 0x16
    3898:	e9 81       	ldd	r30, Y+1	; 0x01
    389a:	fa 81       	ldd	r31, Y+2	; 0x02
    389c:	86 89       	ldd	r24, Z+22	; 0x16
    389e:	89 17       	cp	r24, r25
    38a0:	30 f0       	brcs	.+12     	; 0x38ae <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    38a2:	89 81       	ldd	r24, Y+1	; 0x01
    38a4:	9a 81       	ldd	r25, Y+2	; 0x02
    38a6:	90 93 a0 03 	sts	0x03A0, r25
    38aa:	80 93 9f 03 	sts	0x039F, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    38ae:	80 91 aa 03 	lds	r24, 0x03AA
    38b2:	8f 5f       	subi	r24, 0xFF	; 255
    38b4:	80 93 aa 03 	sts	0x03AA, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    38b8:	e9 81       	ldd	r30, Y+1	; 0x01
    38ba:	fa 81       	ldd	r31, Y+2	; 0x02
    38bc:	96 89       	ldd	r25, Z+22	; 0x16
    38be:	80 91 a5 03 	lds	r24, 0x03A5
    38c2:	89 17       	cp	r24, r25
    38c4:	28 f4       	brcc	.+10     	; 0x38d0 <prvAddNewTaskToReadyList+0x8e>
    38c6:	e9 81       	ldd	r30, Y+1	; 0x01
    38c8:	fa 81       	ldd	r31, Y+2	; 0x02
    38ca:	86 89       	ldd	r24, Z+22	; 0x16
    38cc:	80 93 a5 03 	sts	0x03A5, r24
    38d0:	e9 81       	ldd	r30, Y+1	; 0x01
    38d2:	fa 81       	ldd	r31, Y+2	; 0x02
    38d4:	86 89       	ldd	r24, Z+22	; 0x16
    38d6:	28 2f       	mov	r18, r24
    38d8:	30 e0       	ldi	r19, 0x00	; 0
    38da:	c9 01       	movw	r24, r18
    38dc:	88 0f       	add	r24, r24
    38de:	99 1f       	adc	r25, r25
    38e0:	88 0f       	add	r24, r24
    38e2:	99 1f       	adc	r25, r25
    38e4:	88 0f       	add	r24, r24
    38e6:	99 1f       	adc	r25, r25
    38e8:	82 0f       	add	r24, r18
    38ea:	93 1f       	adc	r25, r19
    38ec:	ac 01       	movw	r20, r24
    38ee:	40 55       	subi	r20, 0x50	; 80
    38f0:	5c 4f       	sbci	r21, 0xFC	; 252
    38f2:	89 81       	ldd	r24, Y+1	; 0x01
    38f4:	9a 81       	ldd	r25, Y+2	; 0x02
    38f6:	9c 01       	movw	r18, r24
    38f8:	2e 5f       	subi	r18, 0xFE	; 254
    38fa:	3f 4f       	sbci	r19, 0xFF	; 255
    38fc:	ca 01       	movw	r24, r20
    38fe:	b9 01       	movw	r22, r18
    3900:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3904:	0f 90       	pop	r0
    3906:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3908:	80 91 a6 03 	lds	r24, 0x03A6
    390c:	88 23       	and	r24, r24
    390e:	61 f0       	breq	.+24     	; 0x3928 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3910:	e0 91 9f 03 	lds	r30, 0x039F
    3914:	f0 91 a0 03 	lds	r31, 0x03A0
    3918:	96 89       	ldd	r25, Z+22	; 0x16
    391a:	e9 81       	ldd	r30, Y+1	; 0x01
    391c:	fa 81       	ldd	r31, Y+2	; 0x02
    391e:	86 89       	ldd	r24, Z+22	; 0x16
    3920:	98 17       	cp	r25, r24
    3922:	10 f4       	brcc	.+4      	; 0x3928 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3924:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3928:	0f 90       	pop	r0
    392a:	0f 90       	pop	r0
    392c:	cf 91       	pop	r28
    392e:	df 91       	pop	r29
    3930:	08 95       	ret

00003932 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3932:	df 93       	push	r29
    3934:	cf 93       	push	r28
    3936:	00 d0       	rcall	.+0      	; 0x3938 <vTaskDelete+0x6>
    3938:	00 d0       	rcall	.+0      	; 0x393a <vTaskDelete+0x8>
    393a:	00 d0       	rcall	.+0      	; 0x393c <vTaskDelete+0xa>
    393c:	cd b7       	in	r28, 0x3d	; 61
    393e:	de b7       	in	r29, 0x3e	; 62
    3940:	9c 83       	std	Y+4, r25	; 0x04
    3942:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3944:	0f b6       	in	r0, 0x3f	; 63
    3946:	f8 94       	cli
    3948:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    394a:	8b 81       	ldd	r24, Y+3	; 0x03
    394c:	9c 81       	ldd	r25, Y+4	; 0x04
    394e:	00 97       	sbiw	r24, 0x00	; 0
    3950:	39 f4       	brne	.+14     	; 0x3960 <vTaskDelete+0x2e>
    3952:	80 91 9f 03 	lds	r24, 0x039F
    3956:	90 91 a0 03 	lds	r25, 0x03A0
    395a:	9e 83       	std	Y+6, r25	; 0x06
    395c:	8d 83       	std	Y+5, r24	; 0x05
    395e:	04 c0       	rjmp	.+8      	; 0x3968 <vTaskDelete+0x36>
    3960:	8b 81       	ldd	r24, Y+3	; 0x03
    3962:	9c 81       	ldd	r25, Y+4	; 0x04
    3964:	9e 83       	std	Y+6, r25	; 0x06
    3966:	8d 83       	std	Y+5, r24	; 0x05
    3968:	8d 81       	ldd	r24, Y+5	; 0x05
    396a:	9e 81       	ldd	r25, Y+6	; 0x06
    396c:	9a 83       	std	Y+2, r25	; 0x02
    396e:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	9a 81       	ldd	r25, Y+2	; 0x02
    3974:	02 96       	adiw	r24, 0x02	; 2
    3976:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    397a:	e9 81       	ldd	r30, Y+1	; 0x01
    397c:	fa 81       	ldd	r31, Y+2	; 0x02
    397e:	84 89       	ldd	r24, Z+20	; 0x14
    3980:	95 89       	ldd	r25, Z+21	; 0x15
    3982:	00 97       	sbiw	r24, 0x00	; 0
    3984:	29 f0       	breq	.+10     	; 0x3990 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3986:	89 81       	ldd	r24, Y+1	; 0x01
    3988:	9a 81       	ldd	r25, Y+2	; 0x02
    398a:	0c 96       	adiw	r24, 0x0c	; 12
    398c:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    3990:	80 91 aa 03 	lds	r24, 0x03AA
    3994:	8f 5f       	subi	r24, 0xFF	; 255
    3996:	80 93 aa 03 	sts	0x03AA, r24

			if( pxTCB == pxCurrentTCB )
    399a:	20 91 9f 03 	lds	r18, 0x039F
    399e:	30 91 a0 03 	lds	r19, 0x03A0
    39a2:	89 81       	ldd	r24, Y+1	; 0x01
    39a4:	9a 81       	ldd	r25, Y+2	; 0x02
    39a6:	82 17       	cp	r24, r18
    39a8:	93 07       	cpc	r25, r19
    39aa:	81 f4       	brne	.+32     	; 0x39cc <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    39ac:	89 81       	ldd	r24, Y+1	; 0x01
    39ae:	9a 81       	ldd	r25, Y+2	; 0x02
    39b0:	9c 01       	movw	r18, r24
    39b2:	2e 5f       	subi	r18, 0xFE	; 254
    39b4:	3f 4f       	sbci	r19, 0xFF	; 255
    39b6:	8c ef       	ldi	r24, 0xFC	; 252
    39b8:	93 e0       	ldi	r25, 0x03	; 3
    39ba:	b9 01       	movw	r22, r18
    39bc:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    39c0:	80 91 a1 03 	lds	r24, 0x03A1
    39c4:	8f 5f       	subi	r24, 0xFF	; 255
    39c6:	80 93 a1 03 	sts	0x03A1, r24
    39ca:	0b c0       	rjmp	.+22     	; 0x39e2 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    39cc:	80 91 a2 03 	lds	r24, 0x03A2
    39d0:	81 50       	subi	r24, 0x01	; 1
    39d2:	80 93 a2 03 	sts	0x03A2, r24
				prvDeleteTCB( pxTCB );
    39d6:	89 81       	ldd	r24, Y+1	; 0x01
    39d8:	9a 81       	ldd	r25, Y+2	; 0x02
    39da:	0e 94 fc 24 	call	0x49f8	; 0x49f8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    39de:	0e 94 12 25 	call	0x4a24	; 0x4a24 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    39e2:	0f 90       	pop	r0
    39e4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    39e6:	80 91 a6 03 	lds	r24, 0x03A6
    39ea:	88 23       	and	r24, r24
    39ec:	59 f0       	breq	.+22     	; 0x3a04 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    39ee:	20 91 9f 03 	lds	r18, 0x039F
    39f2:	30 91 a0 03 	lds	r19, 0x03A0
    39f6:	89 81       	ldd	r24, Y+1	; 0x01
    39f8:	9a 81       	ldd	r25, Y+2	; 0x02
    39fa:	82 17       	cp	r24, r18
    39fc:	93 07       	cpc	r25, r19
    39fe:	11 f4       	brne	.+4      	; 0x3a04 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3a00:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3a04:	26 96       	adiw	r28, 0x06	; 6
    3a06:	0f b6       	in	r0, 0x3f	; 63
    3a08:	f8 94       	cli
    3a0a:	de bf       	out	0x3e, r29	; 62
    3a0c:	0f be       	out	0x3f, r0	; 63
    3a0e:	cd bf       	out	0x3d, r28	; 61
    3a10:	cf 91       	pop	r28
    3a12:	df 91       	pop	r29
    3a14:	08 95       	ret

00003a16 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    3a16:	df 93       	push	r29
    3a18:	cf 93       	push	r28
    3a1a:	cd b7       	in	r28, 0x3d	; 61
    3a1c:	de b7       	in	r29, 0x3e	; 62
    3a1e:	2a 97       	sbiw	r28, 0x0a	; 10
    3a20:	0f b6       	in	r0, 0x3f	; 63
    3a22:	f8 94       	cli
    3a24:	de bf       	out	0x3e, r29	; 62
    3a26:	0f be       	out	0x3f, r0	; 63
    3a28:	cd bf       	out	0x3d, r28	; 61
    3a2a:	98 87       	std	Y+8, r25	; 0x08
    3a2c:	8f 83       	std	Y+7, r24	; 0x07
    3a2e:	7a 87       	std	Y+10, r23	; 0x0a
    3a30:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3a32:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    3a34:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    3a38:	80 91 a3 03 	lds	r24, 0x03A3
    3a3c:	90 91 a4 03 	lds	r25, 0x03A4
    3a40:	9a 83       	std	Y+2, r25	; 0x02
    3a42:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3a44:	ef 81       	ldd	r30, Y+7	; 0x07
    3a46:	f8 85       	ldd	r31, Y+8	; 0x08
    3a48:	20 81       	ld	r18, Z
    3a4a:	31 81       	ldd	r19, Z+1	; 0x01
    3a4c:	89 85       	ldd	r24, Y+9	; 0x09
    3a4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a50:	82 0f       	add	r24, r18
    3a52:	93 1f       	adc	r25, r19
    3a54:	9e 83       	std	Y+6, r25	; 0x06
    3a56:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    3a58:	ef 81       	ldd	r30, Y+7	; 0x07
    3a5a:	f8 85       	ldd	r31, Y+8	; 0x08
    3a5c:	20 81       	ld	r18, Z
    3a5e:	31 81       	ldd	r19, Z+1	; 0x01
    3a60:	89 81       	ldd	r24, Y+1	; 0x01
    3a62:	9a 81       	ldd	r25, Y+2	; 0x02
    3a64:	82 17       	cp	r24, r18
    3a66:	93 07       	cpc	r25, r19
    3a68:	98 f4       	brcc	.+38     	; 0x3a90 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3a6a:	ef 81       	ldd	r30, Y+7	; 0x07
    3a6c:	f8 85       	ldd	r31, Y+8	; 0x08
    3a6e:	20 81       	ld	r18, Z
    3a70:	31 81       	ldd	r19, Z+1	; 0x01
    3a72:	8d 81       	ldd	r24, Y+5	; 0x05
    3a74:	9e 81       	ldd	r25, Y+6	; 0x06
    3a76:	82 17       	cp	r24, r18
    3a78:	93 07       	cpc	r25, r19
    3a7a:	e0 f4       	brcc	.+56     	; 0x3ab4 <vTaskDelayUntil+0x9e>
    3a7c:	2d 81       	ldd	r18, Y+5	; 0x05
    3a7e:	3e 81       	ldd	r19, Y+6	; 0x06
    3a80:	89 81       	ldd	r24, Y+1	; 0x01
    3a82:	9a 81       	ldd	r25, Y+2	; 0x02
    3a84:	82 17       	cp	r24, r18
    3a86:	93 07       	cpc	r25, r19
    3a88:	a8 f4       	brcc	.+42     	; 0x3ab4 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3a8a:	81 e0       	ldi	r24, 0x01	; 1
    3a8c:	8b 83       	std	Y+3, r24	; 0x03
    3a8e:	12 c0       	rjmp	.+36     	; 0x3ab4 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    3a90:	ef 81       	ldd	r30, Y+7	; 0x07
    3a92:	f8 85       	ldd	r31, Y+8	; 0x08
    3a94:	20 81       	ld	r18, Z
    3a96:	31 81       	ldd	r19, Z+1	; 0x01
    3a98:	8d 81       	ldd	r24, Y+5	; 0x05
    3a9a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a9c:	82 17       	cp	r24, r18
    3a9e:	93 07       	cpc	r25, r19
    3aa0:	38 f0       	brcs	.+14     	; 0x3ab0 <vTaskDelayUntil+0x9a>
    3aa2:	2d 81       	ldd	r18, Y+5	; 0x05
    3aa4:	3e 81       	ldd	r19, Y+6	; 0x06
    3aa6:	89 81       	ldd	r24, Y+1	; 0x01
    3aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    3aaa:	82 17       	cp	r24, r18
    3aac:	93 07       	cpc	r25, r19
    3aae:	10 f4       	brcc	.+4      	; 0x3ab4 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3ab0:	81 e0       	ldi	r24, 0x01	; 1
    3ab2:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3ab4:	ef 81       	ldd	r30, Y+7	; 0x07
    3ab6:	f8 85       	ldd	r31, Y+8	; 0x08
    3ab8:	8d 81       	ldd	r24, Y+5	; 0x05
    3aba:	9e 81       	ldd	r25, Y+6	; 0x06
    3abc:	91 83       	std	Z+1, r25	; 0x01
    3abe:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac2:	88 23       	and	r24, r24
    3ac4:	49 f0       	breq	.+18     	; 0x3ad8 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    3ac8:	9e 81       	ldd	r25, Y+6	; 0x06
    3aca:	29 81       	ldd	r18, Y+1	; 0x01
    3acc:	3a 81       	ldd	r19, Y+2	; 0x02
    3ace:	82 1b       	sub	r24, r18
    3ad0:	93 0b       	sbc	r25, r19
    3ad2:	60 e0       	ldi	r22, 0x00	; 0
    3ad4:	0e 94 35 2a 	call	0x546a	; 0x546a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3ad8:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    3adc:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3ade:	8c 81       	ldd	r24, Y+4	; 0x04
    3ae0:	88 23       	and	r24, r24
    3ae2:	11 f4       	brne	.+4      	; 0x3ae8 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    3ae4:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3ae8:	2a 96       	adiw	r28, 0x0a	; 10
    3aea:	0f b6       	in	r0, 0x3f	; 63
    3aec:	f8 94       	cli
    3aee:	de bf       	out	0x3e, r29	; 62
    3af0:	0f be       	out	0x3f, r0	; 63
    3af2:	cd bf       	out	0x3d, r28	; 61
    3af4:	cf 91       	pop	r28
    3af6:	df 91       	pop	r29
    3af8:	08 95       	ret

00003afa <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3afa:	df 93       	push	r29
    3afc:	cf 93       	push	r28
    3afe:	00 d0       	rcall	.+0      	; 0x3b00 <vTaskDelay+0x6>
    3b00:	0f 92       	push	r0
    3b02:	cd b7       	in	r28, 0x3d	; 61
    3b04:	de b7       	in	r29, 0x3e	; 62
    3b06:	9b 83       	std	Y+3, r25	; 0x03
    3b08:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3b0a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3b0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b0e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b10:	00 97       	sbiw	r24, 0x00	; 0
    3b12:	51 f0       	breq	.+20     	; 0x3b28 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3b14:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3b18:	8a 81       	ldd	r24, Y+2	; 0x02
    3b1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b1c:	60 e0       	ldi	r22, 0x00	; 0
    3b1e:	0e 94 35 2a 	call	0x546a	; 0x546a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3b22:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>
    3b26:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3b28:	89 81       	ldd	r24, Y+1	; 0x01
    3b2a:	88 23       	and	r24, r24
    3b2c:	11 f4       	brne	.+4      	; 0x3b32 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3b2e:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3b32:	0f 90       	pop	r0
    3b34:	0f 90       	pop	r0
    3b36:	0f 90       	pop	r0
    3b38:	cf 91       	pop	r28
    3b3a:	df 91       	pop	r29
    3b3c:	08 95       	ret

00003b3e <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    3b3e:	df 93       	push	r29
    3b40:	cf 93       	push	r28
    3b42:	cd b7       	in	r28, 0x3d	; 61
    3b44:	de b7       	in	r29, 0x3e	; 62
    3b46:	27 97       	sbiw	r28, 0x07	; 7
    3b48:	0f b6       	in	r0, 0x3f	; 63
    3b4a:	f8 94       	cli
    3b4c:	de bf       	out	0x3e, r29	; 62
    3b4e:	0f be       	out	0x3f, r0	; 63
    3b50:	cd bf       	out	0x3d, r28	; 61
    3b52:	9d 83       	std	Y+5, r25	; 0x05
    3b54:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    3b56:	0f b6       	in	r0, 0x3f	; 63
    3b58:	f8 94       	cli
    3b5a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3b5c:	8c 81       	ldd	r24, Y+4	; 0x04
    3b5e:	9d 81       	ldd	r25, Y+5	; 0x05
    3b60:	00 97       	sbiw	r24, 0x00	; 0
    3b62:	39 f4       	brne	.+14     	; 0x3b72 <uxTaskPriorityGet+0x34>
    3b64:	80 91 9f 03 	lds	r24, 0x039F
    3b68:	90 91 a0 03 	lds	r25, 0x03A0
    3b6c:	9f 83       	std	Y+7, r25	; 0x07
    3b6e:	8e 83       	std	Y+6, r24	; 0x06
    3b70:	04 c0       	rjmp	.+8      	; 0x3b7a <uxTaskPriorityGet+0x3c>
    3b72:	8c 81       	ldd	r24, Y+4	; 0x04
    3b74:	9d 81       	ldd	r25, Y+5	; 0x05
    3b76:	9f 83       	std	Y+7, r25	; 0x07
    3b78:	8e 83       	std	Y+6, r24	; 0x06
    3b7a:	8e 81       	ldd	r24, Y+6	; 0x06
    3b7c:	9f 81       	ldd	r25, Y+7	; 0x07
    3b7e:	9b 83       	std	Y+3, r25	; 0x03
    3b80:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    3b82:	ea 81       	ldd	r30, Y+2	; 0x02
    3b84:	fb 81       	ldd	r31, Y+3	; 0x03
    3b86:	86 89       	ldd	r24, Z+22	; 0x16
    3b88:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    3b8a:	0f 90       	pop	r0
    3b8c:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    3b8e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3b90:	27 96       	adiw	r28, 0x07	; 7
    3b92:	0f b6       	in	r0, 0x3f	; 63
    3b94:	f8 94       	cli
    3b96:	de bf       	out	0x3e, r29	; 62
    3b98:	0f be       	out	0x3f, r0	; 63
    3b9a:	cd bf       	out	0x3d, r28	; 61
    3b9c:	cf 91       	pop	r28
    3b9e:	df 91       	pop	r29
    3ba0:	08 95       	ret

00003ba2 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
    3ba2:	df 93       	push	r29
    3ba4:	cf 93       	push	r28
    3ba6:	cd b7       	in	r28, 0x3d	; 61
    3ba8:	de b7       	in	r29, 0x3e	; 62
    3baa:	28 97       	sbiw	r28, 0x08	; 8
    3bac:	0f b6       	in	r0, 0x3f	; 63
    3bae:	f8 94       	cli
    3bb0:	de bf       	out	0x3e, r29	; 62
    3bb2:	0f be       	out	0x3f, r0	; 63
    3bb4:	cd bf       	out	0x3d, r28	; 61
    3bb6:	9e 83       	std	Y+6, r25	; 0x06
    3bb8:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    3bba:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3bbc:	8d 81       	ldd	r24, Y+5	; 0x05
    3bbe:	9e 81       	ldd	r25, Y+6	; 0x06
    3bc0:	00 97       	sbiw	r24, 0x00	; 0
    3bc2:	39 f4       	brne	.+14     	; 0x3bd2 <uxTaskPriorityGetFromISR+0x30>
    3bc4:	80 91 9f 03 	lds	r24, 0x039F
    3bc8:	90 91 a0 03 	lds	r25, 0x03A0
    3bcc:	98 87       	std	Y+8, r25	; 0x08
    3bce:	8f 83       	std	Y+7, r24	; 0x07
    3bd0:	04 c0       	rjmp	.+8      	; 0x3bda <uxTaskPriorityGetFromISR+0x38>
    3bd2:	8d 81       	ldd	r24, Y+5	; 0x05
    3bd4:	9e 81       	ldd	r25, Y+6	; 0x06
    3bd6:	98 87       	std	Y+8, r25	; 0x08
    3bd8:	8f 83       	std	Y+7, r24	; 0x07
    3bda:	8f 81       	ldd	r24, Y+7	; 0x07
    3bdc:	98 85       	ldd	r25, Y+8	; 0x08
    3bde:	9c 83       	std	Y+4, r25	; 0x04
    3be0:	8b 83       	std	Y+3, r24	; 0x03
			uxReturn = pxTCB->uxPriority;
    3be2:	eb 81       	ldd	r30, Y+3	; 0x03
    3be4:	fc 81       	ldd	r31, Y+4	; 0x04
    3be6:	86 89       	ldd	r24, Z+22	; 0x16
    3be8:	8a 83       	std	Y+2, r24	; 0x02
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    3bea:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    3bec:	28 96       	adiw	r28, 0x08	; 8
    3bee:	0f b6       	in	r0, 0x3f	; 63
    3bf0:	f8 94       	cli
    3bf2:	de bf       	out	0x3e, r29	; 62
    3bf4:	0f be       	out	0x3f, r0	; 63
    3bf6:	cd bf       	out	0x3d, r28	; 61
    3bf8:	cf 91       	pop	r28
    3bfa:	df 91       	pop	r29
    3bfc:	08 95       	ret

00003bfe <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    3bfe:	df 93       	push	r29
    3c00:	cf 93       	push	r28
    3c02:	cd b7       	in	r28, 0x3d	; 61
    3c04:	de b7       	in	r29, 0x3e	; 62
    3c06:	2a 97       	sbiw	r28, 0x0a	; 10
    3c08:	0f b6       	in	r0, 0x3f	; 63
    3c0a:	f8 94       	cli
    3c0c:	de bf       	out	0x3e, r29	; 62
    3c0e:	0f be       	out	0x3f, r0	; 63
    3c10:	cd bf       	out	0x3d, r28	; 61
    3c12:	9f 83       	std	Y+7, r25	; 0x07
    3c14:	8e 83       	std	Y+6, r24	; 0x06
    3c16:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    3c18:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3c1a:	88 85       	ldd	r24, Y+8	; 0x08
    3c1c:	85 30       	cpi	r24, 0x05	; 5
    3c1e:	10 f0       	brcs	.+4      	; 0x3c24 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3c20:	84 e0       	ldi	r24, 0x04	; 4
    3c22:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    3c24:	0f b6       	in	r0, 0x3f	; 63
    3c26:	f8 94       	cli
    3c28:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3c2a:	8e 81       	ldd	r24, Y+6	; 0x06
    3c2c:	9f 81       	ldd	r25, Y+7	; 0x07
    3c2e:	00 97       	sbiw	r24, 0x00	; 0
    3c30:	39 f4       	brne	.+14     	; 0x3c40 <vTaskPrioritySet+0x42>
    3c32:	80 91 9f 03 	lds	r24, 0x039F
    3c36:	90 91 a0 03 	lds	r25, 0x03A0
    3c3a:	9a 87       	std	Y+10, r25	; 0x0a
    3c3c:	89 87       	std	Y+9, r24	; 0x09
    3c3e:	04 c0       	rjmp	.+8      	; 0x3c48 <vTaskPrioritySet+0x4a>
    3c40:	8e 81       	ldd	r24, Y+6	; 0x06
    3c42:	9f 81       	ldd	r25, Y+7	; 0x07
    3c44:	9a 87       	std	Y+10, r25	; 0x0a
    3c46:	89 87       	std	Y+9, r24	; 0x09
    3c48:	89 85       	ldd	r24, Y+9	; 0x09
    3c4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c4c:	9d 83       	std	Y+5, r25	; 0x05
    3c4e:	8c 83       	std	Y+4, r24	; 0x04

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    3c50:	ec 81       	ldd	r30, Y+4	; 0x04
    3c52:	fd 81       	ldd	r31, Y+5	; 0x05
    3c54:	83 a1       	ldd	r24, Z+35	; 0x23
    3c56:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    3c58:	9b 81       	ldd	r25, Y+3	; 0x03
    3c5a:	88 85       	ldd	r24, Y+8	; 0x08
    3c5c:	98 17       	cp	r25, r24
    3c5e:	09 f4       	brne	.+2      	; 0x3c62 <vTaskPrioritySet+0x64>
    3c60:	8d c0       	rjmp	.+282    	; 0x3d7c <vTaskPrioritySet+0x17e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    3c62:	98 85       	ldd	r25, Y+8	; 0x08
    3c64:	8b 81       	ldd	r24, Y+3	; 0x03
    3c66:	89 17       	cp	r24, r25
    3c68:	a0 f4       	brcc	.+40     	; 0x3c92 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    3c6a:	20 91 9f 03 	lds	r18, 0x039F
    3c6e:	30 91 a0 03 	lds	r19, 0x03A0
    3c72:	8c 81       	ldd	r24, Y+4	; 0x04
    3c74:	9d 81       	ldd	r25, Y+5	; 0x05
    3c76:	82 17       	cp	r24, r18
    3c78:	93 07       	cpc	r25, r19
    3c7a:	b1 f0       	breq	.+44     	; 0x3ca8 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    3c7c:	e0 91 9f 03 	lds	r30, 0x039F
    3c80:	f0 91 a0 03 	lds	r31, 0x03A0
    3c84:	96 89       	ldd	r25, Z+22	; 0x16
    3c86:	88 85       	ldd	r24, Y+8	; 0x08
    3c88:	89 17       	cp	r24, r25
    3c8a:	70 f0       	brcs	.+28     	; 0x3ca8 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    3c8c:	81 e0       	ldi	r24, 0x01	; 1
    3c8e:	89 83       	std	Y+1, r24	; 0x01
    3c90:	0b c0       	rjmp	.+22     	; 0x3ca8 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    3c92:	20 91 9f 03 	lds	r18, 0x039F
    3c96:	30 91 a0 03 	lds	r19, 0x03A0
    3c9a:	8c 81       	ldd	r24, Y+4	; 0x04
    3c9c:	9d 81       	ldd	r25, Y+5	; 0x05
    3c9e:	82 17       	cp	r24, r18
    3ca0:	93 07       	cpc	r25, r19
    3ca2:	11 f4       	brne	.+4      	; 0x3ca8 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    3ca4:	81 e0       	ldi	r24, 0x01	; 1
    3ca6:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    3ca8:	ec 81       	ldd	r30, Y+4	; 0x04
    3caa:	fd 81       	ldd	r31, Y+5	; 0x05
    3cac:	86 89       	ldd	r24, Z+22	; 0x16
    3cae:	8a 83       	std	Y+2, r24	; 0x02

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    3cb0:	ec 81       	ldd	r30, Y+4	; 0x04
    3cb2:	fd 81       	ldd	r31, Y+5	; 0x05
    3cb4:	93 a1       	ldd	r25, Z+35	; 0x23
    3cb6:	ec 81       	ldd	r30, Y+4	; 0x04
    3cb8:	fd 81       	ldd	r31, Y+5	; 0x05
    3cba:	86 89       	ldd	r24, Z+22	; 0x16
    3cbc:	98 17       	cp	r25, r24
    3cbe:	21 f4       	brne	.+8      	; 0x3cc8 <vTaskPrioritySet+0xca>
					{
						pxTCB->uxPriority = uxNewPriority;
    3cc0:	ec 81       	ldd	r30, Y+4	; 0x04
    3cc2:	fd 81       	ldd	r31, Y+5	; 0x05
    3cc4:	88 85       	ldd	r24, Y+8	; 0x08
    3cc6:	86 8b       	std	Z+22, r24	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    3cc8:	ec 81       	ldd	r30, Y+4	; 0x04
    3cca:	fd 81       	ldd	r31, Y+5	; 0x05
    3ccc:	88 85       	ldd	r24, Y+8	; 0x08
    3cce:	83 a3       	std	Z+35, r24	; 0x23
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3cd0:	ec 81       	ldd	r30, Y+4	; 0x04
    3cd2:	fd 81       	ldd	r31, Y+5	; 0x05
    3cd4:	84 85       	ldd	r24, Z+12	; 0x0c
    3cd6:	95 85       	ldd	r25, Z+13	; 0x0d
    3cd8:	99 23       	and	r25, r25
    3cda:	5c f0       	brlt	.+22     	; 0x3cf2 <vTaskPrioritySet+0xf4>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3cdc:	88 85       	ldd	r24, Y+8	; 0x08
    3cde:	28 2f       	mov	r18, r24
    3ce0:	30 e0       	ldi	r19, 0x00	; 0
    3ce2:	85 e0       	ldi	r24, 0x05	; 5
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	82 1b       	sub	r24, r18
    3ce8:	93 0b       	sbc	r25, r19
    3cea:	ec 81       	ldd	r30, Y+4	; 0x04
    3cec:	fd 81       	ldd	r31, Y+5	; 0x05
    3cee:	95 87       	std	Z+13, r25	; 0x0d
    3cf0:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    3cf2:	ec 81       	ldd	r30, Y+4	; 0x04
    3cf4:	fd 81       	ldd	r31, Y+5	; 0x05
    3cf6:	42 85       	ldd	r20, Z+10	; 0x0a
    3cf8:	53 85       	ldd	r21, Z+11	; 0x0b
    3cfa:	8a 81       	ldd	r24, Y+2	; 0x02
    3cfc:	28 2f       	mov	r18, r24
    3cfe:	30 e0       	ldi	r19, 0x00	; 0
    3d00:	c9 01       	movw	r24, r18
    3d02:	88 0f       	add	r24, r24
    3d04:	99 1f       	adc	r25, r25
    3d06:	88 0f       	add	r24, r24
    3d08:	99 1f       	adc	r25, r25
    3d0a:	88 0f       	add	r24, r24
    3d0c:	99 1f       	adc	r25, r25
    3d0e:	82 0f       	add	r24, r18
    3d10:	93 1f       	adc	r25, r19
    3d12:	80 55       	subi	r24, 0x50	; 80
    3d14:	9c 4f       	sbci	r25, 0xFC	; 252
    3d16:	48 17       	cp	r20, r24
    3d18:	59 07       	cpc	r21, r25
    3d1a:	59 f5       	brne	.+86     	; 0x3d72 <vTaskPrioritySet+0x174>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3d1c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d1e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d20:	02 96       	adiw	r24, 0x02	; 2
    3d22:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    3d26:	ec 81       	ldd	r30, Y+4	; 0x04
    3d28:	fd 81       	ldd	r31, Y+5	; 0x05
    3d2a:	96 89       	ldd	r25, Z+22	; 0x16
    3d2c:	80 91 a5 03 	lds	r24, 0x03A5
    3d30:	89 17       	cp	r24, r25
    3d32:	28 f4       	brcc	.+10     	; 0x3d3e <vTaskPrioritySet+0x140>
    3d34:	ec 81       	ldd	r30, Y+4	; 0x04
    3d36:	fd 81       	ldd	r31, Y+5	; 0x05
    3d38:	86 89       	ldd	r24, Z+22	; 0x16
    3d3a:	80 93 a5 03 	sts	0x03A5, r24
    3d3e:	ec 81       	ldd	r30, Y+4	; 0x04
    3d40:	fd 81       	ldd	r31, Y+5	; 0x05
    3d42:	86 89       	ldd	r24, Z+22	; 0x16
    3d44:	28 2f       	mov	r18, r24
    3d46:	30 e0       	ldi	r19, 0x00	; 0
    3d48:	c9 01       	movw	r24, r18
    3d4a:	88 0f       	add	r24, r24
    3d4c:	99 1f       	adc	r25, r25
    3d4e:	88 0f       	add	r24, r24
    3d50:	99 1f       	adc	r25, r25
    3d52:	88 0f       	add	r24, r24
    3d54:	99 1f       	adc	r25, r25
    3d56:	82 0f       	add	r24, r18
    3d58:	93 1f       	adc	r25, r19
    3d5a:	ac 01       	movw	r20, r24
    3d5c:	40 55       	subi	r20, 0x50	; 80
    3d5e:	5c 4f       	sbci	r21, 0xFC	; 252
    3d60:	8c 81       	ldd	r24, Y+4	; 0x04
    3d62:	9d 81       	ldd	r25, Y+5	; 0x05
    3d64:	9c 01       	movw	r18, r24
    3d66:	2e 5f       	subi	r18, 0xFE	; 254
    3d68:	3f 4f       	sbci	r19, 0xFF	; 255
    3d6a:	ca 01       	movw	r24, r20
    3d6c:	b9 01       	movw	r22, r18
    3d6e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    3d72:	89 81       	ldd	r24, Y+1	; 0x01
    3d74:	88 23       	and	r24, r24
    3d76:	11 f0       	breq	.+4      	; 0x3d7c <vTaskPrioritySet+0x17e>
				{
					taskYIELD_IF_USING_PREEMPTION();
    3d78:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    3d7c:	0f 90       	pop	r0
    3d7e:	0f be       	out	0x3f, r0	; 63
	}
    3d80:	2a 96       	adiw	r28, 0x0a	; 10
    3d82:	0f b6       	in	r0, 0x3f	; 63
    3d84:	f8 94       	cli
    3d86:	de bf       	out	0x3e, r29	; 62
    3d88:	0f be       	out	0x3f, r0	; 63
    3d8a:	cd bf       	out	0x3d, r28	; 61
    3d8c:	cf 91       	pop	r28
    3d8e:	df 91       	pop	r29
    3d90:	08 95       	ret

00003d92 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3d92:	df 93       	push	r29
    3d94:	cf 93       	push	r28
    3d96:	00 d0       	rcall	.+0      	; 0x3d98 <vTaskSuspend+0x6>
    3d98:	00 d0       	rcall	.+0      	; 0x3d9a <vTaskSuspend+0x8>
    3d9a:	00 d0       	rcall	.+0      	; 0x3d9c <vTaskSuspend+0xa>
    3d9c:	cd b7       	in	r28, 0x3d	; 61
    3d9e:	de b7       	in	r29, 0x3e	; 62
    3da0:	9c 83       	std	Y+4, r25	; 0x04
    3da2:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3da4:	0f b6       	in	r0, 0x3f	; 63
    3da6:	f8 94       	cli
    3da8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3daa:	8b 81       	ldd	r24, Y+3	; 0x03
    3dac:	9c 81       	ldd	r25, Y+4	; 0x04
    3dae:	00 97       	sbiw	r24, 0x00	; 0
    3db0:	39 f4       	brne	.+14     	; 0x3dc0 <vTaskSuspend+0x2e>
    3db2:	80 91 9f 03 	lds	r24, 0x039F
    3db6:	90 91 a0 03 	lds	r25, 0x03A0
    3dba:	9e 83       	std	Y+6, r25	; 0x06
    3dbc:	8d 83       	std	Y+5, r24	; 0x05
    3dbe:	04 c0       	rjmp	.+8      	; 0x3dc8 <vTaskSuspend+0x36>
    3dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3dc4:	9e 83       	std	Y+6, r25	; 0x06
    3dc6:	8d 83       	std	Y+5, r24	; 0x05
    3dc8:	8d 81       	ldd	r24, Y+5	; 0x05
    3dca:	9e 81       	ldd	r25, Y+6	; 0x06
    3dcc:	9a 83       	std	Y+2, r25	; 0x02
    3dce:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3dd0:	89 81       	ldd	r24, Y+1	; 0x01
    3dd2:	9a 81       	ldd	r25, Y+2	; 0x02
    3dd4:	02 96       	adiw	r24, 0x02	; 2
    3dd6:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3dda:	e9 81       	ldd	r30, Y+1	; 0x01
    3ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    3dde:	84 89       	ldd	r24, Z+20	; 0x14
    3de0:	95 89       	ldd	r25, Z+21	; 0x15
    3de2:	00 97       	sbiw	r24, 0x00	; 0
    3de4:	29 f0       	breq	.+10     	; 0x3df0 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3de6:	89 81       	ldd	r24, Y+1	; 0x01
    3de8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dea:	0c 96       	adiw	r24, 0x0c	; 12
    3dec:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3df0:	89 81       	ldd	r24, Y+1	; 0x01
    3df2:	9a 81       	ldd	r25, Y+2	; 0x02
    3df4:	9c 01       	movw	r18, r24
    3df6:	2e 5f       	subi	r18, 0xFE	; 254
    3df8:	3f 4f       	sbci	r19, 0xFF	; 255
    3dfa:	85 e0       	ldi	r24, 0x05	; 5
    3dfc:	94 e0       	ldi	r25, 0x04	; 4
    3dfe:	b9 01       	movw	r22, r18
    3e00:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    3e04:	0f 90       	pop	r0
    3e06:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3e08:	80 91 a6 03 	lds	r24, 0x03A6
    3e0c:	88 23       	and	r24, r24
    3e0e:	39 f0       	breq	.+14     	; 0x3e1e <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3e10:	0f b6       	in	r0, 0x3f	; 63
    3e12:	f8 94       	cli
    3e14:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3e16:	0e 94 12 25 	call	0x4a24	; 0x4a24 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3e1a:	0f 90       	pop	r0
    3e1c:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3e1e:	20 91 9f 03 	lds	r18, 0x039F
    3e22:	30 91 a0 03 	lds	r19, 0x03A0
    3e26:	89 81       	ldd	r24, Y+1	; 0x01
    3e28:	9a 81       	ldd	r25, Y+2	; 0x02
    3e2a:	82 17       	cp	r24, r18
    3e2c:	93 07       	cpc	r25, r19
    3e2e:	a1 f4       	brne	.+40     	; 0x3e58 <vTaskSuspend+0xc6>
		{
			if( xSchedulerRunning != pdFALSE )
    3e30:	80 91 a6 03 	lds	r24, 0x03A6
    3e34:	88 23       	and	r24, r24
    3e36:	19 f0       	breq	.+6      	; 0x3e3e <vTaskSuspend+0xac>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3e38:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
    3e3c:	0d c0       	rjmp	.+26     	; 0x3e58 <vTaskSuspend+0xc6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    3e3e:	90 91 05 04 	lds	r25, 0x0405
    3e42:	80 91 a2 03 	lds	r24, 0x03A2
    3e46:	98 17       	cp	r25, r24
    3e48:	29 f4       	brne	.+10     	; 0x3e54 <vTaskSuspend+0xc2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3e4a:	10 92 a0 03 	sts	0x03A0, r1
    3e4e:	10 92 9f 03 	sts	0x039F, r1
    3e52:	02 c0       	rjmp	.+4      	; 0x3e58 <vTaskSuspend+0xc6>
				}
				else
				{
					vTaskSwitchContext();
    3e54:	0e 94 4d 22 	call	0x449a	; 0x449a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3e58:	26 96       	adiw	r28, 0x06	; 6
    3e5a:	0f b6       	in	r0, 0x3f	; 63
    3e5c:	f8 94       	cli
    3e5e:	de bf       	out	0x3e, r29	; 62
    3e60:	0f be       	out	0x3f, r0	; 63
    3e62:	cd bf       	out	0x3d, r28	; 61
    3e64:	cf 91       	pop	r28
    3e66:	df 91       	pop	r29
    3e68:	08 95       	ret

00003e6a <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3e6a:	df 93       	push	r29
    3e6c:	cf 93       	push	r28
    3e6e:	00 d0       	rcall	.+0      	; 0x3e70 <prvTaskIsTaskSuspended+0x6>
    3e70:	00 d0       	rcall	.+0      	; 0x3e72 <prvTaskIsTaskSuspended+0x8>
    3e72:	0f 92       	push	r0
    3e74:	cd b7       	in	r28, 0x3d	; 61
    3e76:	de b7       	in	r29, 0x3e	; 62
    3e78:	9d 83       	std	Y+5, r25	; 0x05
    3e7a:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3e7c:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    3e7e:	8c 81       	ldd	r24, Y+4	; 0x04
    3e80:	9d 81       	ldd	r25, Y+5	; 0x05
    3e82:	9a 83       	std	Y+2, r25	; 0x02
    3e84:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3e86:	e9 81       	ldd	r30, Y+1	; 0x01
    3e88:	fa 81       	ldd	r31, Y+2	; 0x02
    3e8a:	82 85       	ldd	r24, Z+10	; 0x0a
    3e8c:	93 85       	ldd	r25, Z+11	; 0x0b
    3e8e:	24 e0       	ldi	r18, 0x04	; 4
    3e90:	85 30       	cpi	r24, 0x05	; 5
    3e92:	92 07       	cpc	r25, r18
    3e94:	81 f4       	brne	.+32     	; 0x3eb6 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3e96:	e9 81       	ldd	r30, Y+1	; 0x01
    3e98:	fa 81       	ldd	r31, Y+2	; 0x02
    3e9a:	84 89       	ldd	r24, Z+20	; 0x14
    3e9c:	95 89       	ldd	r25, Z+21	; 0x15
    3e9e:	23 e0       	ldi	r18, 0x03	; 3
    3ea0:	83 3f       	cpi	r24, 0xF3	; 243
    3ea2:	92 07       	cpc	r25, r18
    3ea4:	41 f0       	breq	.+16     	; 0x3eb6 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    3ea6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ea8:	fa 81       	ldd	r31, Y+2	; 0x02
    3eaa:	84 89       	ldd	r24, Z+20	; 0x14
    3eac:	95 89       	ldd	r25, Z+21	; 0x15
    3eae:	00 97       	sbiw	r24, 0x00	; 0
    3eb0:	11 f4       	brne	.+4      	; 0x3eb6 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3eb2:	81 e0       	ldi	r24, 0x01	; 1
    3eb4:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3eb6:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3eb8:	0f 90       	pop	r0
    3eba:	0f 90       	pop	r0
    3ebc:	0f 90       	pop	r0
    3ebe:	0f 90       	pop	r0
    3ec0:	0f 90       	pop	r0
    3ec2:	cf 91       	pop	r28
    3ec4:	df 91       	pop	r29
    3ec6:	08 95       	ret

00003ec8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3ec8:	df 93       	push	r29
    3eca:	cf 93       	push	r28
    3ecc:	00 d0       	rcall	.+0      	; 0x3ece <vTaskResume+0x6>
    3ece:	00 d0       	rcall	.+0      	; 0x3ed0 <vTaskResume+0x8>
    3ed0:	cd b7       	in	r28, 0x3d	; 61
    3ed2:	de b7       	in	r29, 0x3e	; 62
    3ed4:	9c 83       	std	Y+4, r25	; 0x04
    3ed6:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    3ed8:	8b 81       	ldd	r24, Y+3	; 0x03
    3eda:	9c 81       	ldd	r25, Y+4	; 0x04
    3edc:	9a 83       	std	Y+2, r25	; 0x02
    3ede:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    3ee0:	89 81       	ldd	r24, Y+1	; 0x01
    3ee2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee4:	00 97       	sbiw	r24, 0x00	; 0
    3ee6:	09 f4       	brne	.+2      	; 0x3eea <vTaskResume+0x22>
    3ee8:	4c c0       	rjmp	.+152    	; 0x3f82 <vTaskResume+0xba>
    3eea:	20 91 9f 03 	lds	r18, 0x039F
    3eee:	30 91 a0 03 	lds	r19, 0x03A0
    3ef2:	89 81       	ldd	r24, Y+1	; 0x01
    3ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef6:	82 17       	cp	r24, r18
    3ef8:	93 07       	cpc	r25, r19
    3efa:	09 f4       	brne	.+2      	; 0x3efe <vTaskResume+0x36>
    3efc:	42 c0       	rjmp	.+132    	; 0x3f82 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3efe:	0f b6       	in	r0, 0x3f	; 63
    3f00:	f8 94       	cli
    3f02:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3f04:	89 81       	ldd	r24, Y+1	; 0x01
    3f06:	9a 81       	ldd	r25, Y+2	; 0x02
    3f08:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <prvTaskIsTaskSuspended>
    3f0c:	88 23       	and	r24, r24
    3f0e:	b9 f1       	breq	.+110    	; 0x3f7e <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3f10:	89 81       	ldd	r24, Y+1	; 0x01
    3f12:	9a 81       	ldd	r25, Y+2	; 0x02
    3f14:	02 96       	adiw	r24, 0x02	; 2
    3f16:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3f1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f1e:	96 89       	ldd	r25, Z+22	; 0x16
    3f20:	80 91 a5 03 	lds	r24, 0x03A5
    3f24:	89 17       	cp	r24, r25
    3f26:	28 f4       	brcc	.+10     	; 0x3f32 <vTaskResume+0x6a>
    3f28:	e9 81       	ldd	r30, Y+1	; 0x01
    3f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f2c:	86 89       	ldd	r24, Z+22	; 0x16
    3f2e:	80 93 a5 03 	sts	0x03A5, r24
    3f32:	e9 81       	ldd	r30, Y+1	; 0x01
    3f34:	fa 81       	ldd	r31, Y+2	; 0x02
    3f36:	86 89       	ldd	r24, Z+22	; 0x16
    3f38:	28 2f       	mov	r18, r24
    3f3a:	30 e0       	ldi	r19, 0x00	; 0
    3f3c:	c9 01       	movw	r24, r18
    3f3e:	88 0f       	add	r24, r24
    3f40:	99 1f       	adc	r25, r25
    3f42:	88 0f       	add	r24, r24
    3f44:	99 1f       	adc	r25, r25
    3f46:	88 0f       	add	r24, r24
    3f48:	99 1f       	adc	r25, r25
    3f4a:	82 0f       	add	r24, r18
    3f4c:	93 1f       	adc	r25, r19
    3f4e:	ac 01       	movw	r20, r24
    3f50:	40 55       	subi	r20, 0x50	; 80
    3f52:	5c 4f       	sbci	r21, 0xFC	; 252
    3f54:	89 81       	ldd	r24, Y+1	; 0x01
    3f56:	9a 81       	ldd	r25, Y+2	; 0x02
    3f58:	9c 01       	movw	r18, r24
    3f5a:	2e 5f       	subi	r18, 0xFE	; 254
    3f5c:	3f 4f       	sbci	r19, 0xFF	; 255
    3f5e:	ca 01       	movw	r24, r20
    3f60:	b9 01       	movw	r22, r18
    3f62:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3f66:	e9 81       	ldd	r30, Y+1	; 0x01
    3f68:	fa 81       	ldd	r31, Y+2	; 0x02
    3f6a:	96 89       	ldd	r25, Z+22	; 0x16
    3f6c:	e0 91 9f 03 	lds	r30, 0x039F
    3f70:	f0 91 a0 03 	lds	r31, 0x03A0
    3f74:	86 89       	ldd	r24, Z+22	; 0x16
    3f76:	98 17       	cp	r25, r24
    3f78:	10 f0       	brcs	.+4      	; 0x3f7e <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    3f7a:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3f7e:	0f 90       	pop	r0
    3f80:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3f82:	0f 90       	pop	r0
    3f84:	0f 90       	pop	r0
    3f86:	0f 90       	pop	r0
    3f88:	0f 90       	pop	r0
    3f8a:	cf 91       	pop	r28
    3f8c:	df 91       	pop	r29
    3f8e:	08 95       	ret

00003f90 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3f90:	df 93       	push	r29
    3f92:	cf 93       	push	r28
    3f94:	00 d0       	rcall	.+0      	; 0x3f96 <xTaskResumeFromISR+0x6>
    3f96:	00 d0       	rcall	.+0      	; 0x3f98 <xTaskResumeFromISR+0x8>
    3f98:	00 d0       	rcall	.+0      	; 0x3f9a <xTaskResumeFromISR+0xa>
    3f9a:	cd b7       	in	r28, 0x3d	; 61
    3f9c:	de b7       	in	r29, 0x3e	; 62
    3f9e:	9e 83       	std	Y+6, r25	; 0x06
    3fa0:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    3fa2:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    3fa4:	8d 81       	ldd	r24, Y+5	; 0x05
    3fa6:	9e 81       	ldd	r25, Y+6	; 0x06
    3fa8:	9b 83       	std	Y+3, r25	; 0x03
    3faa:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3fac:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3fae:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb0:	9b 81       	ldd	r25, Y+3	; 0x03
    3fb2:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <prvTaskIsTaskSuspended>
    3fb6:	88 23       	and	r24, r24
    3fb8:	09 f4       	brne	.+2      	; 0x3fbc <xTaskResumeFromISR+0x2c>
    3fba:	46 c0       	rjmp	.+140    	; 0x4048 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3fbc:	80 91 af 03 	lds	r24, 0x03AF
    3fc0:	88 23       	and	r24, r24
    3fc2:	c1 f5       	brne	.+112    	; 0x4034 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3fc4:	ea 81       	ldd	r30, Y+2	; 0x02
    3fc6:	fb 81       	ldd	r31, Y+3	; 0x03
    3fc8:	96 89       	ldd	r25, Z+22	; 0x16
    3fca:	e0 91 9f 03 	lds	r30, 0x039F
    3fce:	f0 91 a0 03 	lds	r31, 0x03A0
    3fd2:	86 89       	ldd	r24, Z+22	; 0x16
    3fd4:	98 17       	cp	r25, r24
    3fd6:	10 f0       	brcs	.+4      	; 0x3fdc <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    3fd8:	81 e0       	ldi	r24, 0x01	; 1
    3fda:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    3fde:	9b 81       	ldd	r25, Y+3	; 0x03
    3fe0:	02 96       	adiw	r24, 0x02	; 2
    3fe2:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3fe6:	ea 81       	ldd	r30, Y+2	; 0x02
    3fe8:	fb 81       	ldd	r31, Y+3	; 0x03
    3fea:	96 89       	ldd	r25, Z+22	; 0x16
    3fec:	80 91 a5 03 	lds	r24, 0x03A5
    3ff0:	89 17       	cp	r24, r25
    3ff2:	28 f4       	brcc	.+10     	; 0x3ffe <xTaskResumeFromISR+0x6e>
    3ff4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ff6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ff8:	86 89       	ldd	r24, Z+22	; 0x16
    3ffa:	80 93 a5 03 	sts	0x03A5, r24
    3ffe:	ea 81       	ldd	r30, Y+2	; 0x02
    4000:	fb 81       	ldd	r31, Y+3	; 0x03
    4002:	86 89       	ldd	r24, Z+22	; 0x16
    4004:	28 2f       	mov	r18, r24
    4006:	30 e0       	ldi	r19, 0x00	; 0
    4008:	c9 01       	movw	r24, r18
    400a:	88 0f       	add	r24, r24
    400c:	99 1f       	adc	r25, r25
    400e:	88 0f       	add	r24, r24
    4010:	99 1f       	adc	r25, r25
    4012:	88 0f       	add	r24, r24
    4014:	99 1f       	adc	r25, r25
    4016:	82 0f       	add	r24, r18
    4018:	93 1f       	adc	r25, r19
    401a:	ac 01       	movw	r20, r24
    401c:	40 55       	subi	r20, 0x50	; 80
    401e:	5c 4f       	sbci	r21, 0xFC	; 252
    4020:	8a 81       	ldd	r24, Y+2	; 0x02
    4022:	9b 81       	ldd	r25, Y+3	; 0x03
    4024:	9c 01       	movw	r18, r24
    4026:	2e 5f       	subi	r18, 0xFE	; 254
    4028:	3f 4f       	sbci	r19, 0xFF	; 255
    402a:	ca 01       	movw	r24, r20
    402c:	b9 01       	movw	r22, r18
    402e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
    4032:	0a c0       	rjmp	.+20     	; 0x4048 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4034:	8a 81       	ldd	r24, Y+2	; 0x02
    4036:	9b 81       	ldd	r25, Y+3	; 0x03
    4038:	9c 01       	movw	r18, r24
    403a:	24 5f       	subi	r18, 0xF4	; 244
    403c:	3f 4f       	sbci	r19, 0xFF	; 255
    403e:	83 ef       	ldi	r24, 0xF3	; 243
    4040:	93 e0       	ldi	r25, 0x03	; 3
    4042:	b9 01       	movw	r22, r18
    4044:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4048:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    404a:	26 96       	adiw	r28, 0x06	; 6
    404c:	0f b6       	in	r0, 0x3f	; 63
    404e:	f8 94       	cli
    4050:	de bf       	out	0x3e, r29	; 62
    4052:	0f be       	out	0x3f, r0	; 63
    4054:	cd bf       	out	0x3d, r28	; 61
    4056:	cf 91       	pop	r28
    4058:	df 91       	pop	r29
    405a:	08 95       	ret

0000405c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    405c:	ef 92       	push	r14
    405e:	ff 92       	push	r15
    4060:	0f 93       	push	r16
    4062:	df 93       	push	r29
    4064:	cf 93       	push	r28
    4066:	0f 92       	push	r0
    4068:	cd b7       	in	r28, 0x3d	; 61
    406a:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    406c:	8c e6       	ldi	r24, 0x6C	; 108
    406e:	94 e2       	ldi	r25, 0x24	; 36
    4070:	24 e6       	ldi	r18, 0x64	; 100
    4072:	30 e0       	ldi	r19, 0x00	; 0
    4074:	ed ea       	ldi	r30, 0xAD	; 173
    4076:	f3 e0       	ldi	r31, 0x03	; 3
    4078:	b9 01       	movw	r22, r18
    407a:	48 ec       	ldi	r20, 0xC8	; 200
    407c:	50 e0       	ldi	r21, 0x00	; 0
    407e:	20 e0       	ldi	r18, 0x00	; 0
    4080:	30 e0       	ldi	r19, 0x00	; 0
    4082:	00 e0       	ldi	r16, 0x00	; 0
    4084:	7f 01       	movw	r14, r30
    4086:	0e 94 ee 1a 	call	0x35dc	; 0x35dc <xTaskCreate>
    408a:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    408c:	89 81       	ldd	r24, Y+1	; 0x01
    408e:	81 30       	cpi	r24, 0x01	; 1
    4090:	81 f4       	brne	.+32     	; 0x40b2 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    4092:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    4094:	8f ef       	ldi	r24, 0xFF	; 255
    4096:	9f ef       	ldi	r25, 0xFF	; 255
    4098:	90 93 ac 03 	sts	0x03AC, r25
    409c:	80 93 ab 03 	sts	0x03AB, r24
		xSchedulerRunning = pdTRUE;
    40a0:	81 e0       	ldi	r24, 0x01	; 1
    40a2:	80 93 a6 03 	sts	0x03A6, r24
		xTickCount = ( TickType_t ) 0U;
    40a6:	10 92 a4 03 	sts	0x03A4, r1
    40aa:	10 92 a3 03 	sts	0x03A3, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    40ae:	0e 94 11 11 	call	0x2222	; 0x2222 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    40b2:	0f 90       	pop	r0
    40b4:	cf 91       	pop	r28
    40b6:	df 91       	pop	r29
    40b8:	0f 91       	pop	r16
    40ba:	ff 90       	pop	r15
    40bc:	ef 90       	pop	r14
    40be:	08 95       	ret

000040c0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    40c0:	df 93       	push	r29
    40c2:	cf 93       	push	r28
    40c4:	cd b7       	in	r28, 0x3d	; 61
    40c6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    40c8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    40ca:	10 92 a6 03 	sts	0x03A6, r1
	vPortEndScheduler();
    40ce:	0e 94 46 11 	call	0x228c	; 0x228c <vPortEndScheduler>
}
    40d2:	cf 91       	pop	r28
    40d4:	df 91       	pop	r29
    40d6:	08 95       	ret

000040d8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    40d8:	df 93       	push	r29
    40da:	cf 93       	push	r28
    40dc:	cd b7       	in	r28, 0x3d	; 61
    40de:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    40e0:	80 91 af 03 	lds	r24, 0x03AF
    40e4:	8f 5f       	subi	r24, 0xFF	; 255
    40e6:	80 93 af 03 	sts	0x03AF, r24
}
    40ea:	cf 91       	pop	r28
    40ec:	df 91       	pop	r29
    40ee:	08 95       	ret

000040f0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    40f0:	df 93       	push	r29
    40f2:	cf 93       	push	r28
    40f4:	00 d0       	rcall	.+0      	; 0x40f6 <xTaskResumeAll+0x6>
    40f6:	00 d0       	rcall	.+0      	; 0x40f8 <xTaskResumeAll+0x8>
    40f8:	cd b7       	in	r28, 0x3d	; 61
    40fa:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    40fc:	1c 82       	std	Y+4, r1	; 0x04
    40fe:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    4100:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4102:	0f b6       	in	r0, 0x3f	; 63
    4104:	f8 94       	cli
    4106:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4108:	80 91 af 03 	lds	r24, 0x03AF
    410c:	81 50       	subi	r24, 0x01	; 1
    410e:	80 93 af 03 	sts	0x03AF, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4112:	80 91 af 03 	lds	r24, 0x03AF
    4116:	88 23       	and	r24, r24
    4118:	09 f0       	breq	.+2      	; 0x411c <xTaskResumeAll+0x2c>
    411a:	73 c0       	rjmp	.+230    	; 0x4202 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    411c:	80 91 a2 03 	lds	r24, 0x03A2
    4120:	88 23       	and	r24, r24
    4122:	09 f4       	brne	.+2      	; 0x4126 <xTaskResumeAll+0x36>
    4124:	6e c0       	rjmp	.+220    	; 0x4202 <xTaskResumeAll+0x112>
    4126:	45 c0       	rjmp	.+138    	; 0x41b2 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    4128:	e0 91 f8 03 	lds	r30, 0x03F8
    412c:	f0 91 f9 03 	lds	r31, 0x03F9
    4130:	86 81       	ldd	r24, Z+6	; 0x06
    4132:	97 81       	ldd	r25, Z+7	; 0x07
    4134:	9c 83       	std	Y+4, r25	; 0x04
    4136:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4138:	8b 81       	ldd	r24, Y+3	; 0x03
    413a:	9c 81       	ldd	r25, Y+4	; 0x04
    413c:	0c 96       	adiw	r24, 0x0c	; 12
    413e:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4142:	8b 81       	ldd	r24, Y+3	; 0x03
    4144:	9c 81       	ldd	r25, Y+4	; 0x04
    4146:	02 96       	adiw	r24, 0x02	; 2
    4148:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    414c:	eb 81       	ldd	r30, Y+3	; 0x03
    414e:	fc 81       	ldd	r31, Y+4	; 0x04
    4150:	96 89       	ldd	r25, Z+22	; 0x16
    4152:	80 91 a5 03 	lds	r24, 0x03A5
    4156:	89 17       	cp	r24, r25
    4158:	28 f4       	brcc	.+10     	; 0x4164 <xTaskResumeAll+0x74>
    415a:	eb 81       	ldd	r30, Y+3	; 0x03
    415c:	fc 81       	ldd	r31, Y+4	; 0x04
    415e:	86 89       	ldd	r24, Z+22	; 0x16
    4160:	80 93 a5 03 	sts	0x03A5, r24
    4164:	eb 81       	ldd	r30, Y+3	; 0x03
    4166:	fc 81       	ldd	r31, Y+4	; 0x04
    4168:	86 89       	ldd	r24, Z+22	; 0x16
    416a:	28 2f       	mov	r18, r24
    416c:	30 e0       	ldi	r19, 0x00	; 0
    416e:	c9 01       	movw	r24, r18
    4170:	88 0f       	add	r24, r24
    4172:	99 1f       	adc	r25, r25
    4174:	88 0f       	add	r24, r24
    4176:	99 1f       	adc	r25, r25
    4178:	88 0f       	add	r24, r24
    417a:	99 1f       	adc	r25, r25
    417c:	82 0f       	add	r24, r18
    417e:	93 1f       	adc	r25, r19
    4180:	ac 01       	movw	r20, r24
    4182:	40 55       	subi	r20, 0x50	; 80
    4184:	5c 4f       	sbci	r21, 0xFC	; 252
    4186:	8b 81       	ldd	r24, Y+3	; 0x03
    4188:	9c 81       	ldd	r25, Y+4	; 0x04
    418a:	9c 01       	movw	r18, r24
    418c:	2e 5f       	subi	r18, 0xFE	; 254
    418e:	3f 4f       	sbci	r19, 0xFF	; 255
    4190:	ca 01       	movw	r24, r20
    4192:	b9 01       	movw	r22, r18
    4194:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4198:	eb 81       	ldd	r30, Y+3	; 0x03
    419a:	fc 81       	ldd	r31, Y+4	; 0x04
    419c:	96 89       	ldd	r25, Z+22	; 0x16
    419e:	e0 91 9f 03 	lds	r30, 0x039F
    41a2:	f0 91 a0 03 	lds	r31, 0x03A0
    41a6:	86 89       	ldd	r24, Z+22	; 0x16
    41a8:	98 17       	cp	r25, r24
    41aa:	18 f0       	brcs	.+6      	; 0x41b2 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    41ac:	81 e0       	ldi	r24, 0x01	; 1
    41ae:	80 93 a8 03 	sts	0x03A8, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    41b2:	80 91 f3 03 	lds	r24, 0x03F3
    41b6:	88 23       	and	r24, r24
    41b8:	09 f0       	breq	.+2      	; 0x41bc <xTaskResumeAll+0xcc>
    41ba:	b6 cf       	rjmp	.-148    	; 0x4128 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    41bc:	8b 81       	ldd	r24, Y+3	; 0x03
    41be:	9c 81       	ldd	r25, Y+4	; 0x04
    41c0:	00 97       	sbiw	r24, 0x00	; 0
    41c2:	11 f0       	breq	.+4      	; 0x41c8 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    41c4:	0e 94 12 25 	call	0x4a24	; 0x4a24 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    41c8:	80 91 a7 03 	lds	r24, 0x03A7
    41cc:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    41ce:	89 81       	ldd	r24, Y+1	; 0x01
    41d0:	88 23       	and	r24, r24
    41d2:	79 f0       	breq	.+30     	; 0x41f2 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    41d4:	0e 94 68 21 	call	0x42d0	; 0x42d0 <xTaskIncrementTick>
    41d8:	88 23       	and	r24, r24
    41da:	19 f0       	breq	.+6      	; 0x41e2 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    41dc:	81 e0       	ldi	r24, 0x01	; 1
    41de:	80 93 a8 03 	sts	0x03A8, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    41e2:	89 81       	ldd	r24, Y+1	; 0x01
    41e4:	81 50       	subi	r24, 0x01	; 1
    41e6:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    41e8:	89 81       	ldd	r24, Y+1	; 0x01
    41ea:	88 23       	and	r24, r24
    41ec:	99 f7       	brne	.-26     	; 0x41d4 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    41ee:	10 92 a7 03 	sts	0x03A7, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    41f2:	80 91 a8 03 	lds	r24, 0x03A8
    41f6:	88 23       	and	r24, r24
    41f8:	21 f0       	breq	.+8      	; 0x4202 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    41fa:	81 e0       	ldi	r24, 0x01	; 1
    41fc:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    41fe:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4202:	0f 90       	pop	r0
    4204:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4206:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4208:	0f 90       	pop	r0
    420a:	0f 90       	pop	r0
    420c:	0f 90       	pop	r0
    420e:	0f 90       	pop	r0
    4210:	cf 91       	pop	r28
    4212:	df 91       	pop	r29
    4214:	08 95       	ret

00004216 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4216:	df 93       	push	r29
    4218:	cf 93       	push	r28
    421a:	00 d0       	rcall	.+0      	; 0x421c <xTaskGetTickCount+0x6>
    421c:	cd b7       	in	r28, 0x3d	; 61
    421e:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4220:	0f b6       	in	r0, 0x3f	; 63
    4222:	f8 94       	cli
    4224:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4226:	80 91 a3 03 	lds	r24, 0x03A3
    422a:	90 91 a4 03 	lds	r25, 0x03A4
    422e:	9a 83       	std	Y+2, r25	; 0x02
    4230:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4232:	0f 90       	pop	r0
    4234:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4236:	89 81       	ldd	r24, Y+1	; 0x01
    4238:	9a 81       	ldd	r25, Y+2	; 0x02
}
    423a:	0f 90       	pop	r0
    423c:	0f 90       	pop	r0
    423e:	cf 91       	pop	r28
    4240:	df 91       	pop	r29
    4242:	08 95       	ret

00004244 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4244:	df 93       	push	r29
    4246:	cf 93       	push	r28
    4248:	00 d0       	rcall	.+0      	; 0x424a <xTaskGetTickCountFromISR+0x6>
    424a:	0f 92       	push	r0
    424c:	cd b7       	in	r28, 0x3d	; 61
    424e:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4250:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4252:	80 91 a3 03 	lds	r24, 0x03A3
    4256:	90 91 a4 03 	lds	r25, 0x03A4
    425a:	9b 83       	std	Y+3, r25	; 0x03
    425c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    425e:	8a 81       	ldd	r24, Y+2	; 0x02
    4260:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4262:	0f 90       	pop	r0
    4264:	0f 90       	pop	r0
    4266:	0f 90       	pop	r0
    4268:	cf 91       	pop	r28
    426a:	df 91       	pop	r29
    426c:	08 95       	ret

0000426e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    426e:	df 93       	push	r29
    4270:	cf 93       	push	r28
    4272:	cd b7       	in	r28, 0x3d	; 61
    4274:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4276:	80 91 a2 03 	lds	r24, 0x03A2
}
    427a:	cf 91       	pop	r28
    427c:	df 91       	pop	r29
    427e:	08 95       	ret

00004280 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    4280:	df 93       	push	r29
    4282:	cf 93       	push	r28
    4284:	00 d0       	rcall	.+0      	; 0x4286 <pcTaskGetName+0x6>
    4286:	00 d0       	rcall	.+0      	; 0x4288 <pcTaskGetName+0x8>
    4288:	00 d0       	rcall	.+0      	; 0x428a <pcTaskGetName+0xa>
    428a:	cd b7       	in	r28, 0x3d	; 61
    428c:	de b7       	in	r29, 0x3e	; 62
    428e:	9c 83       	std	Y+4, r25	; 0x04
    4290:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4292:	8b 81       	ldd	r24, Y+3	; 0x03
    4294:	9c 81       	ldd	r25, Y+4	; 0x04
    4296:	00 97       	sbiw	r24, 0x00	; 0
    4298:	39 f4       	brne	.+14     	; 0x42a8 <pcTaskGetName+0x28>
    429a:	80 91 9f 03 	lds	r24, 0x039F
    429e:	90 91 a0 03 	lds	r25, 0x03A0
    42a2:	9e 83       	std	Y+6, r25	; 0x06
    42a4:	8d 83       	std	Y+5, r24	; 0x05
    42a6:	04 c0       	rjmp	.+8      	; 0x42b0 <pcTaskGetName+0x30>
    42a8:	8b 81       	ldd	r24, Y+3	; 0x03
    42aa:	9c 81       	ldd	r25, Y+4	; 0x04
    42ac:	9e 83       	std	Y+6, r25	; 0x06
    42ae:	8d 83       	std	Y+5, r24	; 0x05
    42b0:	8d 81       	ldd	r24, Y+5	; 0x05
    42b2:	9e 81       	ldd	r25, Y+6	; 0x06
    42b4:	9a 83       	std	Y+2, r25	; 0x02
    42b6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    42b8:	89 81       	ldd	r24, Y+1	; 0x01
    42ba:	9a 81       	ldd	r25, Y+2	; 0x02
    42bc:	49 96       	adiw	r24, 0x19	; 25
}
    42be:	26 96       	adiw	r28, 0x06	; 6
    42c0:	0f b6       	in	r0, 0x3f	; 63
    42c2:	f8 94       	cli
    42c4:	de bf       	out	0x3e, r29	; 62
    42c6:	0f be       	out	0x3f, r0	; 63
    42c8:	cd bf       	out	0x3d, r28	; 61
    42ca:	cf 91       	pop	r28
    42cc:	df 91       	pop	r29
    42ce:	08 95       	ret

000042d0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    42d0:	df 93       	push	r29
    42d2:	cf 93       	push	r28
    42d4:	cd b7       	in	r28, 0x3d	; 61
    42d6:	de b7       	in	r29, 0x3e	; 62
    42d8:	29 97       	sbiw	r28, 0x09	; 9
    42da:	0f b6       	in	r0, 0x3f	; 63
    42dc:	f8 94       	cli
    42de:	de bf       	out	0x3e, r29	; 62
    42e0:	0f be       	out	0x3f, r0	; 63
    42e2:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    42e4:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    42e6:	80 91 af 03 	lds	r24, 0x03AF
    42ea:	88 23       	and	r24, r24
    42ec:	09 f0       	breq	.+2      	; 0x42f0 <xTaskIncrementTick+0x20>
    42ee:	c0 c0       	rjmp	.+384    	; 0x4470 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    42f0:	80 91 a3 03 	lds	r24, 0x03A3
    42f4:	90 91 a4 03 	lds	r25, 0x03A4
    42f8:	01 96       	adiw	r24, 0x01	; 1
    42fa:	9c 83       	std	Y+4, r25	; 0x04
    42fc:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    42fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4300:	9c 81       	ldd	r25, Y+4	; 0x04
    4302:	90 93 a4 03 	sts	0x03A4, r25
    4306:	80 93 a3 03 	sts	0x03A3, r24

		if( xConstTickCount == ( TickType_t ) 0U )
    430a:	8b 81       	ldd	r24, Y+3	; 0x03
    430c:	9c 81       	ldd	r25, Y+4	; 0x04
    430e:	00 97       	sbiw	r24, 0x00	; 0
    4310:	d9 f4       	brne	.+54     	; 0x4348 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4312:	80 91 ef 03 	lds	r24, 0x03EF
    4316:	90 91 f0 03 	lds	r25, 0x03F0
    431a:	9a 83       	std	Y+2, r25	; 0x02
    431c:	89 83       	std	Y+1, r24	; 0x01
    431e:	80 91 f1 03 	lds	r24, 0x03F1
    4322:	90 91 f2 03 	lds	r25, 0x03F2
    4326:	90 93 f0 03 	sts	0x03F0, r25
    432a:	80 93 ef 03 	sts	0x03EF, r24
    432e:	89 81       	ldd	r24, Y+1	; 0x01
    4330:	9a 81       	ldd	r25, Y+2	; 0x02
    4332:	90 93 f2 03 	sts	0x03F2, r25
    4336:	80 93 f1 03 	sts	0x03F1, r24
    433a:	80 91 a9 03 	lds	r24, 0x03A9
    433e:	8f 5f       	subi	r24, 0xFF	; 255
    4340:	80 93 a9 03 	sts	0x03A9, r24
    4344:	0e 94 12 25 	call	0x4a24	; 0x4a24 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4348:	20 91 ab 03 	lds	r18, 0x03AB
    434c:	30 91 ac 03 	lds	r19, 0x03AC
    4350:	8b 81       	ldd	r24, Y+3	; 0x03
    4352:	9c 81       	ldd	r25, Y+4	; 0x04
    4354:	82 17       	cp	r24, r18
    4356:	93 07       	cpc	r25, r19
    4358:	08 f4       	brcc	.+2      	; 0x435c <xTaskIncrementTick+0x8c>
    435a:	71 c0       	rjmp	.+226    	; 0x443e <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    435c:	e0 91 ef 03 	lds	r30, 0x03EF
    4360:	f0 91 f0 03 	lds	r31, 0x03F0
    4364:	80 81       	ld	r24, Z
    4366:	88 23       	and	r24, r24
    4368:	39 f4       	brne	.+14     	; 0x4378 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    436a:	8f ef       	ldi	r24, 0xFF	; 255
    436c:	9f ef       	ldi	r25, 0xFF	; 255
    436e:	90 93 ac 03 	sts	0x03AC, r25
    4372:	80 93 ab 03 	sts	0x03AB, r24
    4376:	63 c0       	rjmp	.+198    	; 0x443e <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4378:	e0 91 ef 03 	lds	r30, 0x03EF
    437c:	f0 91 f0 03 	lds	r31, 0x03F0
    4380:	05 80       	ldd	r0, Z+5	; 0x05
    4382:	f6 81       	ldd	r31, Z+6	; 0x06
    4384:	e0 2d       	mov	r30, r0
    4386:	86 81       	ldd	r24, Z+6	; 0x06
    4388:	97 81       	ldd	r25, Z+7	; 0x07
    438a:	99 87       	std	Y+9, r25	; 0x09
    438c:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    438e:	e8 85       	ldd	r30, Y+8	; 0x08
    4390:	f9 85       	ldd	r31, Y+9	; 0x09
    4392:	82 81       	ldd	r24, Z+2	; 0x02
    4394:	93 81       	ldd	r25, Z+3	; 0x03
    4396:	9f 83       	std	Y+7, r25	; 0x07
    4398:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    439a:	2b 81       	ldd	r18, Y+3	; 0x03
    439c:	3c 81       	ldd	r19, Y+4	; 0x04
    439e:	8e 81       	ldd	r24, Y+6	; 0x06
    43a0:	9f 81       	ldd	r25, Y+7	; 0x07
    43a2:	28 17       	cp	r18, r24
    43a4:	39 07       	cpc	r19, r25
    43a6:	38 f4       	brcc	.+14     	; 0x43b6 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    43a8:	8e 81       	ldd	r24, Y+6	; 0x06
    43aa:	9f 81       	ldd	r25, Y+7	; 0x07
    43ac:	90 93 ac 03 	sts	0x03AC, r25
    43b0:	80 93 ab 03 	sts	0x03AB, r24
    43b4:	44 c0       	rjmp	.+136    	; 0x443e <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    43b6:	88 85       	ldd	r24, Y+8	; 0x08
    43b8:	99 85       	ldd	r25, Y+9	; 0x09
    43ba:	02 96       	adiw	r24, 0x02	; 2
    43bc:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    43c0:	e8 85       	ldd	r30, Y+8	; 0x08
    43c2:	f9 85       	ldd	r31, Y+9	; 0x09
    43c4:	84 89       	ldd	r24, Z+20	; 0x14
    43c6:	95 89       	ldd	r25, Z+21	; 0x15
    43c8:	00 97       	sbiw	r24, 0x00	; 0
    43ca:	29 f0       	breq	.+10     	; 0x43d6 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    43cc:	88 85       	ldd	r24, Y+8	; 0x08
    43ce:	99 85       	ldd	r25, Y+9	; 0x09
    43d0:	0c 96       	adiw	r24, 0x0c	; 12
    43d2:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    43d6:	e8 85       	ldd	r30, Y+8	; 0x08
    43d8:	f9 85       	ldd	r31, Y+9	; 0x09
    43da:	96 89       	ldd	r25, Z+22	; 0x16
    43dc:	80 91 a5 03 	lds	r24, 0x03A5
    43e0:	89 17       	cp	r24, r25
    43e2:	28 f4       	brcc	.+10     	; 0x43ee <xTaskIncrementTick+0x11e>
    43e4:	e8 85       	ldd	r30, Y+8	; 0x08
    43e6:	f9 85       	ldd	r31, Y+9	; 0x09
    43e8:	86 89       	ldd	r24, Z+22	; 0x16
    43ea:	80 93 a5 03 	sts	0x03A5, r24
    43ee:	e8 85       	ldd	r30, Y+8	; 0x08
    43f0:	f9 85       	ldd	r31, Y+9	; 0x09
    43f2:	86 89       	ldd	r24, Z+22	; 0x16
    43f4:	28 2f       	mov	r18, r24
    43f6:	30 e0       	ldi	r19, 0x00	; 0
    43f8:	c9 01       	movw	r24, r18
    43fa:	88 0f       	add	r24, r24
    43fc:	99 1f       	adc	r25, r25
    43fe:	88 0f       	add	r24, r24
    4400:	99 1f       	adc	r25, r25
    4402:	88 0f       	add	r24, r24
    4404:	99 1f       	adc	r25, r25
    4406:	82 0f       	add	r24, r18
    4408:	93 1f       	adc	r25, r19
    440a:	ac 01       	movw	r20, r24
    440c:	40 55       	subi	r20, 0x50	; 80
    440e:	5c 4f       	sbci	r21, 0xFC	; 252
    4410:	88 85       	ldd	r24, Y+8	; 0x08
    4412:	99 85       	ldd	r25, Y+9	; 0x09
    4414:	9c 01       	movw	r18, r24
    4416:	2e 5f       	subi	r18, 0xFE	; 254
    4418:	3f 4f       	sbci	r19, 0xFF	; 255
    441a:	ca 01       	movw	r24, r20
    441c:	b9 01       	movw	r22, r18
    441e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4422:	e8 85       	ldd	r30, Y+8	; 0x08
    4424:	f9 85       	ldd	r31, Y+9	; 0x09
    4426:	96 89       	ldd	r25, Z+22	; 0x16
    4428:	e0 91 9f 03 	lds	r30, 0x039F
    442c:	f0 91 a0 03 	lds	r31, 0x03A0
    4430:	86 89       	ldd	r24, Z+22	; 0x16
    4432:	98 17       	cp	r25, r24
    4434:	08 f4       	brcc	.+2      	; 0x4438 <xTaskIncrementTick+0x168>
    4436:	92 cf       	rjmp	.-220    	; 0x435c <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4438:	81 e0       	ldi	r24, 0x01	; 1
    443a:	8d 83       	std	Y+5, r24	; 0x05
    443c:	8f cf       	rjmp	.-226    	; 0x435c <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    443e:	e0 91 9f 03 	lds	r30, 0x039F
    4442:	f0 91 a0 03 	lds	r31, 0x03A0
    4446:	86 89       	ldd	r24, Z+22	; 0x16
    4448:	28 2f       	mov	r18, r24
    444a:	30 e0       	ldi	r19, 0x00	; 0
    444c:	c9 01       	movw	r24, r18
    444e:	88 0f       	add	r24, r24
    4450:	99 1f       	adc	r25, r25
    4452:	88 0f       	add	r24, r24
    4454:	99 1f       	adc	r25, r25
    4456:	88 0f       	add	r24, r24
    4458:	99 1f       	adc	r25, r25
    445a:	82 0f       	add	r24, r18
    445c:	93 1f       	adc	r25, r19
    445e:	fc 01       	movw	r30, r24
    4460:	e0 55       	subi	r30, 0x50	; 80
    4462:	fc 4f       	sbci	r31, 0xFC	; 252
    4464:	80 81       	ld	r24, Z
    4466:	82 30       	cpi	r24, 0x02	; 2
    4468:	40 f0       	brcs	.+16     	; 0x447a <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    446a:	81 e0       	ldi	r24, 0x01	; 1
    446c:	8d 83       	std	Y+5, r24	; 0x05
    446e:	05 c0       	rjmp	.+10     	; 0x447a <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    4470:	80 91 a7 03 	lds	r24, 0x03A7
    4474:	8f 5f       	subi	r24, 0xFF	; 255
    4476:	80 93 a7 03 	sts	0x03A7, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    447a:	80 91 a8 03 	lds	r24, 0x03A8
    447e:	88 23       	and	r24, r24
    4480:	11 f0       	breq	.+4      	; 0x4486 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    4482:	81 e0       	ldi	r24, 0x01	; 1
    4484:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4486:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4488:	29 96       	adiw	r28, 0x09	; 9
    448a:	0f b6       	in	r0, 0x3f	; 63
    448c:	f8 94       	cli
    448e:	de bf       	out	0x3e, r29	; 62
    4490:	0f be       	out	0x3f, r0	; 63
    4492:	cd bf       	out	0x3d, r28	; 61
    4494:	cf 91       	pop	r28
    4496:	df 91       	pop	r29
    4498:	08 95       	ret

0000449a <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    449a:	df 93       	push	r29
    449c:	cf 93       	push	r28
    449e:	00 d0       	rcall	.+0      	; 0x44a0 <vTaskSwitchContext+0x6>
    44a0:	0f 92       	push	r0
    44a2:	cd b7       	in	r28, 0x3d	; 61
    44a4:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    44a6:	80 91 af 03 	lds	r24, 0x03AF
    44aa:	88 23       	and	r24, r24
    44ac:	21 f0       	breq	.+8      	; 0x44b6 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    44ae:	81 e0       	ldi	r24, 0x01	; 1
    44b0:	80 93 a8 03 	sts	0x03A8, r24
    44b4:	59 c0       	rjmp	.+178    	; 0x4568 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    44b6:	10 92 a8 03 	sts	0x03A8, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    44ba:	80 91 a5 03 	lds	r24, 0x03A5
    44be:	8b 83       	std	Y+3, r24	; 0x03
    44c0:	03 c0       	rjmp	.+6      	; 0x44c8 <vTaskSwitchContext+0x2e>
    44c2:	8b 81       	ldd	r24, Y+3	; 0x03
    44c4:	81 50       	subi	r24, 0x01	; 1
    44c6:	8b 83       	std	Y+3, r24	; 0x03
    44c8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ca:	28 2f       	mov	r18, r24
    44cc:	30 e0       	ldi	r19, 0x00	; 0
    44ce:	c9 01       	movw	r24, r18
    44d0:	88 0f       	add	r24, r24
    44d2:	99 1f       	adc	r25, r25
    44d4:	88 0f       	add	r24, r24
    44d6:	99 1f       	adc	r25, r25
    44d8:	88 0f       	add	r24, r24
    44da:	99 1f       	adc	r25, r25
    44dc:	82 0f       	add	r24, r18
    44de:	93 1f       	adc	r25, r19
    44e0:	fc 01       	movw	r30, r24
    44e2:	e0 55       	subi	r30, 0x50	; 80
    44e4:	fc 4f       	sbci	r31, 0xFC	; 252
    44e6:	80 81       	ld	r24, Z
    44e8:	88 23       	and	r24, r24
    44ea:	59 f3       	breq	.-42     	; 0x44c2 <vTaskSwitchContext+0x28>
    44ec:	8b 81       	ldd	r24, Y+3	; 0x03
    44ee:	28 2f       	mov	r18, r24
    44f0:	30 e0       	ldi	r19, 0x00	; 0
    44f2:	c9 01       	movw	r24, r18
    44f4:	88 0f       	add	r24, r24
    44f6:	99 1f       	adc	r25, r25
    44f8:	88 0f       	add	r24, r24
    44fa:	99 1f       	adc	r25, r25
    44fc:	88 0f       	add	r24, r24
    44fe:	99 1f       	adc	r25, r25
    4500:	82 0f       	add	r24, r18
    4502:	93 1f       	adc	r25, r19
    4504:	80 55       	subi	r24, 0x50	; 80
    4506:	9c 4f       	sbci	r25, 0xFC	; 252
    4508:	9a 83       	std	Y+2, r25	; 0x02
    450a:	89 83       	std	Y+1, r24	; 0x01
    450c:	e9 81       	ldd	r30, Y+1	; 0x01
    450e:	fa 81       	ldd	r31, Y+2	; 0x02
    4510:	01 80       	ldd	r0, Z+1	; 0x01
    4512:	f2 81       	ldd	r31, Z+2	; 0x02
    4514:	e0 2d       	mov	r30, r0
    4516:	82 81       	ldd	r24, Z+2	; 0x02
    4518:	93 81       	ldd	r25, Z+3	; 0x03
    451a:	e9 81       	ldd	r30, Y+1	; 0x01
    451c:	fa 81       	ldd	r31, Y+2	; 0x02
    451e:	92 83       	std	Z+2, r25	; 0x02
    4520:	81 83       	std	Z+1, r24	; 0x01
    4522:	e9 81       	ldd	r30, Y+1	; 0x01
    4524:	fa 81       	ldd	r31, Y+2	; 0x02
    4526:	21 81       	ldd	r18, Z+1	; 0x01
    4528:	32 81       	ldd	r19, Z+2	; 0x02
    452a:	89 81       	ldd	r24, Y+1	; 0x01
    452c:	9a 81       	ldd	r25, Y+2	; 0x02
    452e:	03 96       	adiw	r24, 0x03	; 3
    4530:	28 17       	cp	r18, r24
    4532:	39 07       	cpc	r19, r25
    4534:	59 f4       	brne	.+22     	; 0x454c <vTaskSwitchContext+0xb2>
    4536:	e9 81       	ldd	r30, Y+1	; 0x01
    4538:	fa 81       	ldd	r31, Y+2	; 0x02
    453a:	01 80       	ldd	r0, Z+1	; 0x01
    453c:	f2 81       	ldd	r31, Z+2	; 0x02
    453e:	e0 2d       	mov	r30, r0
    4540:	82 81       	ldd	r24, Z+2	; 0x02
    4542:	93 81       	ldd	r25, Z+3	; 0x03
    4544:	e9 81       	ldd	r30, Y+1	; 0x01
    4546:	fa 81       	ldd	r31, Y+2	; 0x02
    4548:	92 83       	std	Z+2, r25	; 0x02
    454a:	81 83       	std	Z+1, r24	; 0x01
    454c:	e9 81       	ldd	r30, Y+1	; 0x01
    454e:	fa 81       	ldd	r31, Y+2	; 0x02
    4550:	01 80       	ldd	r0, Z+1	; 0x01
    4552:	f2 81       	ldd	r31, Z+2	; 0x02
    4554:	e0 2d       	mov	r30, r0
    4556:	86 81       	ldd	r24, Z+6	; 0x06
    4558:	97 81       	ldd	r25, Z+7	; 0x07
    455a:	90 93 a0 03 	sts	0x03A0, r25
    455e:	80 93 9f 03 	sts	0x039F, r24
    4562:	8b 81       	ldd	r24, Y+3	; 0x03
    4564:	80 93 a5 03 	sts	0x03A5, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4568:	0f 90       	pop	r0
    456a:	0f 90       	pop	r0
    456c:	0f 90       	pop	r0
    456e:	cf 91       	pop	r28
    4570:	df 91       	pop	r29
    4572:	08 95       	ret

00004574 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4574:	df 93       	push	r29
    4576:	cf 93       	push	r28
    4578:	00 d0       	rcall	.+0      	; 0x457a <vTaskPlaceOnEventList+0x6>
    457a:	00 d0       	rcall	.+0      	; 0x457c <vTaskPlaceOnEventList+0x8>
    457c:	cd b7       	in	r28, 0x3d	; 61
    457e:	de b7       	in	r29, 0x3e	; 62
    4580:	9a 83       	std	Y+2, r25	; 0x02
    4582:	89 83       	std	Y+1, r24	; 0x01
    4584:	7c 83       	std	Y+4, r23	; 0x04
    4586:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4588:	80 91 9f 03 	lds	r24, 0x039F
    458c:	90 91 a0 03 	lds	r25, 0x03A0
    4590:	9c 01       	movw	r18, r24
    4592:	24 5f       	subi	r18, 0xF4	; 244
    4594:	3f 4f       	sbci	r19, 0xFF	; 255
    4596:	89 81       	ldd	r24, Y+1	; 0x01
    4598:	9a 81       	ldd	r25, Y+2	; 0x02
    459a:	b9 01       	movw	r22, r18
    459c:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45a0:	8b 81       	ldd	r24, Y+3	; 0x03
    45a2:	9c 81       	ldd	r25, Y+4	; 0x04
    45a4:	61 e0       	ldi	r22, 0x01	; 1
    45a6:	0e 94 35 2a 	call	0x546a	; 0x546a <prvAddCurrentTaskToDelayedList>
}
    45aa:	0f 90       	pop	r0
    45ac:	0f 90       	pop	r0
    45ae:	0f 90       	pop	r0
    45b0:	0f 90       	pop	r0
    45b2:	cf 91       	pop	r28
    45b4:	df 91       	pop	r29
    45b6:	08 95       	ret

000045b8 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    45b8:	df 93       	push	r29
    45ba:	cf 93       	push	r28
    45bc:	00 d0       	rcall	.+0      	; 0x45be <vTaskPlaceOnUnorderedEventList+0x6>
    45be:	00 d0       	rcall	.+0      	; 0x45c0 <vTaskPlaceOnUnorderedEventList+0x8>
    45c0:	00 d0       	rcall	.+0      	; 0x45c2 <vTaskPlaceOnUnorderedEventList+0xa>
    45c2:	cd b7       	in	r28, 0x3d	; 61
    45c4:	de b7       	in	r29, 0x3e	; 62
    45c6:	9a 83       	std	Y+2, r25	; 0x02
    45c8:	89 83       	std	Y+1, r24	; 0x01
    45ca:	7c 83       	std	Y+4, r23	; 0x04
    45cc:	6b 83       	std	Y+3, r22	; 0x03
    45ce:	5e 83       	std	Y+6, r21	; 0x06
    45d0:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    45d2:	e0 91 9f 03 	lds	r30, 0x039F
    45d6:	f0 91 a0 03 	lds	r31, 0x03A0
    45da:	8b 81       	ldd	r24, Y+3	; 0x03
    45dc:	9c 81       	ldd	r25, Y+4	; 0x04
    45de:	90 68       	ori	r25, 0x80	; 128
    45e0:	95 87       	std	Z+13, r25	; 0x0d
    45e2:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    45e4:	80 91 9f 03 	lds	r24, 0x039F
    45e8:	90 91 a0 03 	lds	r25, 0x03A0
    45ec:	9c 01       	movw	r18, r24
    45ee:	24 5f       	subi	r18, 0xF4	; 244
    45f0:	3f 4f       	sbci	r19, 0xFF	; 255
    45f2:	89 81       	ldd	r24, Y+1	; 0x01
    45f4:	9a 81       	ldd	r25, Y+2	; 0x02
    45f6:	b9 01       	movw	r22, r18
    45f8:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45fc:	8d 81       	ldd	r24, Y+5	; 0x05
    45fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4600:	61 e0       	ldi	r22, 0x01	; 1
    4602:	0e 94 35 2a 	call	0x546a	; 0x546a <prvAddCurrentTaskToDelayedList>
}
    4606:	26 96       	adiw	r28, 0x06	; 6
    4608:	0f b6       	in	r0, 0x3f	; 63
    460a:	f8 94       	cli
    460c:	de bf       	out	0x3e, r29	; 62
    460e:	0f be       	out	0x3f, r0	; 63
    4610:	cd bf       	out	0x3d, r28	; 61
    4612:	cf 91       	pop	r28
    4614:	df 91       	pop	r29
    4616:	08 95       	ret

00004618 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4618:	df 93       	push	r29
    461a:	cf 93       	push	r28
    461c:	00 d0       	rcall	.+0      	; 0x461e <xTaskRemoveFromEventList+0x6>
    461e:	00 d0       	rcall	.+0      	; 0x4620 <xTaskRemoveFromEventList+0x8>
    4620:	0f 92       	push	r0
    4622:	cd b7       	in	r28, 0x3d	; 61
    4624:	de b7       	in	r29, 0x3e	; 62
    4626:	9d 83       	std	Y+5, r25	; 0x05
    4628:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    462a:	ec 81       	ldd	r30, Y+4	; 0x04
    462c:	fd 81       	ldd	r31, Y+5	; 0x05
    462e:	05 80       	ldd	r0, Z+5	; 0x05
    4630:	f6 81       	ldd	r31, Z+6	; 0x06
    4632:	e0 2d       	mov	r30, r0
    4634:	86 81       	ldd	r24, Z+6	; 0x06
    4636:	97 81       	ldd	r25, Z+7	; 0x07
    4638:	9b 83       	std	Y+3, r25	; 0x03
    463a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    463c:	8a 81       	ldd	r24, Y+2	; 0x02
    463e:	9b 81       	ldd	r25, Y+3	; 0x03
    4640:	0c 96       	adiw	r24, 0x0c	; 12
    4642:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4646:	80 91 af 03 	lds	r24, 0x03AF
    464a:	88 23       	and	r24, r24
    464c:	61 f5       	brne	.+88     	; 0x46a6 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    464e:	8a 81       	ldd	r24, Y+2	; 0x02
    4650:	9b 81       	ldd	r25, Y+3	; 0x03
    4652:	02 96       	adiw	r24, 0x02	; 2
    4654:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4658:	ea 81       	ldd	r30, Y+2	; 0x02
    465a:	fb 81       	ldd	r31, Y+3	; 0x03
    465c:	96 89       	ldd	r25, Z+22	; 0x16
    465e:	80 91 a5 03 	lds	r24, 0x03A5
    4662:	89 17       	cp	r24, r25
    4664:	28 f4       	brcc	.+10     	; 0x4670 <xTaskRemoveFromEventList+0x58>
    4666:	ea 81       	ldd	r30, Y+2	; 0x02
    4668:	fb 81       	ldd	r31, Y+3	; 0x03
    466a:	86 89       	ldd	r24, Z+22	; 0x16
    466c:	80 93 a5 03 	sts	0x03A5, r24
    4670:	ea 81       	ldd	r30, Y+2	; 0x02
    4672:	fb 81       	ldd	r31, Y+3	; 0x03
    4674:	86 89       	ldd	r24, Z+22	; 0x16
    4676:	28 2f       	mov	r18, r24
    4678:	30 e0       	ldi	r19, 0x00	; 0
    467a:	c9 01       	movw	r24, r18
    467c:	88 0f       	add	r24, r24
    467e:	99 1f       	adc	r25, r25
    4680:	88 0f       	add	r24, r24
    4682:	99 1f       	adc	r25, r25
    4684:	88 0f       	add	r24, r24
    4686:	99 1f       	adc	r25, r25
    4688:	82 0f       	add	r24, r18
    468a:	93 1f       	adc	r25, r19
    468c:	ac 01       	movw	r20, r24
    468e:	40 55       	subi	r20, 0x50	; 80
    4690:	5c 4f       	sbci	r21, 0xFC	; 252
    4692:	8a 81       	ldd	r24, Y+2	; 0x02
    4694:	9b 81       	ldd	r25, Y+3	; 0x03
    4696:	9c 01       	movw	r18, r24
    4698:	2e 5f       	subi	r18, 0xFE	; 254
    469a:	3f 4f       	sbci	r19, 0xFF	; 255
    469c:	ca 01       	movw	r24, r20
    469e:	b9 01       	movw	r22, r18
    46a0:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
    46a4:	0a c0       	rjmp	.+20     	; 0x46ba <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    46a6:	8a 81       	ldd	r24, Y+2	; 0x02
    46a8:	9b 81       	ldd	r25, Y+3	; 0x03
    46aa:	9c 01       	movw	r18, r24
    46ac:	24 5f       	subi	r18, 0xF4	; 244
    46ae:	3f 4f       	sbci	r19, 0xFF	; 255
    46b0:	83 ef       	ldi	r24, 0xF3	; 243
    46b2:	93 e0       	ldi	r25, 0x03	; 3
    46b4:	b9 01       	movw	r22, r18
    46b6:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    46ba:	ea 81       	ldd	r30, Y+2	; 0x02
    46bc:	fb 81       	ldd	r31, Y+3	; 0x03
    46be:	96 89       	ldd	r25, Z+22	; 0x16
    46c0:	e0 91 9f 03 	lds	r30, 0x039F
    46c4:	f0 91 a0 03 	lds	r31, 0x03A0
    46c8:	86 89       	ldd	r24, Z+22	; 0x16
    46ca:	89 17       	cp	r24, r25
    46cc:	30 f4       	brcc	.+12     	; 0x46da <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    46ce:	81 e0       	ldi	r24, 0x01	; 1
    46d0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    46d2:	81 e0       	ldi	r24, 0x01	; 1
    46d4:	80 93 a8 03 	sts	0x03A8, r24
    46d8:	01 c0       	rjmp	.+2      	; 0x46dc <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    46da:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    46dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    46de:	0f 90       	pop	r0
    46e0:	0f 90       	pop	r0
    46e2:	0f 90       	pop	r0
    46e4:	0f 90       	pop	r0
    46e6:	0f 90       	pop	r0
    46e8:	cf 91       	pop	r28
    46ea:	df 91       	pop	r29
    46ec:	08 95       	ret

000046ee <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    46ee:	df 93       	push	r29
    46f0:	cf 93       	push	r28
    46f2:	cd b7       	in	r28, 0x3d	; 61
    46f4:	de b7       	in	r29, 0x3e	; 62
    46f6:	27 97       	sbiw	r28, 0x07	; 7
    46f8:	0f b6       	in	r0, 0x3f	; 63
    46fa:	f8 94       	cli
    46fc:	de bf       	out	0x3e, r29	; 62
    46fe:	0f be       	out	0x3f, r0	; 63
    4700:	cd bf       	out	0x3d, r28	; 61
    4702:	9d 83       	std	Y+5, r25	; 0x05
    4704:	8c 83       	std	Y+4, r24	; 0x04
    4706:	7f 83       	std	Y+7, r23	; 0x07
    4708:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    470a:	8e 81       	ldd	r24, Y+6	; 0x06
    470c:	9f 81       	ldd	r25, Y+7	; 0x07
    470e:	90 68       	ori	r25, 0x80	; 128
    4710:	ec 81       	ldd	r30, Y+4	; 0x04
    4712:	fd 81       	ldd	r31, Y+5	; 0x05
    4714:	91 83       	std	Z+1, r25	; 0x01
    4716:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    4718:	ec 81       	ldd	r30, Y+4	; 0x04
    471a:	fd 81       	ldd	r31, Y+5	; 0x05
    471c:	86 81       	ldd	r24, Z+6	; 0x06
    471e:	97 81       	ldd	r25, Z+7	; 0x07
    4720:	9b 83       	std	Y+3, r25	; 0x03
    4722:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4724:	8c 81       	ldd	r24, Y+4	; 0x04
    4726:	9d 81       	ldd	r25, Y+5	; 0x05
    4728:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    472c:	8a 81       	ldd	r24, Y+2	; 0x02
    472e:	9b 81       	ldd	r25, Y+3	; 0x03
    4730:	02 96       	adiw	r24, 0x02	; 2
    4732:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4736:	ea 81       	ldd	r30, Y+2	; 0x02
    4738:	fb 81       	ldd	r31, Y+3	; 0x03
    473a:	96 89       	ldd	r25, Z+22	; 0x16
    473c:	80 91 a5 03 	lds	r24, 0x03A5
    4740:	89 17       	cp	r24, r25
    4742:	28 f4       	brcc	.+10     	; 0x474e <xTaskRemoveFromUnorderedEventList+0x60>
    4744:	ea 81       	ldd	r30, Y+2	; 0x02
    4746:	fb 81       	ldd	r31, Y+3	; 0x03
    4748:	86 89       	ldd	r24, Z+22	; 0x16
    474a:	80 93 a5 03 	sts	0x03A5, r24
    474e:	ea 81       	ldd	r30, Y+2	; 0x02
    4750:	fb 81       	ldd	r31, Y+3	; 0x03
    4752:	86 89       	ldd	r24, Z+22	; 0x16
    4754:	28 2f       	mov	r18, r24
    4756:	30 e0       	ldi	r19, 0x00	; 0
    4758:	c9 01       	movw	r24, r18
    475a:	88 0f       	add	r24, r24
    475c:	99 1f       	adc	r25, r25
    475e:	88 0f       	add	r24, r24
    4760:	99 1f       	adc	r25, r25
    4762:	88 0f       	add	r24, r24
    4764:	99 1f       	adc	r25, r25
    4766:	82 0f       	add	r24, r18
    4768:	93 1f       	adc	r25, r19
    476a:	ac 01       	movw	r20, r24
    476c:	40 55       	subi	r20, 0x50	; 80
    476e:	5c 4f       	sbci	r21, 0xFC	; 252
    4770:	8a 81       	ldd	r24, Y+2	; 0x02
    4772:	9b 81       	ldd	r25, Y+3	; 0x03
    4774:	9c 01       	movw	r18, r24
    4776:	2e 5f       	subi	r18, 0xFE	; 254
    4778:	3f 4f       	sbci	r19, 0xFF	; 255
    477a:	ca 01       	movw	r24, r20
    477c:	b9 01       	movw	r22, r18
    477e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4782:	ea 81       	ldd	r30, Y+2	; 0x02
    4784:	fb 81       	ldd	r31, Y+3	; 0x03
    4786:	96 89       	ldd	r25, Z+22	; 0x16
    4788:	e0 91 9f 03 	lds	r30, 0x039F
    478c:	f0 91 a0 03 	lds	r31, 0x03A0
    4790:	86 89       	ldd	r24, Z+22	; 0x16
    4792:	89 17       	cp	r24, r25
    4794:	30 f4       	brcc	.+12     	; 0x47a2 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4796:	81 e0       	ldi	r24, 0x01	; 1
    4798:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    479a:	81 e0       	ldi	r24, 0x01	; 1
    479c:	80 93 a8 03 	sts	0x03A8, r24
    47a0:	01 c0       	rjmp	.+2      	; 0x47a4 <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    47a2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    47a4:	89 81       	ldd	r24, Y+1	; 0x01
}
    47a6:	27 96       	adiw	r28, 0x07	; 7
    47a8:	0f b6       	in	r0, 0x3f	; 63
    47aa:	f8 94       	cli
    47ac:	de bf       	out	0x3e, r29	; 62
    47ae:	0f be       	out	0x3f, r0	; 63
    47b0:	cd bf       	out	0x3d, r28	; 61
    47b2:	cf 91       	pop	r28
    47b4:	df 91       	pop	r29
    47b6:	08 95       	ret

000047b8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    47b8:	df 93       	push	r29
    47ba:	cf 93       	push	r28
    47bc:	00 d0       	rcall	.+0      	; 0x47be <vTaskSetTimeOutState+0x6>
    47be:	cd b7       	in	r28, 0x3d	; 61
    47c0:	de b7       	in	r29, 0x3e	; 62
    47c2:	9a 83       	std	Y+2, r25	; 0x02
    47c4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    47c6:	80 91 a9 03 	lds	r24, 0x03A9
    47ca:	e9 81       	ldd	r30, Y+1	; 0x01
    47cc:	fa 81       	ldd	r31, Y+2	; 0x02
    47ce:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    47d0:	80 91 a3 03 	lds	r24, 0x03A3
    47d4:	90 91 a4 03 	lds	r25, 0x03A4
    47d8:	e9 81       	ldd	r30, Y+1	; 0x01
    47da:	fa 81       	ldd	r31, Y+2	; 0x02
    47dc:	92 83       	std	Z+2, r25	; 0x02
    47de:	81 83       	std	Z+1, r24	; 0x01
}
    47e0:	0f 90       	pop	r0
    47e2:	0f 90       	pop	r0
    47e4:	cf 91       	pop	r28
    47e6:	df 91       	pop	r29
    47e8:	08 95       	ret

000047ea <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    47ea:	df 93       	push	r29
    47ec:	cf 93       	push	r28
    47ee:	cd b7       	in	r28, 0x3d	; 61
    47f0:	de b7       	in	r29, 0x3e	; 62
    47f2:	27 97       	sbiw	r28, 0x07	; 7
    47f4:	0f b6       	in	r0, 0x3f	; 63
    47f6:	f8 94       	cli
    47f8:	de bf       	out	0x3e, r29	; 62
    47fa:	0f be       	out	0x3f, r0	; 63
    47fc:	cd bf       	out	0x3d, r28	; 61
    47fe:	9d 83       	std	Y+5, r25	; 0x05
    4800:	8c 83       	std	Y+4, r24	; 0x04
    4802:	7f 83       	std	Y+7, r23	; 0x07
    4804:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4806:	0f b6       	in	r0, 0x3f	; 63
    4808:	f8 94       	cli
    480a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    480c:	80 91 a3 03 	lds	r24, 0x03A3
    4810:	90 91 a4 03 	lds	r25, 0x03A4
    4814:	9a 83       	std	Y+2, r25	; 0x02
    4816:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4818:	ee 81       	ldd	r30, Y+6	; 0x06
    481a:	ff 81       	ldd	r31, Y+7	; 0x07
    481c:	80 81       	ld	r24, Z
    481e:	91 81       	ldd	r25, Z+1	; 0x01
    4820:	2f ef       	ldi	r18, 0xFF	; 255
    4822:	8f 3f       	cpi	r24, 0xFF	; 255
    4824:	92 07       	cpc	r25, r18
    4826:	11 f4       	brne	.+4      	; 0x482c <xTaskCheckForTimeOut+0x42>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4828:	1b 82       	std	Y+3, r1	; 0x03
    482a:	40 c0       	rjmp	.+128    	; 0x48ac <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    482c:	ec 81       	ldd	r30, Y+4	; 0x04
    482e:	fd 81       	ldd	r31, Y+5	; 0x05
    4830:	90 81       	ld	r25, Z
    4832:	80 91 a9 03 	lds	r24, 0x03A9
    4836:	98 17       	cp	r25, r24
    4838:	61 f0       	breq	.+24     	; 0x4852 <xTaskCheckForTimeOut+0x68>
    483a:	ec 81       	ldd	r30, Y+4	; 0x04
    483c:	fd 81       	ldd	r31, Y+5	; 0x05
    483e:	21 81       	ldd	r18, Z+1	; 0x01
    4840:	32 81       	ldd	r19, Z+2	; 0x02
    4842:	89 81       	ldd	r24, Y+1	; 0x01
    4844:	9a 81       	ldd	r25, Y+2	; 0x02
    4846:	82 17       	cp	r24, r18
    4848:	93 07       	cpc	r25, r19
    484a:	18 f0       	brcs	.+6      	; 0x4852 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    484c:	81 e0       	ldi	r24, 0x01	; 1
    484e:	8b 83       	std	Y+3, r24	; 0x03
    4850:	2d c0       	rjmp	.+90     	; 0x48ac <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4852:	ec 81       	ldd	r30, Y+4	; 0x04
    4854:	fd 81       	ldd	r31, Y+5	; 0x05
    4856:	21 81       	ldd	r18, Z+1	; 0x01
    4858:	32 81       	ldd	r19, Z+2	; 0x02
    485a:	89 81       	ldd	r24, Y+1	; 0x01
    485c:	9a 81       	ldd	r25, Y+2	; 0x02
    485e:	ac 01       	movw	r20, r24
    4860:	42 1b       	sub	r20, r18
    4862:	53 0b       	sbc	r21, r19
    4864:	9a 01       	movw	r18, r20
    4866:	ee 81       	ldd	r30, Y+6	; 0x06
    4868:	ff 81       	ldd	r31, Y+7	; 0x07
    486a:	80 81       	ld	r24, Z
    486c:	91 81       	ldd	r25, Z+1	; 0x01
    486e:	28 17       	cp	r18, r24
    4870:	39 07       	cpc	r19, r25
    4872:	d0 f4       	brcc	.+52     	; 0x48a8 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    4874:	ee 81       	ldd	r30, Y+6	; 0x06
    4876:	ff 81       	ldd	r31, Y+7	; 0x07
    4878:	40 81       	ld	r20, Z
    487a:	51 81       	ldd	r21, Z+1	; 0x01
    487c:	ec 81       	ldd	r30, Y+4	; 0x04
    487e:	fd 81       	ldd	r31, Y+5	; 0x05
    4880:	21 81       	ldd	r18, Z+1	; 0x01
    4882:	32 81       	ldd	r19, Z+2	; 0x02
    4884:	89 81       	ldd	r24, Y+1	; 0x01
    4886:	9a 81       	ldd	r25, Y+2	; 0x02
    4888:	b9 01       	movw	r22, r18
    488a:	68 1b       	sub	r22, r24
    488c:	79 0b       	sbc	r23, r25
    488e:	cb 01       	movw	r24, r22
    4890:	84 0f       	add	r24, r20
    4892:	95 1f       	adc	r25, r21
    4894:	ee 81       	ldd	r30, Y+6	; 0x06
    4896:	ff 81       	ldd	r31, Y+7	; 0x07
    4898:	91 83       	std	Z+1, r25	; 0x01
    489a:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    489c:	8c 81       	ldd	r24, Y+4	; 0x04
    489e:	9d 81       	ldd	r25, Y+5	; 0x05
    48a0:	0e 94 dc 23 	call	0x47b8	; 0x47b8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    48a4:	1b 82       	std	Y+3, r1	; 0x03
    48a6:	02 c0       	rjmp	.+4      	; 0x48ac <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    48a8:	81 e0       	ldi	r24, 0x01	; 1
    48aa:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    48ac:	0f 90       	pop	r0
    48ae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    48b0:	8b 81       	ldd	r24, Y+3	; 0x03
}
    48b2:	27 96       	adiw	r28, 0x07	; 7
    48b4:	0f b6       	in	r0, 0x3f	; 63
    48b6:	f8 94       	cli
    48b8:	de bf       	out	0x3e, r29	; 62
    48ba:	0f be       	out	0x3f, r0	; 63
    48bc:	cd bf       	out	0x3d, r28	; 61
    48be:	cf 91       	pop	r28
    48c0:	df 91       	pop	r29
    48c2:	08 95       	ret

000048c4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    48c4:	df 93       	push	r29
    48c6:	cf 93       	push	r28
    48c8:	cd b7       	in	r28, 0x3d	; 61
    48ca:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    48cc:	81 e0       	ldi	r24, 0x01	; 1
    48ce:	80 93 a8 03 	sts	0x03A8, r24
}
    48d2:	cf 91       	pop	r28
    48d4:	df 91       	pop	r29
    48d6:	08 95       	ret

000048d8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    48d8:	df 93       	push	r29
    48da:	cf 93       	push	r28
    48dc:	00 d0       	rcall	.+0      	; 0x48de <prvIdleTask+0x6>
    48de:	cd b7       	in	r28, 0x3d	; 61
    48e0:	de b7       	in	r29, 0x3e	; 62
    48e2:	9a 83       	std	Y+2, r25	; 0x02
    48e4:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    48e6:	0e 94 bd 24 	call	0x497a	; 0x497a <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    48ea:	80 91 b0 03 	lds	r24, 0x03B0
    48ee:	82 30       	cpi	r24, 0x02	; 2
    48f0:	d0 f3       	brcs	.-12     	; 0x48e6 <prvIdleTask+0xe>
			{
				taskYIELD();
    48f2:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
    48f6:	f7 cf       	rjmp	.-18     	; 0x48e6 <prvIdleTask+0xe>

000048f8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    48f8:	df 93       	push	r29
    48fa:	cf 93       	push	r28
    48fc:	0f 92       	push	r0
    48fe:	cd b7       	in	r28, 0x3d	; 61
    4900:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4902:	19 82       	std	Y+1, r1	; 0x01
    4904:	13 c0       	rjmp	.+38     	; 0x492c <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4906:	89 81       	ldd	r24, Y+1	; 0x01
    4908:	28 2f       	mov	r18, r24
    490a:	30 e0       	ldi	r19, 0x00	; 0
    490c:	c9 01       	movw	r24, r18
    490e:	88 0f       	add	r24, r24
    4910:	99 1f       	adc	r25, r25
    4912:	88 0f       	add	r24, r24
    4914:	99 1f       	adc	r25, r25
    4916:	88 0f       	add	r24, r24
    4918:	99 1f       	adc	r25, r25
    491a:	82 0f       	add	r24, r18
    491c:	93 1f       	adc	r25, r19
    491e:	80 55       	subi	r24, 0x50	; 80
    4920:	9c 4f       	sbci	r25, 0xFC	; 252
    4922:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4926:	89 81       	ldd	r24, Y+1	; 0x01
    4928:	8f 5f       	subi	r24, 0xFF	; 255
    492a:	89 83       	std	Y+1, r24	; 0x01
    492c:	89 81       	ldd	r24, Y+1	; 0x01
    492e:	85 30       	cpi	r24, 0x05	; 5
    4930:	50 f3       	brcs	.-44     	; 0x4906 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4932:	8d ed       	ldi	r24, 0xDD	; 221
    4934:	93 e0       	ldi	r25, 0x03	; 3
    4936:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    493a:	86 ee       	ldi	r24, 0xE6	; 230
    493c:	93 e0       	ldi	r25, 0x03	; 3
    493e:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4942:	83 ef       	ldi	r24, 0xF3	; 243
    4944:	93 e0       	ldi	r25, 0x03	; 3
    4946:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    494a:	8c ef       	ldi	r24, 0xFC	; 252
    494c:	93 e0       	ldi	r25, 0x03	; 3
    494e:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4952:	85 e0       	ldi	r24, 0x05	; 5
    4954:	94 e0       	ldi	r25, 0x04	; 4
    4956:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    495a:	8d ed       	ldi	r24, 0xDD	; 221
    495c:	93 e0       	ldi	r25, 0x03	; 3
    495e:	90 93 f0 03 	sts	0x03F0, r25
    4962:	80 93 ef 03 	sts	0x03EF, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4966:	86 ee       	ldi	r24, 0xE6	; 230
    4968:	93 e0       	ldi	r25, 0x03	; 3
    496a:	90 93 f2 03 	sts	0x03F2, r25
    496e:	80 93 f1 03 	sts	0x03F1, r24
}
    4972:	0f 90       	pop	r0
    4974:	cf 91       	pop	r28
    4976:	df 91       	pop	r29
    4978:	08 95       	ret

0000497a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    497a:	df 93       	push	r29
    497c:	cf 93       	push	r28
    497e:	00 d0       	rcall	.+0      	; 0x4980 <prvCheckTasksWaitingTermination+0x6>
    4980:	0f 92       	push	r0
    4982:	cd b7       	in	r28, 0x3d	; 61
    4984:	de b7       	in	r29, 0x3e	; 62
    4986:	2e c0       	rjmp	.+92     	; 0x49e4 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    4988:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    498c:	80 91 fc 03 	lds	r24, 0x03FC
    4990:	1b 82       	std	Y+3, r1	; 0x03
    4992:	88 23       	and	r24, r24
    4994:	11 f4       	brne	.+4      	; 0x499a <prvCheckTasksWaitingTermination+0x20>
    4996:	81 e0       	ldi	r24, 0x01	; 1
    4998:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    499a:	0e 94 78 20 	call	0x40f0	; 0x40f0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    499e:	8b 81       	ldd	r24, Y+3	; 0x03
    49a0:	88 23       	and	r24, r24
    49a2:	01 f5       	brne	.+64     	; 0x49e4 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    49a4:	0f b6       	in	r0, 0x3f	; 63
    49a6:	f8 94       	cli
    49a8:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    49aa:	e0 91 01 04 	lds	r30, 0x0401
    49ae:	f0 91 02 04 	lds	r31, 0x0402
    49b2:	86 81       	ldd	r24, Z+6	; 0x06
    49b4:	97 81       	ldd	r25, Z+7	; 0x07
    49b6:	9a 83       	std	Y+2, r25	; 0x02
    49b8:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    49ba:	89 81       	ldd	r24, Y+1	; 0x01
    49bc:	9a 81       	ldd	r25, Y+2	; 0x02
    49be:	02 96       	adiw	r24, 0x02	; 2
    49c0:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					--uxCurrentNumberOfTasks;
    49c4:	80 91 a2 03 	lds	r24, 0x03A2
    49c8:	81 50       	subi	r24, 0x01	; 1
    49ca:	80 93 a2 03 	sts	0x03A2, r24
					--uxDeletedTasksWaitingCleanUp;
    49ce:	80 91 a1 03 	lds	r24, 0x03A1
    49d2:	81 50       	subi	r24, 0x01	; 1
    49d4:	80 93 a1 03 	sts	0x03A1, r24
				}
				taskEXIT_CRITICAL();
    49d8:	0f 90       	pop	r0
    49da:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    49dc:	89 81       	ldd	r24, Y+1	; 0x01
    49de:	9a 81       	ldd	r25, Y+2	; 0x02
    49e0:	0e 94 fc 24 	call	0x49f8	; 0x49f8 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    49e4:	80 91 a1 03 	lds	r24, 0x03A1
    49e8:	88 23       	and	r24, r24
    49ea:	71 f6       	brne	.-100    	; 0x4988 <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    49ec:	0f 90       	pop	r0
    49ee:	0f 90       	pop	r0
    49f0:	0f 90       	pop	r0
    49f2:	cf 91       	pop	r28
    49f4:	df 91       	pop	r29
    49f6:	08 95       	ret

000049f8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    49f8:	df 93       	push	r29
    49fa:	cf 93       	push	r28
    49fc:	00 d0       	rcall	.+0      	; 0x49fe <prvDeleteTCB+0x6>
    49fe:	cd b7       	in	r28, 0x3d	; 61
    4a00:	de b7       	in	r29, 0x3e	; 62
    4a02:	9a 83       	std	Y+2, r25	; 0x02
    4a04:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4a06:	e9 81       	ldd	r30, Y+1	; 0x01
    4a08:	fa 81       	ldd	r31, Y+2	; 0x02
    4a0a:	87 89       	ldd	r24, Z+23	; 0x17
    4a0c:	90 8d       	ldd	r25, Z+24	; 0x18
    4a0e:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <vPortFree>
			vPortFree( pxTCB );
    4a12:	89 81       	ldd	r24, Y+1	; 0x01
    4a14:	9a 81       	ldd	r25, Y+2	; 0x02
    4a16:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4a1a:	0f 90       	pop	r0
    4a1c:	0f 90       	pop	r0
    4a1e:	cf 91       	pop	r28
    4a20:	df 91       	pop	r29
    4a22:	08 95       	ret

00004a24 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4a24:	df 93       	push	r29
    4a26:	cf 93       	push	r28
    4a28:	00 d0       	rcall	.+0      	; 0x4a2a <prvResetNextTaskUnblockTime+0x6>
    4a2a:	cd b7       	in	r28, 0x3d	; 61
    4a2c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4a2e:	e0 91 ef 03 	lds	r30, 0x03EF
    4a32:	f0 91 f0 03 	lds	r31, 0x03F0
    4a36:	80 81       	ld	r24, Z
    4a38:	88 23       	and	r24, r24
    4a3a:	39 f4       	brne	.+14     	; 0x4a4a <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4a3c:	8f ef       	ldi	r24, 0xFF	; 255
    4a3e:	9f ef       	ldi	r25, 0xFF	; 255
    4a40:	90 93 ac 03 	sts	0x03AC, r25
    4a44:	80 93 ab 03 	sts	0x03AB, r24
    4a48:	13 c0       	rjmp	.+38     	; 0x4a70 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4a4a:	e0 91 ef 03 	lds	r30, 0x03EF
    4a4e:	f0 91 f0 03 	lds	r31, 0x03F0
    4a52:	05 80       	ldd	r0, Z+5	; 0x05
    4a54:	f6 81       	ldd	r31, Z+6	; 0x06
    4a56:	e0 2d       	mov	r30, r0
    4a58:	86 81       	ldd	r24, Z+6	; 0x06
    4a5a:	97 81       	ldd	r25, Z+7	; 0x07
    4a5c:	9a 83       	std	Y+2, r25	; 0x02
    4a5e:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4a60:	e9 81       	ldd	r30, Y+1	; 0x01
    4a62:	fa 81       	ldd	r31, Y+2	; 0x02
    4a64:	82 81       	ldd	r24, Z+2	; 0x02
    4a66:	93 81       	ldd	r25, Z+3	; 0x03
    4a68:	90 93 ac 03 	sts	0x03AC, r25
    4a6c:	80 93 ab 03 	sts	0x03AB, r24
	}
}
    4a70:	0f 90       	pop	r0
    4a72:	0f 90       	pop	r0
    4a74:	cf 91       	pop	r28
    4a76:	df 91       	pop	r29
    4a78:	08 95       	ret

00004a7a <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4a7a:	df 93       	push	r29
    4a7c:	cf 93       	push	r28
    4a7e:	00 d0       	rcall	.+0      	; 0x4a80 <xTaskGetCurrentTaskHandle+0x6>
    4a80:	cd b7       	in	r28, 0x3d	; 61
    4a82:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4a84:	80 91 9f 03 	lds	r24, 0x039F
    4a88:	90 91 a0 03 	lds	r25, 0x03A0
    4a8c:	9a 83       	std	Y+2, r25	; 0x02
    4a8e:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4a90:	89 81       	ldd	r24, Y+1	; 0x01
    4a92:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4a94:	0f 90       	pop	r0
    4a96:	0f 90       	pop	r0
    4a98:	cf 91       	pop	r28
    4a9a:	df 91       	pop	r29
    4a9c:	08 95       	ret

00004a9e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4a9e:	df 93       	push	r29
    4aa0:	cf 93       	push	r28
    4aa2:	00 d0       	rcall	.+0      	; 0x4aa4 <vTaskPriorityInherit+0x6>
    4aa4:	00 d0       	rcall	.+0      	; 0x4aa6 <vTaskPriorityInherit+0x8>
    4aa6:	cd b7       	in	r28, 0x3d	; 61
    4aa8:	de b7       	in	r29, 0x3e	; 62
    4aaa:	9c 83       	std	Y+4, r25	; 0x04
    4aac:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4aae:	8b 81       	ldd	r24, Y+3	; 0x03
    4ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    4ab2:	9a 83       	std	Y+2, r25	; 0x02
    4ab4:	89 83       	std	Y+1, r24	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    4ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    4aba:	00 97       	sbiw	r24, 0x00	; 0
    4abc:	09 f4       	brne	.+2      	; 0x4ac0 <vTaskPriorityInherit+0x22>
    4abe:	73 c0       	rjmp	.+230    	; 0x4ba6 <vTaskPriorityInherit+0x108>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    4ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac4:	96 89       	ldd	r25, Z+22	; 0x16
    4ac6:	e0 91 9f 03 	lds	r30, 0x039F
    4aca:	f0 91 a0 03 	lds	r31, 0x03A0
    4ace:	86 89       	ldd	r24, Z+22	; 0x16
    4ad0:	98 17       	cp	r25, r24
    4ad2:	08 f0       	brcs	.+2      	; 0x4ad6 <vTaskPriorityInherit+0x38>
    4ad4:	68 c0       	rjmp	.+208    	; 0x4ba6 <vTaskPriorityInherit+0x108>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    4ada:	84 85       	ldd	r24, Z+12	; 0x0c
    4adc:	95 85       	ldd	r25, Z+13	; 0x0d
    4ade:	99 23       	and	r25, r25
    4ae0:	7c f0       	brlt	.+30     	; 0x4b00 <vTaskPriorityInherit+0x62>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4ae2:	e0 91 9f 03 	lds	r30, 0x039F
    4ae6:	f0 91 a0 03 	lds	r31, 0x03A0
    4aea:	86 89       	ldd	r24, Z+22	; 0x16
    4aec:	28 2f       	mov	r18, r24
    4aee:	30 e0       	ldi	r19, 0x00	; 0
    4af0:	85 e0       	ldi	r24, 0x05	; 5
    4af2:	90 e0       	ldi	r25, 0x00	; 0
    4af4:	82 1b       	sub	r24, r18
    4af6:	93 0b       	sbc	r25, r19
    4af8:	e9 81       	ldd	r30, Y+1	; 0x01
    4afa:	fa 81       	ldd	r31, Y+2	; 0x02
    4afc:	95 87       	std	Z+13, r25	; 0x0d
    4afe:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    4b00:	e9 81       	ldd	r30, Y+1	; 0x01
    4b02:	fa 81       	ldd	r31, Y+2	; 0x02
    4b04:	42 85       	ldd	r20, Z+10	; 0x0a
    4b06:	53 85       	ldd	r21, Z+11	; 0x0b
    4b08:	e9 81       	ldd	r30, Y+1	; 0x01
    4b0a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b0c:	86 89       	ldd	r24, Z+22	; 0x16
    4b0e:	28 2f       	mov	r18, r24
    4b10:	30 e0       	ldi	r19, 0x00	; 0
    4b12:	c9 01       	movw	r24, r18
    4b14:	88 0f       	add	r24, r24
    4b16:	99 1f       	adc	r25, r25
    4b18:	88 0f       	add	r24, r24
    4b1a:	99 1f       	adc	r25, r25
    4b1c:	88 0f       	add	r24, r24
    4b1e:	99 1f       	adc	r25, r25
    4b20:	82 0f       	add	r24, r18
    4b22:	93 1f       	adc	r25, r19
    4b24:	80 55       	subi	r24, 0x50	; 80
    4b26:	9c 4f       	sbci	r25, 0xFC	; 252
    4b28:	48 17       	cp	r20, r24
    4b2a:	59 07       	cpc	r21, r25
    4b2c:	a1 f5       	brne	.+104    	; 0x4b96 <vTaskPriorityInherit+0xf8>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4b2e:	89 81       	ldd	r24, Y+1	; 0x01
    4b30:	9a 81       	ldd	r25, Y+2	; 0x02
    4b32:	02 96       	adiw	r24, 0x02	; 2
    4b34:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4b38:	e0 91 9f 03 	lds	r30, 0x039F
    4b3c:	f0 91 a0 03 	lds	r31, 0x03A0
    4b40:	86 89       	ldd	r24, Z+22	; 0x16
    4b42:	e9 81       	ldd	r30, Y+1	; 0x01
    4b44:	fa 81       	ldd	r31, Y+2	; 0x02
    4b46:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    4b48:	e9 81       	ldd	r30, Y+1	; 0x01
    4b4a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4c:	96 89       	ldd	r25, Z+22	; 0x16
    4b4e:	80 91 a5 03 	lds	r24, 0x03A5
    4b52:	89 17       	cp	r24, r25
    4b54:	28 f4       	brcc	.+10     	; 0x4b60 <vTaskPriorityInherit+0xc2>
    4b56:	e9 81       	ldd	r30, Y+1	; 0x01
    4b58:	fa 81       	ldd	r31, Y+2	; 0x02
    4b5a:	86 89       	ldd	r24, Z+22	; 0x16
    4b5c:	80 93 a5 03 	sts	0x03A5, r24
    4b60:	e9 81       	ldd	r30, Y+1	; 0x01
    4b62:	fa 81       	ldd	r31, Y+2	; 0x02
    4b64:	86 89       	ldd	r24, Z+22	; 0x16
    4b66:	28 2f       	mov	r18, r24
    4b68:	30 e0       	ldi	r19, 0x00	; 0
    4b6a:	c9 01       	movw	r24, r18
    4b6c:	88 0f       	add	r24, r24
    4b6e:	99 1f       	adc	r25, r25
    4b70:	88 0f       	add	r24, r24
    4b72:	99 1f       	adc	r25, r25
    4b74:	88 0f       	add	r24, r24
    4b76:	99 1f       	adc	r25, r25
    4b78:	82 0f       	add	r24, r18
    4b7a:	93 1f       	adc	r25, r19
    4b7c:	ac 01       	movw	r20, r24
    4b7e:	40 55       	subi	r20, 0x50	; 80
    4b80:	5c 4f       	sbci	r21, 0xFC	; 252
    4b82:	89 81       	ldd	r24, Y+1	; 0x01
    4b84:	9a 81       	ldd	r25, Y+2	; 0x02
    4b86:	9c 01       	movw	r18, r24
    4b88:	2e 5f       	subi	r18, 0xFE	; 254
    4b8a:	3f 4f       	sbci	r19, 0xFF	; 255
    4b8c:	ca 01       	movw	r24, r20
    4b8e:	b9 01       	movw	r22, r18
    4b90:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
    4b94:	08 c0       	rjmp	.+16     	; 0x4ba6 <vTaskPriorityInherit+0x108>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    4b96:	e0 91 9f 03 	lds	r30, 0x039F
    4b9a:	f0 91 a0 03 	lds	r31, 0x03A0
    4b9e:	86 89       	ldd	r24, Z+22	; 0x16
    4ba0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ba2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ba4:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    4ba6:	0f 90       	pop	r0
    4ba8:	0f 90       	pop	r0
    4baa:	0f 90       	pop	r0
    4bac:	0f 90       	pop	r0
    4bae:	cf 91       	pop	r28
    4bb0:	df 91       	pop	r29
    4bb2:	08 95       	ret

00004bb4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    4bb4:	df 93       	push	r29
    4bb6:	cf 93       	push	r28
    4bb8:	00 d0       	rcall	.+0      	; 0x4bba <xTaskPriorityDisinherit+0x6>
    4bba:	00 d0       	rcall	.+0      	; 0x4bbc <xTaskPriorityDisinherit+0x8>
    4bbc:	0f 92       	push	r0
    4bbe:	cd b7       	in	r28, 0x3d	; 61
    4bc0:	de b7       	in	r29, 0x3e	; 62
    4bc2:	9d 83       	std	Y+5, r25	; 0x05
    4bc4:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    4bc6:	8c 81       	ldd	r24, Y+4	; 0x04
    4bc8:	9d 81       	ldd	r25, Y+5	; 0x05
    4bca:	9b 83       	std	Y+3, r25	; 0x03
    4bcc:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    4bce:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    4bd0:	8c 81       	ldd	r24, Y+4	; 0x04
    4bd2:	9d 81       	ldd	r25, Y+5	; 0x05
    4bd4:	00 97       	sbiw	r24, 0x00	; 0
    4bd6:	09 f4       	brne	.+2      	; 0x4bda <xTaskPriorityDisinherit+0x26>
    4bd8:	56 c0       	rjmp	.+172    	; 0x4c86 <xTaskPriorityDisinherit+0xd2>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    4bda:	ea 81       	ldd	r30, Y+2	; 0x02
    4bdc:	fb 81       	ldd	r31, Y+3	; 0x03
    4bde:	84 a1       	ldd	r24, Z+36	; 0x24
    4be0:	81 50       	subi	r24, 0x01	; 1
    4be2:	ea 81       	ldd	r30, Y+2	; 0x02
    4be4:	fb 81       	ldd	r31, Y+3	; 0x03
    4be6:	84 a3       	std	Z+36, r24	; 0x24

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4be8:	ea 81       	ldd	r30, Y+2	; 0x02
    4bea:	fb 81       	ldd	r31, Y+3	; 0x03
    4bec:	96 89       	ldd	r25, Z+22	; 0x16
    4bee:	ea 81       	ldd	r30, Y+2	; 0x02
    4bf0:	fb 81       	ldd	r31, Y+3	; 0x03
    4bf2:	83 a1       	ldd	r24, Z+35	; 0x23
    4bf4:	98 17       	cp	r25, r24
    4bf6:	09 f4       	brne	.+2      	; 0x4bfa <xTaskPriorityDisinherit+0x46>
    4bf8:	46 c0       	rjmp	.+140    	; 0x4c86 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4bfa:	ea 81       	ldd	r30, Y+2	; 0x02
    4bfc:	fb 81       	ldd	r31, Y+3	; 0x03
    4bfe:	84 a1       	ldd	r24, Z+36	; 0x24
    4c00:	88 23       	and	r24, r24
    4c02:	09 f0       	breq	.+2      	; 0x4c06 <xTaskPriorityDisinherit+0x52>
    4c04:	40 c0       	rjmp	.+128    	; 0x4c86 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4c06:	8a 81       	ldd	r24, Y+2	; 0x02
    4c08:	9b 81       	ldd	r25, Y+3	; 0x03
    4c0a:	02 96       	adiw	r24, 0x02	; 2
    4c0c:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    4c10:	ea 81       	ldd	r30, Y+2	; 0x02
    4c12:	fb 81       	ldd	r31, Y+3	; 0x03
    4c14:	83 a1       	ldd	r24, Z+35	; 0x23
    4c16:	ea 81       	ldd	r30, Y+2	; 0x02
    4c18:	fb 81       	ldd	r31, Y+3	; 0x03
    4c1a:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4c1c:	ea 81       	ldd	r30, Y+2	; 0x02
    4c1e:	fb 81       	ldd	r31, Y+3	; 0x03
    4c20:	86 89       	ldd	r24, Z+22	; 0x16
    4c22:	28 2f       	mov	r18, r24
    4c24:	30 e0       	ldi	r19, 0x00	; 0
    4c26:	85 e0       	ldi	r24, 0x05	; 5
    4c28:	90 e0       	ldi	r25, 0x00	; 0
    4c2a:	82 1b       	sub	r24, r18
    4c2c:	93 0b       	sbc	r25, r19
    4c2e:	ea 81       	ldd	r30, Y+2	; 0x02
    4c30:	fb 81       	ldd	r31, Y+3	; 0x03
    4c32:	95 87       	std	Z+13, r25	; 0x0d
    4c34:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    4c36:	ea 81       	ldd	r30, Y+2	; 0x02
    4c38:	fb 81       	ldd	r31, Y+3	; 0x03
    4c3a:	96 89       	ldd	r25, Z+22	; 0x16
    4c3c:	80 91 a5 03 	lds	r24, 0x03A5
    4c40:	89 17       	cp	r24, r25
    4c42:	28 f4       	brcc	.+10     	; 0x4c4e <xTaskPriorityDisinherit+0x9a>
    4c44:	ea 81       	ldd	r30, Y+2	; 0x02
    4c46:	fb 81       	ldd	r31, Y+3	; 0x03
    4c48:	86 89       	ldd	r24, Z+22	; 0x16
    4c4a:	80 93 a5 03 	sts	0x03A5, r24
    4c4e:	ea 81       	ldd	r30, Y+2	; 0x02
    4c50:	fb 81       	ldd	r31, Y+3	; 0x03
    4c52:	86 89       	ldd	r24, Z+22	; 0x16
    4c54:	28 2f       	mov	r18, r24
    4c56:	30 e0       	ldi	r19, 0x00	; 0
    4c58:	c9 01       	movw	r24, r18
    4c5a:	88 0f       	add	r24, r24
    4c5c:	99 1f       	adc	r25, r25
    4c5e:	88 0f       	add	r24, r24
    4c60:	99 1f       	adc	r25, r25
    4c62:	88 0f       	add	r24, r24
    4c64:	99 1f       	adc	r25, r25
    4c66:	82 0f       	add	r24, r18
    4c68:	93 1f       	adc	r25, r19
    4c6a:	ac 01       	movw	r20, r24
    4c6c:	40 55       	subi	r20, 0x50	; 80
    4c6e:	5c 4f       	sbci	r21, 0xFC	; 252
    4c70:	8a 81       	ldd	r24, Y+2	; 0x02
    4c72:	9b 81       	ldd	r25, Y+3	; 0x03
    4c74:	9c 01       	movw	r18, r24
    4c76:	2e 5f       	subi	r18, 0xFE	; 254
    4c78:	3f 4f       	sbci	r19, 0xFF	; 255
    4c7a:	ca 01       	movw	r24, r20
    4c7c:	b9 01       	movw	r22, r18
    4c7e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    4c82:	81 e0       	ldi	r24, 0x01	; 1
    4c84:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    4c86:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4c88:	0f 90       	pop	r0
    4c8a:	0f 90       	pop	r0
    4c8c:	0f 90       	pop	r0
    4c8e:	0f 90       	pop	r0
    4c90:	0f 90       	pop	r0
    4c92:	cf 91       	pop	r28
    4c94:	df 91       	pop	r29
    4c96:	08 95       	ret

00004c98 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4c98:	df 93       	push	r29
    4c9a:	cf 93       	push	r28
    4c9c:	00 d0       	rcall	.+0      	; 0x4c9e <uxTaskResetEventItemValue+0x6>
    4c9e:	cd b7       	in	r28, 0x3d	; 61
    4ca0:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4ca2:	e0 91 9f 03 	lds	r30, 0x039F
    4ca6:	f0 91 a0 03 	lds	r31, 0x03A0
    4caa:	84 85       	ldd	r24, Z+12	; 0x0c
    4cac:	95 85       	ldd	r25, Z+13	; 0x0d
    4cae:	9a 83       	std	Y+2, r25	; 0x02
    4cb0:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4cb2:	a0 91 9f 03 	lds	r26, 0x039F
    4cb6:	b0 91 a0 03 	lds	r27, 0x03A0
    4cba:	e0 91 9f 03 	lds	r30, 0x039F
    4cbe:	f0 91 a0 03 	lds	r31, 0x03A0
    4cc2:	86 89       	ldd	r24, Z+22	; 0x16
    4cc4:	28 2f       	mov	r18, r24
    4cc6:	30 e0       	ldi	r19, 0x00	; 0
    4cc8:	85 e0       	ldi	r24, 0x05	; 5
    4cca:	90 e0       	ldi	r25, 0x00	; 0
    4ccc:	82 1b       	sub	r24, r18
    4cce:	93 0b       	sbc	r25, r19
    4cd0:	1d 96       	adiw	r26, 0x0d	; 13
    4cd2:	9c 93       	st	X, r25
    4cd4:	8e 93       	st	-X, r24
    4cd6:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4cd8:	89 81       	ldd	r24, Y+1	; 0x01
    4cda:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4cdc:	0f 90       	pop	r0
    4cde:	0f 90       	pop	r0
    4ce0:	cf 91       	pop	r28
    4ce2:	df 91       	pop	r29
    4ce4:	08 95       	ret

00004ce6 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    4ce6:	df 93       	push	r29
    4ce8:	cf 93       	push	r28
    4cea:	cd b7       	in	r28, 0x3d	; 61
    4cec:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4cee:	80 91 9f 03 	lds	r24, 0x039F
    4cf2:	90 91 a0 03 	lds	r25, 0x03A0
    4cf6:	00 97       	sbiw	r24, 0x00	; 0
    4cf8:	39 f0       	breq	.+14     	; 0x4d08 <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    4cfa:	e0 91 9f 03 	lds	r30, 0x039F
    4cfe:	f0 91 a0 03 	lds	r31, 0x03A0
    4d02:	84 a1       	ldd	r24, Z+36	; 0x24
    4d04:	8f 5f       	subi	r24, 0xFF	; 255
    4d06:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    4d08:	80 91 9f 03 	lds	r24, 0x039F
    4d0c:	90 91 a0 03 	lds	r25, 0x03A0
	}
    4d10:	cf 91       	pop	r28
    4d12:	df 91       	pop	r29
    4d14:	08 95       	ret

00004d16 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4d16:	df 93       	push	r29
    4d18:	cf 93       	push	r28
    4d1a:	cd b7       	in	r28, 0x3d	; 61
    4d1c:	de b7       	in	r29, 0x3e	; 62
    4d1e:	27 97       	sbiw	r28, 0x07	; 7
    4d20:	0f b6       	in	r0, 0x3f	; 63
    4d22:	f8 94       	cli
    4d24:	de bf       	out	0x3e, r29	; 62
    4d26:	0f be       	out	0x3f, r0	; 63
    4d28:	cd bf       	out	0x3d, r28	; 61
    4d2a:	8d 83       	std	Y+5, r24	; 0x05
    4d2c:	7f 83       	std	Y+7, r23	; 0x07
    4d2e:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4d30:	0f b6       	in	r0, 0x3f	; 63
    4d32:	f8 94       	cli
    4d34:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4d36:	e0 91 9f 03 	lds	r30, 0x039F
    4d3a:	f0 91 a0 03 	lds	r31, 0x03A0
    4d3e:	85 a1       	ldd	r24, Z+37	; 0x25
    4d40:	96 a1       	ldd	r25, Z+38	; 0x26
    4d42:	a7 a1       	ldd	r26, Z+39	; 0x27
    4d44:	b0 a5       	ldd	r27, Z+40	; 0x28
    4d46:	00 97       	sbiw	r24, 0x00	; 0
    4d48:	a1 05       	cpc	r26, r1
    4d4a:	b1 05       	cpc	r27, r1
    4d4c:	89 f4       	brne	.+34     	; 0x4d70 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4d4e:	e0 91 9f 03 	lds	r30, 0x039F
    4d52:	f0 91 a0 03 	lds	r31, 0x03A0
    4d56:	81 e0       	ldi	r24, 0x01	; 1
    4d58:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4d5a:	8e 81       	ldd	r24, Y+6	; 0x06
    4d5c:	9f 81       	ldd	r25, Y+7	; 0x07
    4d5e:	00 97       	sbiw	r24, 0x00	; 0
    4d60:	39 f0       	breq	.+14     	; 0x4d70 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4d62:	8e 81       	ldd	r24, Y+6	; 0x06
    4d64:	9f 81       	ldd	r25, Y+7	; 0x07
    4d66:	61 e0       	ldi	r22, 0x01	; 1
    4d68:	0e 94 35 2a 	call	0x546a	; 0x546a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4d6c:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4d70:	0f 90       	pop	r0
    4d72:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4d74:	0f b6       	in	r0, 0x3f	; 63
    4d76:	f8 94       	cli
    4d78:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4d7a:	e0 91 9f 03 	lds	r30, 0x039F
    4d7e:	f0 91 a0 03 	lds	r31, 0x03A0
    4d82:	85 a1       	ldd	r24, Z+37	; 0x25
    4d84:	96 a1       	ldd	r25, Z+38	; 0x26
    4d86:	a7 a1       	ldd	r26, Z+39	; 0x27
    4d88:	b0 a5       	ldd	r27, Z+40	; 0x28
    4d8a:	89 83       	std	Y+1, r24	; 0x01
    4d8c:	9a 83       	std	Y+2, r25	; 0x02
    4d8e:	ab 83       	std	Y+3, r26	; 0x03
    4d90:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4d92:	89 81       	ldd	r24, Y+1	; 0x01
    4d94:	9a 81       	ldd	r25, Y+2	; 0x02
    4d96:	ab 81       	ldd	r26, Y+3	; 0x03
    4d98:	bc 81       	ldd	r27, Y+4	; 0x04
    4d9a:	00 97       	sbiw	r24, 0x00	; 0
    4d9c:	a1 05       	cpc	r26, r1
    4d9e:	b1 05       	cpc	r27, r1
    4da0:	d9 f0       	breq	.+54     	; 0x4dd8 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4da2:	8d 81       	ldd	r24, Y+5	; 0x05
    4da4:	88 23       	and	r24, r24
    4da6:	49 f0       	breq	.+18     	; 0x4dba <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4da8:	e0 91 9f 03 	lds	r30, 0x039F
    4dac:	f0 91 a0 03 	lds	r31, 0x03A0
    4db0:	15 a2       	std	Z+37, r1	; 0x25
    4db2:	16 a2       	std	Z+38, r1	; 0x26
    4db4:	17 a2       	std	Z+39, r1	; 0x27
    4db6:	10 a6       	std	Z+40, r1	; 0x28
    4db8:	0f c0       	rjmp	.+30     	; 0x4dd8 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    4dba:	e0 91 9f 03 	lds	r30, 0x039F
    4dbe:	f0 91 a0 03 	lds	r31, 0x03A0
    4dc2:	89 81       	ldd	r24, Y+1	; 0x01
    4dc4:	9a 81       	ldd	r25, Y+2	; 0x02
    4dc6:	ab 81       	ldd	r26, Y+3	; 0x03
    4dc8:	bc 81       	ldd	r27, Y+4	; 0x04
    4dca:	01 97       	sbiw	r24, 0x01	; 1
    4dcc:	a1 09       	sbc	r26, r1
    4dce:	b1 09       	sbc	r27, r1
    4dd0:	85 a3       	std	Z+37, r24	; 0x25
    4dd2:	96 a3       	std	Z+38, r25	; 0x26
    4dd4:	a7 a3       	std	Z+39, r26	; 0x27
    4dd6:	b0 a7       	std	Z+40, r27	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4dd8:	e0 91 9f 03 	lds	r30, 0x039F
    4ddc:	f0 91 a0 03 	lds	r31, 0x03A0
    4de0:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4de2:	0f 90       	pop	r0
    4de4:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4de6:	89 81       	ldd	r24, Y+1	; 0x01
    4de8:	9a 81       	ldd	r25, Y+2	; 0x02
    4dea:	ab 81       	ldd	r26, Y+3	; 0x03
    4dec:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4dee:	bc 01       	movw	r22, r24
    4df0:	cd 01       	movw	r24, r26
    4df2:	27 96       	adiw	r28, 0x07	; 7
    4df4:	0f b6       	in	r0, 0x3f	; 63
    4df6:	f8 94       	cli
    4df8:	de bf       	out	0x3e, r29	; 62
    4dfa:	0f be       	out	0x3f, r0	; 63
    4dfc:	cd bf       	out	0x3d, r28	; 61
    4dfe:	cf 91       	pop	r28
    4e00:	df 91       	pop	r29
    4e02:	08 95       	ret

00004e04 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4e04:	ef 92       	push	r14
    4e06:	ff 92       	push	r15
    4e08:	0f 93       	push	r16
    4e0a:	1f 93       	push	r17
    4e0c:	df 93       	push	r29
    4e0e:	cf 93       	push	r28
    4e10:	cd b7       	in	r28, 0x3d	; 61
    4e12:	de b7       	in	r29, 0x3e	; 62
    4e14:	2d 97       	sbiw	r28, 0x0d	; 13
    4e16:	0f b6       	in	r0, 0x3f	; 63
    4e18:	f8 94       	cli
    4e1a:	de bf       	out	0x3e, r29	; 62
    4e1c:	0f be       	out	0x3f, r0	; 63
    4e1e:	cd bf       	out	0x3d, r28	; 61
    4e20:	6a 83       	std	Y+2, r22	; 0x02
    4e22:	7b 83       	std	Y+3, r23	; 0x03
    4e24:	8c 83       	std	Y+4, r24	; 0x04
    4e26:	9d 83       	std	Y+5, r25	; 0x05
    4e28:	2e 83       	std	Y+6, r18	; 0x06
    4e2a:	3f 83       	std	Y+7, r19	; 0x07
    4e2c:	48 87       	std	Y+8, r20	; 0x08
    4e2e:	59 87       	std	Y+9, r21	; 0x09
    4e30:	1b 87       	std	Y+11, r17	; 0x0b
    4e32:	0a 87       	std	Y+10, r16	; 0x0a
    4e34:	fd 86       	std	Y+13, r15	; 0x0d
    4e36:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4e38:	0f b6       	in	r0, 0x3f	; 63
    4e3a:	f8 94       	cli
    4e3c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4e3e:	e0 91 9f 03 	lds	r30, 0x039F
    4e42:	f0 91 a0 03 	lds	r31, 0x03A0
    4e46:	81 a5       	ldd	r24, Z+41	; 0x29
    4e48:	82 30       	cpi	r24, 0x02	; 2
    4e4a:	49 f1       	breq	.+82     	; 0x4e9e <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4e4c:	e0 91 9f 03 	lds	r30, 0x039F
    4e50:	f0 91 a0 03 	lds	r31, 0x03A0
    4e54:	25 a1       	ldd	r18, Z+37	; 0x25
    4e56:	36 a1       	ldd	r19, Z+38	; 0x26
    4e58:	47 a1       	ldd	r20, Z+39	; 0x27
    4e5a:	50 a5       	ldd	r21, Z+40	; 0x28
    4e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e5e:	9b 81       	ldd	r25, Y+3	; 0x03
    4e60:	ac 81       	ldd	r26, Y+4	; 0x04
    4e62:	bd 81       	ldd	r27, Y+5	; 0x05
    4e64:	80 95       	com	r24
    4e66:	90 95       	com	r25
    4e68:	a0 95       	com	r26
    4e6a:	b0 95       	com	r27
    4e6c:	82 23       	and	r24, r18
    4e6e:	93 23       	and	r25, r19
    4e70:	a4 23       	and	r26, r20
    4e72:	b5 23       	and	r27, r21
    4e74:	85 a3       	std	Z+37, r24	; 0x25
    4e76:	96 a3       	std	Z+38, r25	; 0x26
    4e78:	a7 a3       	std	Z+39, r26	; 0x27
    4e7a:	b0 a7       	std	Z+40, r27	; 0x28

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4e7c:	e0 91 9f 03 	lds	r30, 0x039F
    4e80:	f0 91 a0 03 	lds	r31, 0x03A0
    4e84:	81 e0       	ldi	r24, 0x01	; 1
    4e86:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4e88:	8c 85       	ldd	r24, Y+12	; 0x0c
    4e8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4e8c:	00 97       	sbiw	r24, 0x00	; 0
    4e8e:	39 f0       	breq	.+14     	; 0x4e9e <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4e90:	8c 85       	ldd	r24, Y+12	; 0x0c
    4e92:	9d 85       	ldd	r25, Y+13	; 0x0d
    4e94:	61 e0       	ldi	r22, 0x01	; 1
    4e96:	0e 94 35 2a 	call	0x546a	; 0x546a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4e9a:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4e9e:	0f 90       	pop	r0
    4ea0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4ea2:	0f b6       	in	r0, 0x3f	; 63
    4ea4:	f8 94       	cli
    4ea6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4ea8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4eaa:	9b 85       	ldd	r25, Y+11	; 0x0b
    4eac:	00 97       	sbiw	r24, 0x00	; 0
    4eae:	71 f0       	breq	.+28     	; 0x4ecc <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4eb0:	e0 91 9f 03 	lds	r30, 0x039F
    4eb4:	f0 91 a0 03 	lds	r31, 0x03A0
    4eb8:	85 a1       	ldd	r24, Z+37	; 0x25
    4eba:	96 a1       	ldd	r25, Z+38	; 0x26
    4ebc:	a7 a1       	ldd	r26, Z+39	; 0x27
    4ebe:	b0 a5       	ldd	r27, Z+40	; 0x28
    4ec0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ec2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ec4:	80 83       	st	Z, r24
    4ec6:	91 83       	std	Z+1, r25	; 0x01
    4ec8:	a2 83       	std	Z+2, r26	; 0x02
    4eca:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4ecc:	e0 91 9f 03 	lds	r30, 0x039F
    4ed0:	f0 91 a0 03 	lds	r31, 0x03A0
    4ed4:	81 a5       	ldd	r24, Z+41	; 0x29
    4ed6:	81 30       	cpi	r24, 0x01	; 1
    4ed8:	11 f4       	brne	.+4      	; 0x4ede <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4eda:	19 82       	std	Y+1, r1	; 0x01
    4edc:	1a c0       	rjmp	.+52     	; 0x4f12 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4ede:	e0 91 9f 03 	lds	r30, 0x039F
    4ee2:	f0 91 a0 03 	lds	r31, 0x03A0
    4ee6:	25 a1       	ldd	r18, Z+37	; 0x25
    4ee8:	36 a1       	ldd	r19, Z+38	; 0x26
    4eea:	47 a1       	ldd	r20, Z+39	; 0x27
    4eec:	50 a5       	ldd	r21, Z+40	; 0x28
    4eee:	8e 81       	ldd	r24, Y+6	; 0x06
    4ef0:	9f 81       	ldd	r25, Y+7	; 0x07
    4ef2:	a8 85       	ldd	r26, Y+8	; 0x08
    4ef4:	b9 85       	ldd	r27, Y+9	; 0x09
    4ef6:	80 95       	com	r24
    4ef8:	90 95       	com	r25
    4efa:	a0 95       	com	r26
    4efc:	b0 95       	com	r27
    4efe:	82 23       	and	r24, r18
    4f00:	93 23       	and	r25, r19
    4f02:	a4 23       	and	r26, r20
    4f04:	b5 23       	and	r27, r21
    4f06:	85 a3       	std	Z+37, r24	; 0x25
    4f08:	96 a3       	std	Z+38, r25	; 0x26
    4f0a:	a7 a3       	std	Z+39, r26	; 0x27
    4f0c:	b0 a7       	std	Z+40, r27	; 0x28
				xReturn = pdTRUE;
    4f0e:	81 e0       	ldi	r24, 0x01	; 1
    4f10:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4f12:	e0 91 9f 03 	lds	r30, 0x039F
    4f16:	f0 91 a0 03 	lds	r31, 0x03A0
    4f1a:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4f1c:	0f 90       	pop	r0
    4f1e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4f20:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4f22:	2d 96       	adiw	r28, 0x0d	; 13
    4f24:	0f b6       	in	r0, 0x3f	; 63
    4f26:	f8 94       	cli
    4f28:	de bf       	out	0x3e, r29	; 62
    4f2a:	0f be       	out	0x3f, r0	; 63
    4f2c:	cd bf       	out	0x3d, r28	; 61
    4f2e:	cf 91       	pop	r28
    4f30:	df 91       	pop	r29
    4f32:	1f 91       	pop	r17
    4f34:	0f 91       	pop	r16
    4f36:	ff 90       	pop	r15
    4f38:	ef 90       	pop	r14
    4f3a:	08 95       	ret

00004f3c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4f3c:	0f 93       	push	r16
    4f3e:	1f 93       	push	r17
    4f40:	df 93       	push	r29
    4f42:	cf 93       	push	r28
    4f44:	cd b7       	in	r28, 0x3d	; 61
    4f46:	de b7       	in	r29, 0x3e	; 62
    4f48:	2f 97       	sbiw	r28, 0x0f	; 15
    4f4a:	0f b6       	in	r0, 0x3f	; 63
    4f4c:	f8 94       	cli
    4f4e:	de bf       	out	0x3e, r29	; 62
    4f50:	0f be       	out	0x3f, r0	; 63
    4f52:	cd bf       	out	0x3d, r28	; 61
    4f54:	9e 83       	std	Y+6, r25	; 0x06
    4f56:	8d 83       	std	Y+5, r24	; 0x05
    4f58:	4f 83       	std	Y+7, r20	; 0x07
    4f5a:	58 87       	std	Y+8, r21	; 0x08
    4f5c:	69 87       	std	Y+9, r22	; 0x09
    4f5e:	7a 87       	std	Y+10, r23	; 0x0a
    4f60:	2b 87       	std	Y+11, r18	; 0x0b
    4f62:	1d 87       	std	Y+13, r17	; 0x0d
    4f64:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4f66:	81 e0       	ldi	r24, 0x01	; 1
    4f68:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    4f6a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f6c:	9e 81       	ldd	r25, Y+6	; 0x06
    4f6e:	9c 83       	std	Y+4, r25	; 0x04
    4f70:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4f72:	0f b6       	in	r0, 0x3f	; 63
    4f74:	f8 94       	cli
    4f76:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4f78:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4f7c:	00 97       	sbiw	r24, 0x00	; 0
    4f7e:	61 f0       	breq	.+24     	; 0x4f98 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4f80:	eb 81       	ldd	r30, Y+3	; 0x03
    4f82:	fc 81       	ldd	r31, Y+4	; 0x04
    4f84:	85 a1       	ldd	r24, Z+37	; 0x25
    4f86:	96 a1       	ldd	r25, Z+38	; 0x26
    4f88:	a7 a1       	ldd	r26, Z+39	; 0x27
    4f8a:	b0 a5       	ldd	r27, Z+40	; 0x28
    4f8c:	ec 85       	ldd	r30, Y+12	; 0x0c
    4f8e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4f90:	80 83       	st	Z, r24
    4f92:	91 83       	std	Z+1, r25	; 0x01
    4f94:	a2 83       	std	Z+2, r26	; 0x02
    4f96:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4f98:	eb 81       	ldd	r30, Y+3	; 0x03
    4f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4f9c:	81 a5       	ldd	r24, Z+41	; 0x29
    4f9e:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4fa0:	eb 81       	ldd	r30, Y+3	; 0x03
    4fa2:	fc 81       	ldd	r31, Y+4	; 0x04
    4fa4:	82 e0       	ldi	r24, 0x02	; 2
    4fa6:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    4fa8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4faa:	28 2f       	mov	r18, r24
    4fac:	30 e0       	ldi	r19, 0x00	; 0
    4fae:	3f 87       	std	Y+15, r19	; 0x0f
    4fb0:	2e 87       	std	Y+14, r18	; 0x0e
    4fb2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fb4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4fb6:	82 30       	cpi	r24, 0x02	; 2
    4fb8:	91 05       	cpc	r25, r1
    4fba:	59 f1       	breq	.+86     	; 0x5012 <xTaskGenericNotify+0xd6>
    4fbc:	2e 85       	ldd	r18, Y+14	; 0x0e
    4fbe:	3f 85       	ldd	r19, Y+15	; 0x0f
    4fc0:	23 30       	cpi	r18, 0x03	; 3
    4fc2:	31 05       	cpc	r19, r1
    4fc4:	34 f4       	brge	.+12     	; 0x4fd2 <xTaskGenericNotify+0x96>
    4fc6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fc8:	9f 85       	ldd	r25, Y+15	; 0x0f
    4fca:	81 30       	cpi	r24, 0x01	; 1
    4fcc:	91 05       	cpc	r25, r1
    4fce:	61 f0       	breq	.+24     	; 0x4fe8 <xTaskGenericNotify+0xac>
    4fd0:	4a c0       	rjmp	.+148    	; 0x5066 <xTaskGenericNotify+0x12a>
    4fd2:	2e 85       	ldd	r18, Y+14	; 0x0e
    4fd4:	3f 85       	ldd	r19, Y+15	; 0x0f
    4fd6:	23 30       	cpi	r18, 0x03	; 3
    4fd8:	31 05       	cpc	r19, r1
    4fda:	59 f1       	breq	.+86     	; 0x5032 <xTaskGenericNotify+0xf6>
    4fdc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fde:	9f 85       	ldd	r25, Y+15	; 0x0f
    4fe0:	84 30       	cpi	r24, 0x04	; 4
    4fe2:	91 05       	cpc	r25, r1
    4fe4:	89 f1       	breq	.+98     	; 0x5048 <xTaskGenericNotify+0x10c>
    4fe6:	3f c0       	rjmp	.+126    	; 0x5066 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    4fea:	fc 81       	ldd	r31, Y+4	; 0x04
    4fec:	25 a1       	ldd	r18, Z+37	; 0x25
    4fee:	36 a1       	ldd	r19, Z+38	; 0x26
    4ff0:	47 a1       	ldd	r20, Z+39	; 0x27
    4ff2:	50 a5       	ldd	r21, Z+40	; 0x28
    4ff4:	8f 81       	ldd	r24, Y+7	; 0x07
    4ff6:	98 85       	ldd	r25, Y+8	; 0x08
    4ff8:	a9 85       	ldd	r26, Y+9	; 0x09
    4ffa:	ba 85       	ldd	r27, Y+10	; 0x0a
    4ffc:	82 2b       	or	r24, r18
    4ffe:	93 2b       	or	r25, r19
    5000:	a4 2b       	or	r26, r20
    5002:	b5 2b       	or	r27, r21
    5004:	eb 81       	ldd	r30, Y+3	; 0x03
    5006:	fc 81       	ldd	r31, Y+4	; 0x04
    5008:	85 a3       	std	Z+37, r24	; 0x25
    500a:	96 a3       	std	Z+38, r25	; 0x26
    500c:	a7 a3       	std	Z+39, r26	; 0x27
    500e:	b0 a7       	std	Z+40, r27	; 0x28
    5010:	2a c0       	rjmp	.+84     	; 0x5066 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5012:	eb 81       	ldd	r30, Y+3	; 0x03
    5014:	fc 81       	ldd	r31, Y+4	; 0x04
    5016:	85 a1       	ldd	r24, Z+37	; 0x25
    5018:	96 a1       	ldd	r25, Z+38	; 0x26
    501a:	a7 a1       	ldd	r26, Z+39	; 0x27
    501c:	b0 a5       	ldd	r27, Z+40	; 0x28
    501e:	01 96       	adiw	r24, 0x01	; 1
    5020:	a1 1d       	adc	r26, r1
    5022:	b1 1d       	adc	r27, r1
    5024:	eb 81       	ldd	r30, Y+3	; 0x03
    5026:	fc 81       	ldd	r31, Y+4	; 0x04
    5028:	85 a3       	std	Z+37, r24	; 0x25
    502a:	96 a3       	std	Z+38, r25	; 0x26
    502c:	a7 a3       	std	Z+39, r26	; 0x27
    502e:	b0 a7       	std	Z+40, r27	; 0x28
    5030:	1a c0       	rjmp	.+52     	; 0x5066 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5032:	eb 81       	ldd	r30, Y+3	; 0x03
    5034:	fc 81       	ldd	r31, Y+4	; 0x04
    5036:	8f 81       	ldd	r24, Y+7	; 0x07
    5038:	98 85       	ldd	r25, Y+8	; 0x08
    503a:	a9 85       	ldd	r26, Y+9	; 0x09
    503c:	ba 85       	ldd	r27, Y+10	; 0x0a
    503e:	85 a3       	std	Z+37, r24	; 0x25
    5040:	96 a3       	std	Z+38, r25	; 0x26
    5042:	a7 a3       	std	Z+39, r26	; 0x27
    5044:	b0 a7       	std	Z+40, r27	; 0x28
    5046:	0f c0       	rjmp	.+30     	; 0x5066 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5048:	89 81       	ldd	r24, Y+1	; 0x01
    504a:	82 30       	cpi	r24, 0x02	; 2
    504c:	59 f0       	breq	.+22     	; 0x5064 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    504e:	eb 81       	ldd	r30, Y+3	; 0x03
    5050:	fc 81       	ldd	r31, Y+4	; 0x04
    5052:	8f 81       	ldd	r24, Y+7	; 0x07
    5054:	98 85       	ldd	r25, Y+8	; 0x08
    5056:	a9 85       	ldd	r26, Y+9	; 0x09
    5058:	ba 85       	ldd	r27, Y+10	; 0x0a
    505a:	85 a3       	std	Z+37, r24	; 0x25
    505c:	96 a3       	std	Z+38, r25	; 0x26
    505e:	a7 a3       	std	Z+39, r26	; 0x27
    5060:	b0 a7       	std	Z+40, r27	; 0x28
    5062:	01 c0       	rjmp	.+2      	; 0x5066 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5064:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5066:	89 81       	ldd	r24, Y+1	; 0x01
    5068:	81 30       	cpi	r24, 0x01	; 1
    506a:	b9 f5       	brne	.+110    	; 0x50da <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    506c:	8b 81       	ldd	r24, Y+3	; 0x03
    506e:	9c 81       	ldd	r25, Y+4	; 0x04
    5070:	02 96       	adiw	r24, 0x02	; 2
    5072:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    5076:	eb 81       	ldd	r30, Y+3	; 0x03
    5078:	fc 81       	ldd	r31, Y+4	; 0x04
    507a:	96 89       	ldd	r25, Z+22	; 0x16
    507c:	80 91 a5 03 	lds	r24, 0x03A5
    5080:	89 17       	cp	r24, r25
    5082:	28 f4       	brcc	.+10     	; 0x508e <xTaskGenericNotify+0x152>
    5084:	eb 81       	ldd	r30, Y+3	; 0x03
    5086:	fc 81       	ldd	r31, Y+4	; 0x04
    5088:	86 89       	ldd	r24, Z+22	; 0x16
    508a:	80 93 a5 03 	sts	0x03A5, r24
    508e:	eb 81       	ldd	r30, Y+3	; 0x03
    5090:	fc 81       	ldd	r31, Y+4	; 0x04
    5092:	86 89       	ldd	r24, Z+22	; 0x16
    5094:	28 2f       	mov	r18, r24
    5096:	30 e0       	ldi	r19, 0x00	; 0
    5098:	c9 01       	movw	r24, r18
    509a:	88 0f       	add	r24, r24
    509c:	99 1f       	adc	r25, r25
    509e:	88 0f       	add	r24, r24
    50a0:	99 1f       	adc	r25, r25
    50a2:	88 0f       	add	r24, r24
    50a4:	99 1f       	adc	r25, r25
    50a6:	82 0f       	add	r24, r18
    50a8:	93 1f       	adc	r25, r19
    50aa:	ac 01       	movw	r20, r24
    50ac:	40 55       	subi	r20, 0x50	; 80
    50ae:	5c 4f       	sbci	r21, 0xFC	; 252
    50b0:	8b 81       	ldd	r24, Y+3	; 0x03
    50b2:	9c 81       	ldd	r25, Y+4	; 0x04
    50b4:	9c 01       	movw	r18, r24
    50b6:	2e 5f       	subi	r18, 0xFE	; 254
    50b8:	3f 4f       	sbci	r19, 0xFF	; 255
    50ba:	ca 01       	movw	r24, r20
    50bc:	b9 01       	movw	r22, r18
    50be:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    50c2:	eb 81       	ldd	r30, Y+3	; 0x03
    50c4:	fc 81       	ldd	r31, Y+4	; 0x04
    50c6:	96 89       	ldd	r25, Z+22	; 0x16
    50c8:	e0 91 9f 03 	lds	r30, 0x039F
    50cc:	f0 91 a0 03 	lds	r31, 0x03A0
    50d0:	86 89       	ldd	r24, Z+22	; 0x16
    50d2:	89 17       	cp	r24, r25
    50d4:	10 f4       	brcc	.+4      	; 0x50da <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    50d6:	0e 94 4d 11 	call	0x229a	; 0x229a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    50da:	0f 90       	pop	r0
    50dc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    50de:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    50e0:	2f 96       	adiw	r28, 0x0f	; 15
    50e2:	0f b6       	in	r0, 0x3f	; 63
    50e4:	f8 94       	cli
    50e6:	de bf       	out	0x3e, r29	; 62
    50e8:	0f be       	out	0x3f, r0	; 63
    50ea:	cd bf       	out	0x3d, r28	; 61
    50ec:	cf 91       	pop	r28
    50ee:	df 91       	pop	r29
    50f0:	1f 91       	pop	r17
    50f2:	0f 91       	pop	r16
    50f4:	08 95       	ret

000050f6 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    50f6:	ef 92       	push	r14
    50f8:	ff 92       	push	r15
    50fa:	0f 93       	push	r16
    50fc:	1f 93       	push	r17
    50fe:	df 93       	push	r29
    5100:	cf 93       	push	r28
    5102:	cd b7       	in	r28, 0x3d	; 61
    5104:	de b7       	in	r29, 0x3e	; 62
    5106:	62 97       	sbiw	r28, 0x12	; 18
    5108:	0f b6       	in	r0, 0x3f	; 63
    510a:	f8 94       	cli
    510c:	de bf       	out	0x3e, r29	; 62
    510e:	0f be       	out	0x3f, r0	; 63
    5110:	cd bf       	out	0x3d, r28	; 61
    5112:	9f 83       	std	Y+7, r25	; 0x07
    5114:	8e 83       	std	Y+6, r24	; 0x06
    5116:	48 87       	std	Y+8, r20	; 0x08
    5118:	59 87       	std	Y+9, r21	; 0x09
    511a:	6a 87       	std	Y+10, r22	; 0x0a
    511c:	7b 87       	std	Y+11, r23	; 0x0b
    511e:	2c 87       	std	Y+12, r18	; 0x0c
    5120:	1e 87       	std	Y+14, r17	; 0x0e
    5122:	0d 87       	std	Y+13, r16	; 0x0d
    5124:	f8 8a       	std	Y+16, r15	; 0x10
    5126:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5128:	81 e0       	ldi	r24, 0x01	; 1
    512a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    512c:	8e 81       	ldd	r24, Y+6	; 0x06
    512e:	9f 81       	ldd	r25, Y+7	; 0x07
    5130:	9d 83       	std	Y+5, r25	; 0x05
    5132:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5134:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    5136:	8d 85       	ldd	r24, Y+13	; 0x0d
    5138:	9e 85       	ldd	r25, Y+14	; 0x0e
    513a:	00 97       	sbiw	r24, 0x00	; 0
    513c:	61 f0       	breq	.+24     	; 0x5156 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    513e:	ec 81       	ldd	r30, Y+4	; 0x04
    5140:	fd 81       	ldd	r31, Y+5	; 0x05
    5142:	85 a1       	ldd	r24, Z+37	; 0x25
    5144:	96 a1       	ldd	r25, Z+38	; 0x26
    5146:	a7 a1       	ldd	r26, Z+39	; 0x27
    5148:	b0 a5       	ldd	r27, Z+40	; 0x28
    514a:	ed 85       	ldd	r30, Y+13	; 0x0d
    514c:	fe 85       	ldd	r31, Y+14	; 0x0e
    514e:	80 83       	st	Z, r24
    5150:	91 83       	std	Z+1, r25	; 0x01
    5152:	a2 83       	std	Z+2, r26	; 0x02
    5154:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5156:	ec 81       	ldd	r30, Y+4	; 0x04
    5158:	fd 81       	ldd	r31, Y+5	; 0x05
    515a:	81 a5       	ldd	r24, Z+41	; 0x29
    515c:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    515e:	ec 81       	ldd	r30, Y+4	; 0x04
    5160:	fd 81       	ldd	r31, Y+5	; 0x05
    5162:	82 e0       	ldi	r24, 0x02	; 2
    5164:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    5166:	8c 85       	ldd	r24, Y+12	; 0x0c
    5168:	28 2f       	mov	r18, r24
    516a:	30 e0       	ldi	r19, 0x00	; 0
    516c:	3a 8b       	std	Y+18, r19	; 0x12
    516e:	29 8b       	std	Y+17, r18	; 0x11
    5170:	89 89       	ldd	r24, Y+17	; 0x11
    5172:	9a 89       	ldd	r25, Y+18	; 0x12
    5174:	82 30       	cpi	r24, 0x02	; 2
    5176:	91 05       	cpc	r25, r1
    5178:	59 f1       	breq	.+86     	; 0x51d0 <xTaskGenericNotifyFromISR+0xda>
    517a:	29 89       	ldd	r18, Y+17	; 0x11
    517c:	3a 89       	ldd	r19, Y+18	; 0x12
    517e:	23 30       	cpi	r18, 0x03	; 3
    5180:	31 05       	cpc	r19, r1
    5182:	34 f4       	brge	.+12     	; 0x5190 <xTaskGenericNotifyFromISR+0x9a>
    5184:	89 89       	ldd	r24, Y+17	; 0x11
    5186:	9a 89       	ldd	r25, Y+18	; 0x12
    5188:	81 30       	cpi	r24, 0x01	; 1
    518a:	91 05       	cpc	r25, r1
    518c:	61 f0       	breq	.+24     	; 0x51a6 <xTaskGenericNotifyFromISR+0xb0>
    518e:	4a c0       	rjmp	.+148    	; 0x5224 <xTaskGenericNotifyFromISR+0x12e>
    5190:	29 89       	ldd	r18, Y+17	; 0x11
    5192:	3a 89       	ldd	r19, Y+18	; 0x12
    5194:	23 30       	cpi	r18, 0x03	; 3
    5196:	31 05       	cpc	r19, r1
    5198:	59 f1       	breq	.+86     	; 0x51f0 <xTaskGenericNotifyFromISR+0xfa>
    519a:	89 89       	ldd	r24, Y+17	; 0x11
    519c:	9a 89       	ldd	r25, Y+18	; 0x12
    519e:	84 30       	cpi	r24, 0x04	; 4
    51a0:	91 05       	cpc	r25, r1
    51a2:	89 f1       	breq	.+98     	; 0x5206 <xTaskGenericNotifyFromISR+0x110>
    51a4:	3f c0       	rjmp	.+126    	; 0x5224 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    51a6:	ec 81       	ldd	r30, Y+4	; 0x04
    51a8:	fd 81       	ldd	r31, Y+5	; 0x05
    51aa:	25 a1       	ldd	r18, Z+37	; 0x25
    51ac:	36 a1       	ldd	r19, Z+38	; 0x26
    51ae:	47 a1       	ldd	r20, Z+39	; 0x27
    51b0:	50 a5       	ldd	r21, Z+40	; 0x28
    51b2:	88 85       	ldd	r24, Y+8	; 0x08
    51b4:	99 85       	ldd	r25, Y+9	; 0x09
    51b6:	aa 85       	ldd	r26, Y+10	; 0x0a
    51b8:	bb 85       	ldd	r27, Y+11	; 0x0b
    51ba:	82 2b       	or	r24, r18
    51bc:	93 2b       	or	r25, r19
    51be:	a4 2b       	or	r26, r20
    51c0:	b5 2b       	or	r27, r21
    51c2:	ec 81       	ldd	r30, Y+4	; 0x04
    51c4:	fd 81       	ldd	r31, Y+5	; 0x05
    51c6:	85 a3       	std	Z+37, r24	; 0x25
    51c8:	96 a3       	std	Z+38, r25	; 0x26
    51ca:	a7 a3       	std	Z+39, r26	; 0x27
    51cc:	b0 a7       	std	Z+40, r27	; 0x28
    51ce:	2a c0       	rjmp	.+84     	; 0x5224 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    51d0:	ec 81       	ldd	r30, Y+4	; 0x04
    51d2:	fd 81       	ldd	r31, Y+5	; 0x05
    51d4:	85 a1       	ldd	r24, Z+37	; 0x25
    51d6:	96 a1       	ldd	r25, Z+38	; 0x26
    51d8:	a7 a1       	ldd	r26, Z+39	; 0x27
    51da:	b0 a5       	ldd	r27, Z+40	; 0x28
    51dc:	01 96       	adiw	r24, 0x01	; 1
    51de:	a1 1d       	adc	r26, r1
    51e0:	b1 1d       	adc	r27, r1
    51e2:	ec 81       	ldd	r30, Y+4	; 0x04
    51e4:	fd 81       	ldd	r31, Y+5	; 0x05
    51e6:	85 a3       	std	Z+37, r24	; 0x25
    51e8:	96 a3       	std	Z+38, r25	; 0x26
    51ea:	a7 a3       	std	Z+39, r26	; 0x27
    51ec:	b0 a7       	std	Z+40, r27	; 0x28
    51ee:	1a c0       	rjmp	.+52     	; 0x5224 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    51f0:	ec 81       	ldd	r30, Y+4	; 0x04
    51f2:	fd 81       	ldd	r31, Y+5	; 0x05
    51f4:	88 85       	ldd	r24, Y+8	; 0x08
    51f6:	99 85       	ldd	r25, Y+9	; 0x09
    51f8:	aa 85       	ldd	r26, Y+10	; 0x0a
    51fa:	bb 85       	ldd	r27, Y+11	; 0x0b
    51fc:	85 a3       	std	Z+37, r24	; 0x25
    51fe:	96 a3       	std	Z+38, r25	; 0x26
    5200:	a7 a3       	std	Z+39, r26	; 0x27
    5202:	b0 a7       	std	Z+40, r27	; 0x28
    5204:	0f c0       	rjmp	.+30     	; 0x5224 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5206:	8b 81       	ldd	r24, Y+3	; 0x03
    5208:	82 30       	cpi	r24, 0x02	; 2
    520a:	59 f0       	breq	.+22     	; 0x5222 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    520c:	ec 81       	ldd	r30, Y+4	; 0x04
    520e:	fd 81       	ldd	r31, Y+5	; 0x05
    5210:	88 85       	ldd	r24, Y+8	; 0x08
    5212:	99 85       	ldd	r25, Y+9	; 0x09
    5214:	aa 85       	ldd	r26, Y+10	; 0x0a
    5216:	bb 85       	ldd	r27, Y+11	; 0x0b
    5218:	85 a3       	std	Z+37, r24	; 0x25
    521a:	96 a3       	std	Z+38, r25	; 0x26
    521c:	a7 a3       	std	Z+39, r26	; 0x27
    521e:	b0 a7       	std	Z+40, r27	; 0x28
    5220:	01 c0       	rjmp	.+2      	; 0x5224 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5222:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5224:	8b 81       	ldd	r24, Y+3	; 0x03
    5226:	81 30       	cpi	r24, 0x01	; 1
    5228:	09 f0       	breq	.+2      	; 0x522c <xTaskGenericNotifyFromISR+0x136>
    522a:	50 c0       	rjmp	.+160    	; 0x52cc <xTaskGenericNotifyFromISR+0x1d6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    522c:	80 91 af 03 	lds	r24, 0x03AF
    5230:	88 23       	and	r24, r24
    5232:	61 f5       	brne	.+88     	; 0x528c <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5234:	8c 81       	ldd	r24, Y+4	; 0x04
    5236:	9d 81       	ldd	r25, Y+5	; 0x05
    5238:	02 96       	adiw	r24, 0x02	; 2
    523a:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    523e:	ec 81       	ldd	r30, Y+4	; 0x04
    5240:	fd 81       	ldd	r31, Y+5	; 0x05
    5242:	96 89       	ldd	r25, Z+22	; 0x16
    5244:	80 91 a5 03 	lds	r24, 0x03A5
    5248:	89 17       	cp	r24, r25
    524a:	28 f4       	brcc	.+10     	; 0x5256 <xTaskGenericNotifyFromISR+0x160>
    524c:	ec 81       	ldd	r30, Y+4	; 0x04
    524e:	fd 81       	ldd	r31, Y+5	; 0x05
    5250:	86 89       	ldd	r24, Z+22	; 0x16
    5252:	80 93 a5 03 	sts	0x03A5, r24
    5256:	ec 81       	ldd	r30, Y+4	; 0x04
    5258:	fd 81       	ldd	r31, Y+5	; 0x05
    525a:	86 89       	ldd	r24, Z+22	; 0x16
    525c:	28 2f       	mov	r18, r24
    525e:	30 e0       	ldi	r19, 0x00	; 0
    5260:	c9 01       	movw	r24, r18
    5262:	88 0f       	add	r24, r24
    5264:	99 1f       	adc	r25, r25
    5266:	88 0f       	add	r24, r24
    5268:	99 1f       	adc	r25, r25
    526a:	88 0f       	add	r24, r24
    526c:	99 1f       	adc	r25, r25
    526e:	82 0f       	add	r24, r18
    5270:	93 1f       	adc	r25, r19
    5272:	ac 01       	movw	r20, r24
    5274:	40 55       	subi	r20, 0x50	; 80
    5276:	5c 4f       	sbci	r21, 0xFC	; 252
    5278:	8c 81       	ldd	r24, Y+4	; 0x04
    527a:	9d 81       	ldd	r25, Y+5	; 0x05
    527c:	9c 01       	movw	r18, r24
    527e:	2e 5f       	subi	r18, 0xFE	; 254
    5280:	3f 4f       	sbci	r19, 0xFF	; 255
    5282:	ca 01       	movw	r24, r20
    5284:	b9 01       	movw	r22, r18
    5286:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
    528a:	0a c0       	rjmp	.+20     	; 0x52a0 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    528c:	8c 81       	ldd	r24, Y+4	; 0x04
    528e:	9d 81       	ldd	r25, Y+5	; 0x05
    5290:	9c 01       	movw	r18, r24
    5292:	24 5f       	subi	r18, 0xF4	; 244
    5294:	3f 4f       	sbci	r19, 0xFF	; 255
    5296:	83 ef       	ldi	r24, 0xF3	; 243
    5298:	93 e0       	ldi	r25, 0x03	; 3
    529a:	b9 01       	movw	r22, r18
    529c:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    52a0:	ec 81       	ldd	r30, Y+4	; 0x04
    52a2:	fd 81       	ldd	r31, Y+5	; 0x05
    52a4:	96 89       	ldd	r25, Z+22	; 0x16
    52a6:	e0 91 9f 03 	lds	r30, 0x039F
    52aa:	f0 91 a0 03 	lds	r31, 0x03A0
    52ae:	86 89       	ldd	r24, Z+22	; 0x16
    52b0:	89 17       	cp	r24, r25
    52b2:	60 f4       	brcc	.+24     	; 0x52cc <xTaskGenericNotifyFromISR+0x1d6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    52b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    52b6:	98 89       	ldd	r25, Y+16	; 0x10
    52b8:	00 97       	sbiw	r24, 0x00	; 0
    52ba:	29 f0       	breq	.+10     	; 0x52c6 <xTaskGenericNotifyFromISR+0x1d0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    52bc:	ef 85       	ldd	r30, Y+15	; 0x0f
    52be:	f8 89       	ldd	r31, Y+16	; 0x10
    52c0:	81 e0       	ldi	r24, 0x01	; 1
    52c2:	80 83       	st	Z, r24
    52c4:	03 c0       	rjmp	.+6      	; 0x52cc <xTaskGenericNotifyFromISR+0x1d6>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    52c6:	81 e0       	ldi	r24, 0x01	; 1
    52c8:	80 93 a8 03 	sts	0x03A8, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    52cc:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    52ce:	62 96       	adiw	r28, 0x12	; 18
    52d0:	0f b6       	in	r0, 0x3f	; 63
    52d2:	f8 94       	cli
    52d4:	de bf       	out	0x3e, r29	; 62
    52d6:	0f be       	out	0x3f, r0	; 63
    52d8:	cd bf       	out	0x3d, r28	; 61
    52da:	cf 91       	pop	r28
    52dc:	df 91       	pop	r29
    52de:	1f 91       	pop	r17
    52e0:	0f 91       	pop	r16
    52e2:	ff 90       	pop	r15
    52e4:	ef 90       	pop	r14
    52e6:	08 95       	ret

000052e8 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    52e8:	df 93       	push	r29
    52ea:	cf 93       	push	r28
    52ec:	cd b7       	in	r28, 0x3d	; 61
    52ee:	de b7       	in	r29, 0x3e	; 62
    52f0:	28 97       	sbiw	r28, 0x08	; 8
    52f2:	0f b6       	in	r0, 0x3f	; 63
    52f4:	f8 94       	cli
    52f6:	de bf       	out	0x3e, r29	; 62
    52f8:	0f be       	out	0x3f, r0	; 63
    52fa:	cd bf       	out	0x3d, r28	; 61
    52fc:	9e 83       	std	Y+6, r25	; 0x06
    52fe:	8d 83       	std	Y+5, r24	; 0x05
    5300:	78 87       	std	Y+8, r23	; 0x08
    5302:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    5304:	8d 81       	ldd	r24, Y+5	; 0x05
    5306:	9e 81       	ldd	r25, Y+6	; 0x06
    5308:	9c 83       	std	Y+4, r25	; 0x04
    530a:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    530c:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    530e:	eb 81       	ldd	r30, Y+3	; 0x03
    5310:	fc 81       	ldd	r31, Y+4	; 0x04
    5312:	81 a5       	ldd	r24, Z+41	; 0x29
    5314:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5316:	eb 81       	ldd	r30, Y+3	; 0x03
    5318:	fc 81       	ldd	r31, Y+4	; 0x04
    531a:	82 e0       	ldi	r24, 0x02	; 2
    531c:	81 a7       	std	Z+41, r24	; 0x29

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    531e:	eb 81       	ldd	r30, Y+3	; 0x03
    5320:	fc 81       	ldd	r31, Y+4	; 0x04
    5322:	85 a1       	ldd	r24, Z+37	; 0x25
    5324:	96 a1       	ldd	r25, Z+38	; 0x26
    5326:	a7 a1       	ldd	r26, Z+39	; 0x27
    5328:	b0 a5       	ldd	r27, Z+40	; 0x28
    532a:	01 96       	adiw	r24, 0x01	; 1
    532c:	a1 1d       	adc	r26, r1
    532e:	b1 1d       	adc	r27, r1
    5330:	eb 81       	ldd	r30, Y+3	; 0x03
    5332:	fc 81       	ldd	r31, Y+4	; 0x04
    5334:	85 a3       	std	Z+37, r24	; 0x25
    5336:	96 a3       	std	Z+38, r25	; 0x26
    5338:	a7 a3       	std	Z+39, r26	; 0x27
    533a:	b0 a7       	std	Z+40, r27	; 0x28

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    533c:	8a 81       	ldd	r24, Y+2	; 0x02
    533e:	81 30       	cpi	r24, 0x01	; 1
    5340:	09 f0       	breq	.+2      	; 0x5344 <vTaskNotifyGiveFromISR+0x5c>
    5342:	50 c0       	rjmp	.+160    	; 0x53e4 <vTaskNotifyGiveFromISR+0xfc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5344:	80 91 af 03 	lds	r24, 0x03AF
    5348:	88 23       	and	r24, r24
    534a:	61 f5       	brne	.+88     	; 0x53a4 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    534c:	8b 81       	ldd	r24, Y+3	; 0x03
    534e:	9c 81       	ldd	r25, Y+4	; 0x04
    5350:	02 96       	adiw	r24, 0x02	; 2
    5352:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5356:	eb 81       	ldd	r30, Y+3	; 0x03
    5358:	fc 81       	ldd	r31, Y+4	; 0x04
    535a:	96 89       	ldd	r25, Z+22	; 0x16
    535c:	80 91 a5 03 	lds	r24, 0x03A5
    5360:	89 17       	cp	r24, r25
    5362:	28 f4       	brcc	.+10     	; 0x536e <vTaskNotifyGiveFromISR+0x86>
    5364:	eb 81       	ldd	r30, Y+3	; 0x03
    5366:	fc 81       	ldd	r31, Y+4	; 0x04
    5368:	86 89       	ldd	r24, Z+22	; 0x16
    536a:	80 93 a5 03 	sts	0x03A5, r24
    536e:	eb 81       	ldd	r30, Y+3	; 0x03
    5370:	fc 81       	ldd	r31, Y+4	; 0x04
    5372:	86 89       	ldd	r24, Z+22	; 0x16
    5374:	28 2f       	mov	r18, r24
    5376:	30 e0       	ldi	r19, 0x00	; 0
    5378:	c9 01       	movw	r24, r18
    537a:	88 0f       	add	r24, r24
    537c:	99 1f       	adc	r25, r25
    537e:	88 0f       	add	r24, r24
    5380:	99 1f       	adc	r25, r25
    5382:	88 0f       	add	r24, r24
    5384:	99 1f       	adc	r25, r25
    5386:	82 0f       	add	r24, r18
    5388:	93 1f       	adc	r25, r19
    538a:	ac 01       	movw	r20, r24
    538c:	40 55       	subi	r20, 0x50	; 80
    538e:	5c 4f       	sbci	r21, 0xFC	; 252
    5390:	8b 81       	ldd	r24, Y+3	; 0x03
    5392:	9c 81       	ldd	r25, Y+4	; 0x04
    5394:	9c 01       	movw	r18, r24
    5396:	2e 5f       	subi	r18, 0xFE	; 254
    5398:	3f 4f       	sbci	r19, 0xFF	; 255
    539a:	ca 01       	movw	r24, r20
    539c:	b9 01       	movw	r22, r18
    539e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
    53a2:	0a c0       	rjmp	.+20     	; 0x53b8 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    53a4:	8b 81       	ldd	r24, Y+3	; 0x03
    53a6:	9c 81       	ldd	r25, Y+4	; 0x04
    53a8:	9c 01       	movw	r18, r24
    53aa:	24 5f       	subi	r18, 0xF4	; 244
    53ac:	3f 4f       	sbci	r19, 0xFF	; 255
    53ae:	83 ef       	ldi	r24, 0xF3	; 243
    53b0:	93 e0       	ldi	r25, 0x03	; 3
    53b2:	b9 01       	movw	r22, r18
    53b4:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    53b8:	eb 81       	ldd	r30, Y+3	; 0x03
    53ba:	fc 81       	ldd	r31, Y+4	; 0x04
    53bc:	96 89       	ldd	r25, Z+22	; 0x16
    53be:	e0 91 9f 03 	lds	r30, 0x039F
    53c2:	f0 91 a0 03 	lds	r31, 0x03A0
    53c6:	86 89       	ldd	r24, Z+22	; 0x16
    53c8:	89 17       	cp	r24, r25
    53ca:	60 f4       	brcc	.+24     	; 0x53e4 <vTaskNotifyGiveFromISR+0xfc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    53cc:	8f 81       	ldd	r24, Y+7	; 0x07
    53ce:	98 85       	ldd	r25, Y+8	; 0x08
    53d0:	00 97       	sbiw	r24, 0x00	; 0
    53d2:	29 f0       	breq	.+10     	; 0x53de <vTaskNotifyGiveFromISR+0xf6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    53d4:	ef 81       	ldd	r30, Y+7	; 0x07
    53d6:	f8 85       	ldd	r31, Y+8	; 0x08
    53d8:	81 e0       	ldi	r24, 0x01	; 1
    53da:	80 83       	st	Z, r24
    53dc:	03 c0       	rjmp	.+6      	; 0x53e4 <vTaskNotifyGiveFromISR+0xfc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    53de:	81 e0       	ldi	r24, 0x01	; 1
    53e0:	80 93 a8 03 	sts	0x03A8, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    53e4:	28 96       	adiw	r28, 0x08	; 8
    53e6:	0f b6       	in	r0, 0x3f	; 63
    53e8:	f8 94       	cli
    53ea:	de bf       	out	0x3e, r29	; 62
    53ec:	0f be       	out	0x3f, r0	; 63
    53ee:	cd bf       	out	0x3d, r28	; 61
    53f0:	cf 91       	pop	r28
    53f2:	df 91       	pop	r29
    53f4:	08 95       	ret

000053f6 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    53f6:	df 93       	push	r29
    53f8:	cf 93       	push	r28
    53fa:	cd b7       	in	r28, 0x3d	; 61
    53fc:	de b7       	in	r29, 0x3e	; 62
    53fe:	27 97       	sbiw	r28, 0x07	; 7
    5400:	0f b6       	in	r0, 0x3f	; 63
    5402:	f8 94       	cli
    5404:	de bf       	out	0x3e, r29	; 62
    5406:	0f be       	out	0x3f, r0	; 63
    5408:	cd bf       	out	0x3d, r28	; 61
    540a:	9d 83       	std	Y+5, r25	; 0x05
    540c:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    540e:	8c 81       	ldd	r24, Y+4	; 0x04
    5410:	9d 81       	ldd	r25, Y+5	; 0x05
    5412:	00 97       	sbiw	r24, 0x00	; 0
    5414:	39 f4       	brne	.+14     	; 0x5424 <xTaskNotifyStateClear+0x2e>
    5416:	80 91 9f 03 	lds	r24, 0x039F
    541a:	90 91 a0 03 	lds	r25, 0x03A0
    541e:	9f 83       	std	Y+7, r25	; 0x07
    5420:	8e 83       	std	Y+6, r24	; 0x06
    5422:	04 c0       	rjmp	.+8      	; 0x542c <xTaskNotifyStateClear+0x36>
    5424:	8c 81       	ldd	r24, Y+4	; 0x04
    5426:	9d 81       	ldd	r25, Y+5	; 0x05
    5428:	9f 83       	std	Y+7, r25	; 0x07
    542a:	8e 83       	std	Y+6, r24	; 0x06
    542c:	8e 81       	ldd	r24, Y+6	; 0x06
    542e:	9f 81       	ldd	r25, Y+7	; 0x07
    5430:	9b 83       	std	Y+3, r25	; 0x03
    5432:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5434:	0f b6       	in	r0, 0x3f	; 63
    5436:	f8 94       	cli
    5438:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    543a:	ea 81       	ldd	r30, Y+2	; 0x02
    543c:	fb 81       	ldd	r31, Y+3	; 0x03
    543e:	81 a5       	ldd	r24, Z+41	; 0x29
    5440:	82 30       	cpi	r24, 0x02	; 2
    5442:	31 f4       	brne	.+12     	; 0x5450 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5444:	ea 81       	ldd	r30, Y+2	; 0x02
    5446:	fb 81       	ldd	r31, Y+3	; 0x03
    5448:	11 a6       	std	Z+41, r1	; 0x29
				xReturn = pdPASS;
    544a:	81 e0       	ldi	r24, 0x01	; 1
    544c:	89 83       	std	Y+1, r24	; 0x01
    544e:	01 c0       	rjmp	.+2      	; 0x5452 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5450:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5452:	0f 90       	pop	r0
    5454:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5456:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5458:	27 96       	adiw	r28, 0x07	; 7
    545a:	0f b6       	in	r0, 0x3f	; 63
    545c:	f8 94       	cli
    545e:	de bf       	out	0x3e, r29	; 62
    5460:	0f be       	out	0x3f, r0	; 63
    5462:	cd bf       	out	0x3d, r28	; 61
    5464:	cf 91       	pop	r28
    5466:	df 91       	pop	r29
    5468:	08 95       	ret

0000546a <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    546a:	df 93       	push	r29
    546c:	cf 93       	push	r28
    546e:	cd b7       	in	r28, 0x3d	; 61
    5470:	de b7       	in	r29, 0x3e	; 62
    5472:	27 97       	sbiw	r28, 0x07	; 7
    5474:	0f b6       	in	r0, 0x3f	; 63
    5476:	f8 94       	cli
    5478:	de bf       	out	0x3e, r29	; 62
    547a:	0f be       	out	0x3f, r0	; 63
    547c:	cd bf       	out	0x3d, r28	; 61
    547e:	9e 83       	std	Y+6, r25	; 0x06
    5480:	8d 83       	std	Y+5, r24	; 0x05
    5482:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5484:	80 91 a3 03 	lds	r24, 0x03A3
    5488:	90 91 a4 03 	lds	r25, 0x03A4
    548c:	9a 83       	std	Y+2, r25	; 0x02
    548e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5490:	80 91 9f 03 	lds	r24, 0x039F
    5494:	90 91 a0 03 	lds	r25, 0x03A0
    5498:	02 96       	adiw	r24, 0x02	; 2
    549a:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    549e:	8d 81       	ldd	r24, Y+5	; 0x05
    54a0:	9e 81       	ldd	r25, Y+6	; 0x06
    54a2:	2f ef       	ldi	r18, 0xFF	; 255
    54a4:	8f 3f       	cpi	r24, 0xFF	; 255
    54a6:	92 07       	cpc	r25, r18
    54a8:	81 f4       	brne	.+32     	; 0x54ca <prvAddCurrentTaskToDelayedList+0x60>
    54aa:	8f 81       	ldd	r24, Y+7	; 0x07
    54ac:	88 23       	and	r24, r24
    54ae:	69 f0       	breq	.+26     	; 0x54ca <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    54b0:	80 91 9f 03 	lds	r24, 0x039F
    54b4:	90 91 a0 03 	lds	r25, 0x03A0
    54b8:	9c 01       	movw	r18, r24
    54ba:	2e 5f       	subi	r18, 0xFE	; 254
    54bc:	3f 4f       	sbci	r19, 0xFF	; 255
    54be:	85 e0       	ldi	r24, 0x05	; 5
    54c0:	94 e0       	ldi	r25, 0x04	; 4
    54c2:	b9 01       	movw	r22, r18
    54c4:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vListInsertEnd>
    54c8:	43 c0       	rjmp	.+134    	; 0x5550 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    54ca:	29 81       	ldd	r18, Y+1	; 0x01
    54cc:	3a 81       	ldd	r19, Y+2	; 0x02
    54ce:	8d 81       	ldd	r24, Y+5	; 0x05
    54d0:	9e 81       	ldd	r25, Y+6	; 0x06
    54d2:	82 0f       	add	r24, r18
    54d4:	93 1f       	adc	r25, r19
    54d6:	9c 83       	std	Y+4, r25	; 0x04
    54d8:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    54da:	e0 91 9f 03 	lds	r30, 0x039F
    54de:	f0 91 a0 03 	lds	r31, 0x03A0
    54e2:	8b 81       	ldd	r24, Y+3	; 0x03
    54e4:	9c 81       	ldd	r25, Y+4	; 0x04
    54e6:	93 83       	std	Z+3, r25	; 0x03
    54e8:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    54ea:	2b 81       	ldd	r18, Y+3	; 0x03
    54ec:	3c 81       	ldd	r19, Y+4	; 0x04
    54ee:	89 81       	ldd	r24, Y+1	; 0x01
    54f0:	9a 81       	ldd	r25, Y+2	; 0x02
    54f2:	28 17       	cp	r18, r24
    54f4:	39 07       	cpc	r19, r25
    54f6:	70 f4       	brcc	.+28     	; 0x5514 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    54f8:	80 91 f1 03 	lds	r24, 0x03F1
    54fc:	90 91 f2 03 	lds	r25, 0x03F2
    5500:	20 91 9f 03 	lds	r18, 0x039F
    5504:	30 91 a0 03 	lds	r19, 0x03A0
    5508:	2e 5f       	subi	r18, 0xFE	; 254
    550a:	3f 4f       	sbci	r19, 0xFF	; 255
    550c:	b9 01       	movw	r22, r18
    550e:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <vListInsert>
    5512:	1e c0       	rjmp	.+60     	; 0x5550 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5514:	40 91 ef 03 	lds	r20, 0x03EF
    5518:	50 91 f0 03 	lds	r21, 0x03F0
    551c:	80 91 9f 03 	lds	r24, 0x039F
    5520:	90 91 a0 03 	lds	r25, 0x03A0
    5524:	9c 01       	movw	r18, r24
    5526:	2e 5f       	subi	r18, 0xFE	; 254
    5528:	3f 4f       	sbci	r19, 0xFF	; 255
    552a:	ca 01       	movw	r24, r20
    552c:	b9 01       	movw	r22, r18
    552e:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5532:	20 91 ab 03 	lds	r18, 0x03AB
    5536:	30 91 ac 03 	lds	r19, 0x03AC
    553a:	8b 81       	ldd	r24, Y+3	; 0x03
    553c:	9c 81       	ldd	r25, Y+4	; 0x04
    553e:	82 17       	cp	r24, r18
    5540:	93 07       	cpc	r25, r19
    5542:	30 f4       	brcc	.+12     	; 0x5550 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5544:	8b 81       	ldd	r24, Y+3	; 0x03
    5546:	9c 81       	ldd	r25, Y+4	; 0x04
    5548:	90 93 ac 03 	sts	0x03AC, r25
    554c:	80 93 ab 03 	sts	0x03AB, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5550:	27 96       	adiw	r28, 0x07	; 7
    5552:	0f b6       	in	r0, 0x3f	; 63
    5554:	f8 94       	cli
    5556:	de bf       	out	0x3e, r29	; 62
    5558:	0f be       	out	0x3f, r0	; 63
    555a:	cd bf       	out	0x3d, r28	; 61
    555c:	cf 91       	pop	r28
    555e:	df 91       	pop	r29
    5560:	08 95       	ret

00005562 <__prologue_saves__>:
    5562:	2f 92       	push	r2
    5564:	3f 92       	push	r3
    5566:	4f 92       	push	r4
    5568:	5f 92       	push	r5
    556a:	6f 92       	push	r6
    556c:	7f 92       	push	r7
    556e:	8f 92       	push	r8
    5570:	9f 92       	push	r9
    5572:	af 92       	push	r10
    5574:	bf 92       	push	r11
    5576:	cf 92       	push	r12
    5578:	df 92       	push	r13
    557a:	ef 92       	push	r14
    557c:	ff 92       	push	r15
    557e:	0f 93       	push	r16
    5580:	1f 93       	push	r17
    5582:	cf 93       	push	r28
    5584:	df 93       	push	r29
    5586:	cd b7       	in	r28, 0x3d	; 61
    5588:	de b7       	in	r29, 0x3e	; 62
    558a:	ca 1b       	sub	r28, r26
    558c:	db 0b       	sbc	r29, r27
    558e:	0f b6       	in	r0, 0x3f	; 63
    5590:	f8 94       	cli
    5592:	de bf       	out	0x3e, r29	; 62
    5594:	0f be       	out	0x3f, r0	; 63
    5596:	cd bf       	out	0x3d, r28	; 61
    5598:	09 94       	ijmp

0000559a <__epilogue_restores__>:
    559a:	2a 88       	ldd	r2, Y+18	; 0x12
    559c:	39 88       	ldd	r3, Y+17	; 0x11
    559e:	48 88       	ldd	r4, Y+16	; 0x10
    55a0:	5f 84       	ldd	r5, Y+15	; 0x0f
    55a2:	6e 84       	ldd	r6, Y+14	; 0x0e
    55a4:	7d 84       	ldd	r7, Y+13	; 0x0d
    55a6:	8c 84       	ldd	r8, Y+12	; 0x0c
    55a8:	9b 84       	ldd	r9, Y+11	; 0x0b
    55aa:	aa 84       	ldd	r10, Y+10	; 0x0a
    55ac:	b9 84       	ldd	r11, Y+9	; 0x09
    55ae:	c8 84       	ldd	r12, Y+8	; 0x08
    55b0:	df 80       	ldd	r13, Y+7	; 0x07
    55b2:	ee 80       	ldd	r14, Y+6	; 0x06
    55b4:	fd 80       	ldd	r15, Y+5	; 0x05
    55b6:	0c 81       	ldd	r16, Y+4	; 0x04
    55b8:	1b 81       	ldd	r17, Y+3	; 0x03
    55ba:	aa 81       	ldd	r26, Y+2	; 0x02
    55bc:	b9 81       	ldd	r27, Y+1	; 0x01
    55be:	ce 0f       	add	r28, r30
    55c0:	d1 1d       	adc	r29, r1
    55c2:	0f b6       	in	r0, 0x3f	; 63
    55c4:	f8 94       	cli
    55c6:	de bf       	out	0x3e, r29	; 62
    55c8:	0f be       	out	0x3f, r0	; 63
    55ca:	cd bf       	out	0x3d, r28	; 61
    55cc:	ed 01       	movw	r28, r26
    55ce:	08 95       	ret

000055d0 <memcpy>:
    55d0:	fb 01       	movw	r30, r22
    55d2:	dc 01       	movw	r26, r24
    55d4:	02 c0       	rjmp	.+4      	; 0x55da <memcpy+0xa>
    55d6:	01 90       	ld	r0, Z+
    55d8:	0d 92       	st	X+, r0
    55da:	41 50       	subi	r20, 0x01	; 1
    55dc:	50 40       	sbci	r21, 0x00	; 0
    55de:	d8 f7       	brcc	.-10     	; 0x55d6 <memcpy+0x6>
    55e0:	08 95       	ret

000055e2 <_exit>:
    55e2:	f8 94       	cli

000055e4 <__stop_program>:
    55e4:	ff cf       	rjmp	.-2      	; 0x55e4 <__stop_program>
